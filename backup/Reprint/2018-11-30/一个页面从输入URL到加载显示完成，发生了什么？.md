---
title: '一个页面从输入URL到加载显示完成，发生了什么？' 
date: 2018-11-30 2:30:12
hidden: true
slug: gvur7ks9frc
categories: [reprint]
---

{{< raw >}}

                    
<h2 id="articleHeader0">面试经典题——URL加载</h2>
<h3 id="articleHeader1">一、涉及基本知识点：</h3>
<p><strong>1. 计算机网络</strong></p>
<ol>
<li>
<p>五层因特尔协议栈：</p>
<ul>
<li>应用层（dns、http）：DNS解析成IP并完成http请求发送；</li>
<li>传输层（tcp、udp）：三次握手四次挥手模式建立tcp连接；</li>
<li>网络层（IP、ARP）：IP寻址；</li>
<li>数据链路层（PPP）：将请求数据封装成帧；</li>
<li>物理层：利用物理介质传输比特流（传输的时候通过双绞线、电磁波等）</li>
<li>
<strong>OIS七层框架</strong>:多了两层即，会话层（处理两个通信系统中交换信息的表示方式）和表示层（管理不同用户和进程之间的对话）。</li>
</ul>
</li>
<li>
<p><strong>get和post的区别</strong>：</p>
<ul>
<li>get产生一个tcp数据包，post产生两个</li>
<li>get请求时会把headers和data数据一起发送出去；</li>
<li>post请求时，浏览器先发送headers，服务器100继续，浏览器再发送data。</li>
</ul>
</li>
<li>
<p><strong>DNS查询得到IP</strong></p>
<ol>
<li>请求信息：首先查看域名的本地DNS缓存，该缓存存储计算机最近检索到的信息，如果计算机不知道答案，那么就需要执行一个DNS查询来查找答案；</li>
<li>
<p>询问递归式DNS服务器：</p>
<ul>
<li>如果信息不存储在本地，计算机会联系您的ISP（网络提供商）的递归DNS服务器；</li>
<li>这些专用计算机会为你执行一个DNS查询工作；</li>
<li>递归服务器有自己的缓存，所以这个查询过程通常在这里完成，并将信息还回给用户；</li>
</ul>
</li>
<li>
<p>询问根域名服务器</p>
<ul>
<li>如果递归服务器没有答案，他们会查询根域名服务器；</li>
<li>根域名服务器是一种计算机，它扮演着一种DNS的电话接线员的角色，他们不知道答案，但可以将我们的疑问指向知道在哪里可以找到答案的人。</li>
</ul>
</li>
<li>
<p>询问TLD域名服务器：</p>
<ul>
<li>根域名服务器将查看请求的第一部分，按从右到左的顺序，从www.dyn.com中找到.com，并将请求指向.com对应的顶级域名服务器（TLD）.com;</li>
<li>每个TLD，如（.com,.org,.us）都有自己的顶级域名服务器，</li>
<li>这些服务器没有我们需要的信息，但他们可以直接将我们引导到有信息的服务器。</li>
</ul>
</li>
<li>
<p>询问权威的DNS服务器</p>
<ul>
<li>TLD域名服务器会继续检查请求的下一部分（dyn）www.dyn.com，并将查询指向负责此特定域名的服务器；</li>
<li>这些权威的服务器将负责了解关于特定域的所有信息，并将信息存储在DNS记录。</li>
</ul>
</li>
<li>
<p>找回记录：<br> -递归服务器从权威服务器中检索dyn.com的记录，并将记录存储在本地缓存；</p>
<ul>
<li>如果其他任何人请求dyn.com的主机记录，递归服务器已经有答案了，并不需要再次进行查找；</li>
<li>所有记录都有一个期限，一段时间后，递归服务器将需要要求一个新的记录副本，以确保信息不回过时。</li>
</ul>
</li>
<li>
<p>接收答案：</p>
<ul>
<li>有了答案，递归服务器将记录返回到计算机，</li>
<li>您的计算机将记录存储在缓存中，从记录中读取IP地址，然后将这些信息传递给浏览器；</li>
<li>然后浏览器就可以根据IP地址和服务器进行连接建立。</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>TCPIP请求</strong></p>
<ul>
<li>http的本质就是TCPIP请求；</li>
<li>需要经历3次握手建立连接，4次挥手断开连接；</li>
<li>TCP将http长报文划分为短报文，通过三次握手与服务器端建立连接，进行可靠传输。</li>
<li>
<p><strong>三次握手：</strong></p>
<ul>
<li>客户端：你是XXX服务端吗？</li>
<li>服务端： 我是XXX服务端，你是客户端吗？</li>
<li>客服端： 是的，我是客户端</li>
<li>建立连接成功后，接下来就可以进行正式的传输数据。</li>
</ul>
</li>
<li>
<p><strong>四次挥手断开连接</strong></p>
<ul>
<li>主动方：我已经关闭了向你那边的信息发送通道，只能被动接受信息了；</li>
<li>被动方： 收到通道关闭的信息；</li>
<li>被动方： 我现在也关闭了向你那边发送信息的通道</li>
<li>主动方： 左后收到信息，连接断开，之后双方无法通信</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>TCP/IP的并发限制：</strong></p>
<ul>
<li>浏览器对同一个域名下并发的TCP连接是有限制的（2-10个不等）</li>
<li>而且在http1.0中往往一个资源的下载就需要一个tcp/ip请求</li>
</ul>
</li>
</ol>
<hr>
<p><strong>2. 浏览器机制</strong></p>
<p><strong>（1）进程和线程的概念</strong></p>
<ol>
<li>进程是CPU资源分配的最小单位，是能拥有资源和独立运行的最小单位；</li>
<li>线程是CPU调度的最小单位，线程是建立在进程的基础上的一次程序运行单位，一个进程可以拥有多个线程；</li>
<li>通俗的讲：进程是一个工厂，工厂有它独立的资源，工厂之间相互独立-&gt;进程之间相互独立，线程是工厂中的工人，多个工人之间可以协作完成任务，工厂内有一个或多个工人，工人之间共享空间。</li>
</ol>
<p><strong>（2）多进程的浏览器</strong></p>
<blockquote>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会开一个进程（某些情况下多个tab由于优化策略会合并）</blockquote>
<ul><li>浏览器主要进程：</li></ul>
<ol>
<li>
<p><strong>Browser进程：浏览器的主进程，负责协调、主控，只有一个，作用：</strong></p>
<ul>
<li>负责浏览器界面的显示、与用户交互（如前进、后退等）</li>
<li>负责各个页面的管理，创建和销毁其他进程；</li>
<li>将Renderer进程得到的内存中的Bitmap绘制到用户界面上</li>
<li>网络资源的管理和下载等</li>
</ul>
</li>
<li><strong>第三方插件进程： 每种类型的插件对应一个进程，仅当该插件使用时才创建；</strong></li>
<li>
<strong>GPU进程</strong>： 最多一个，用于3D绘制等；</li>
<li>
<p><strong>浏览器渲染进程（Renderer进程、浏览器内核、内部是多线程）</strong>：</p>
<ul>
<li>默认没打开一个tab页面，就会启动一个Renderer进程；</li>
<li>负责页面的渲染，脚本的执行，事件的处理。</li>
</ul>
</li>
</ol>
<ul><li>
<p>浏览器多进程的优势</p>
<ol>
<li>避免单个page crash影响整个浏览器；</li>
<li>避免第三方插件crash影响整个浏览器</li>
<li>多进程充分利用多核优势；</li>
<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>
</ol>
</li></ul>
<blockquote>简单点理解：如果浏览器是单进程，那么某个tab页或第三方插件崩溃了，就会导致整个浏览器崩溃，体验度极差，不过多进程内存消耗会更大，有点用空间换时间。</blockquote>
<p><strong>浏览器内核（渲染进程）</strong></p>
<ul><li>浏览器渲染进程内部是多线程，包含主要线程有：</li></ul>
<p><strong>1.GUI渲染线程：</strong></p>
<ul>
<li>（1）负责浏览器界面的渲染，解析HTML、CSS，构建DOM树和RenderObject树，布局和绘制等；</li>
<li>（2） 当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时该线程会执行；</li>
<li>
<strong>注意：GUI渲染线程和JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起，GUI更新会保存在一个队列中等JS引擎空闲时立即执行。</li>
</ul>
<p><strong>2.JS引擎线程：</strong></p>
<ul>
<li>JS内核，负责处理JavaScript脚本程序（V8引擎）</li>
<li>负责解析JavaScript脚本，运行代码；</li>
<li>JS引擎一直等待着任务队列中的任务到来，然后加以处理，一个tab页面（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序；</li>
<li>
<strong>注意：由于GUI渲染线程和JS引擎线程是互斥的</strong>，所以如果JS程序运行时间过长，这样会导致页面渲染不连贯，导致页面渲染加载阻塞；</li>
</ul>
<p><strong>3.事件触发线程：</strong></p>
<ul>
<li>归属于浏览器，而不是JS引擎，用来控制事件循环；</li>
<li>当JS引擎执行代码块如setTimeOut时（也可以来自浏览器内核的其他线程，如鼠标单击事件、AJAX异步请求等），会将对应的任务添加到事件线程中；</li>
<li>当对应的事件符合触发条件被触发时，该线程就会把事件添加到JS的待处理队列的队尾，等待JS引擎的处理；</li>
<li>
<strong>注意：由于JS的单线程的关系</strong>所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。</li>
</ul>
<p><strong>4.定时触发器线程：</strong></p>
<ul>
<li>setTimeOut与setInterval所在的线程；</li>
<li>浏览器的定时计数器并不是由JavaScript引擎计数的，（因为JavaScript是单线程，如果处于阻塞状态就会影响计时的准确）因此通过单独的线程来计时并触发定时（计时完毕后，添加到事件队列，等待JS引擎空闲时执行）</li>
</ul>
<p><strong>5.异步http请求线程：</strong></p>
<ul>
<li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求的</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就将产生状态变更事件，将这个回调在放到事件队列中，再由JavaScript引擎执行。</li>
</ul>
<h3 id="articleHeader2">一、 一个页面从输入URL到加载显示完成，这个过程发生了什么？</h3>
<ul>
<li>
<p>简洁版：</p>
<ul>
<li>浏览器根据请求的URL交给DNS域名解析，找到真实的IP，向服务器发起请求；</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、CSS、JavaScript等）；</li>
<li>浏览器对加载到的资源（HTML、CSS、JavaScript等）进行语法解析，构建相应的内部数据结构（DOM树、CSS树、render树等）；</li>
<li>载入解析到的资源文件、渲染页面、完成。</li>
</ul>
</li>
<li>
<p>详细版：</p>
<ol>
<li>首先浏览器开启一个线程来处理这个请求，对URL分析判断，如果是http协议就按照Web方式来处理；</li>
<li>其次浏览器会对URL进行解析，一般包括（协议头、主机域名或IP地址、端口号、请求路径、查询参数、hash等），然后开启网络线程发出一个完整到http请求；</li>
<li>当然一般我们输入的URL是服务器域名，这时就需要DNS通过域名查询得到对应的IP；</li>
<li>DNS首先会查看浏览器DNS缓存，没有就查询计算机本地DNS缓存，还没有就询问递归式DNS服务器（即网络提供商，一般这个服务器都会有自己的缓存，所以IP查询一般在这里完成），如果没有缓存，那就需要通过根域名和TLD域名服务器指到对应的权威DNS服务器找回记录，并缓存到递归式服务器，然后递归服务器在将记录返回给本地。</li>
<li>有了IP地址，此时网络层便会通过IP地址寻的对应服务器的物理地址</li>
<li>寻得服务器地址，客户端在网络传输层便可以和服务器通过三次握手建立tcpip连接</li>
<li>连接建立后网络数据链路层将数据包装成帧；</li>
<li>最后物理层利用物理介质进行传输；</li>
<li>到了服务器，就会通过相反的方式将数据一层一层的还原回去；</li>
<li>请求到了后台服务器，一般会有统一的验证，如安全验证、跨域验证等，验证未通过就直接返回相应的http报文</li>
<li>验证通过后，就会进入后台代码，此时程序收到请求，然后执行对应的操作（如查询数据库等）；</li>
<li>如果浏览器访问过，且缓存上有对应的资源，便会与服务器最后修改时间对比，一致便返回304，告诉浏览器可使用本地缓存；</li>
<li>前端浏览器接收到响应成功的报文后便开始下载网页</li>
<li>
<p>下载完的网页将被交给浏览器内核（渲染进程）进行处理：</p>
<ol>
<li>根据顶部定义的DTD类型进行对应的解析方式；</li>
<li>渲染进程内部是多线程的，网页的解析将会被交给内部的GUI渲染线程处理；</li>
<li>首先渲染线程中的HTML解释器，将HTML网页和资源从字节流解释转换成字符流；</li>
<li>再通过词法分析器将字符流解释成词语；</li>
<li>之后经过语法分析器根据词语构建成节点；最后通过这些节点组建一个DOM树；</li>
<li>这个过程中，如果遇到的DOM节点是JavaScript代码，就会调用JavaScript引擎对JavaScript代码进行解释执行，此时由JavaScript引擎和GUI渲染线程的互斥，GUI渲染线程就会被挂起，渲染过程停止；如果JavaScript代码的运行中对DOM树进行了修改，那么DOM的构建需要从新开始；</li>
<li>如果节点需要依赖其他资源，如（图片，CSS等），便会调用网络模块的资源加载器来加载它们，但它们是异步的，不会阻塞当前DOM树的构建；</li>
<li>如果遇到的是JavaScript资源URL（没有标记异步），则需要停止当前DOM的构建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续构建DOM；</li>
<li>对于CSS，CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树；</li>
<li>然后合并CSS规则树和DOM树，生成render渲染树；</li>
<li>最后对render树进行布局和绘制，并将结果通过IO线程传递给Browser控制进程进行显示。</li>
</ol>
</li>
</ol>
</li>
</ul>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
一个页面从输入URL到加载显示完成，发生了什么？

## 原文链接
[https://segmentfault.com/a/1190000014872028](https://segmentfault.com/a/1190000014872028)

