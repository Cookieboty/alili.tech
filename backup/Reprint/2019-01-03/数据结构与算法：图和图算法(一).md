---
title: '数据结构与算法：图和图算法(一)' 
date: 2019-01-03 2:30:11
hidden: true
slug: qvti0i4zbgr
categories: [reprint]
---

{{< raw >}}

                    
<p>科学上网 ：<br>输入我的邀请码 <code>YHMU3B9</code> 来获得三个月的蓝灯专业版！立即下载 <a href="https://github.com/getlantern/forum" rel="nofollow noreferrer" target="_blank">https://github.com/getlantern...</a></p>
<h2 id="articleHeader0">摘  要  ： 图 论 问 题(Graph Theory)</h2>
<p><span class="img-wrap"><img data-src="/img/bVTNFS?w=1300&amp;h=818" src="https://static.alili.tech/img/bVTNFS?w=1300&amp;h=818" alt="图片描述" title="图片描述" style="cursor: pointer; display: inline;"></span></p>
<ul>
<li>
<code>节点(Vertex)</code> 与 <code>边（Edge）</code>
</li>
<li>
<p>图的表示： <code>邻接表</code> 和 <code>邻接矩阵 </code></p>
<ul>
<li>这里可以分为 <code>有向图</code> 和<code>无向图</code><br><code>无向图是一种特殊的有向图</code>
</li>
<li>
<code>有权图</code> 和 <code>无权图</code>
</li>
</ul>
</li>
<li>图的遍历： <code>DFS</code> <code>BFS</code>     常见可以解决的问题有： <code>联通分量</code>  <code>Flood Fill</code> <code>寻路</code> <code>走迷宫</code> <code>迷宫生成</code>  <code>无权图的最短路径</code> <code>环的判断</code>
</li>
<li>最小生成树问题（Minimum Spanning Tree）    <code>Prim</code> <code>Kruskal</code>
</li>
<li>最短路径问题(Shortest Path)   <code>Dijkstra</code> <code>Bellman-Ford</code>
</li>
<li>拓扑排序(Topological sorting)</li>
</ul>
<p>这里可演示　－&gt;  <a href="https://mrpandey.github.io/d3graphTheory/unit.html" rel="nofollow noreferrer" target="_blank">https://mrpandey.github.io/d3...</a></p>
<h1 id="articleHeader1">图</h1>
<blockquote>什么是图？</blockquote>
<p>图是一种复杂的非线性结构。</p>
<p>在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继；</p>
<p>在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(parent node)及下一层的多个元素(孩子节点)相关；</p>
<p>而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。</p>
<p><strong>图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)</strong></p>
<h2 id="articleHeader2">无向图 和 有向图</h2>
<p>相关基础戳<a href="http://www.cnblogs.com/mcgrady/archive/2013/09/23/3335847.html" rel="nofollow noreferrer" target="_blank">这里</a></p>
<h2 id="articleHeader3">有权图 和 无权图</h2>
<p><span class="img-wrap"><img data-src="/img/bVTNKF?w=1406&amp;h=616" src="https://static.alili.tech/img/bVTNKF?w=1406&amp;h=616" alt="图片描述" title="图片描述" style="cursor: pointer; display: inline;"></span></p>
<p><span class="img-wrap"><img data-src="/img/bVTNKN?w=1276&amp;h=643" src="https://static.alili.tech/img/bVTNKN?w=1276&amp;h=643" alt="图片描述" title="图片描述" style="cursor: pointer; display: inline;"></span></p>
<h2 id="articleHeader4">顶点的度</h2>
<p>对于<strong>无向图</strong>，顶点的度表示以该顶点作为一个端点的边的数目。比如，图(a)无向图中顶点V3的度D(V3)=3</p>
<p>对于<strong>有向图</strong>，顶点的度分为入度和出度。入度表示以该顶点为终点的入边数目，出度是以该顶点为起点的出边数目，该顶点的度等于其入度和出度之和。比如，顶点V1的入度ID(V1)=1，出度OD(V1)=2，所以D(V1)=ID(V1)+OD(V1)=1+2=3</p>
<p>记住，不管是无向图还是有向图，顶点数n，边数e和顶点的度数有如下关系：</p>
<p><span class="img-wrap"><img data-src="/img/bVTrBT?w=88&amp;h=62" src="https://static.alili.tech/img/bVTrBT?w=88&amp;h=62" alt="图片描述" title="图片描述" style="cursor: pointer; display: inline;"></span></p>
<p>因此，就拿有向图(b)来举例，由公式可以得到图G的边数<code>e=(D(V1)+D(V2)+D(V3))/2=(3+2+3)/2=4</code></p>
<p><span class="img-wrap"><img data-src="/img/bVTrCv?w=202&amp;h=180" src="https://static.alili.tech/img/bVTrCv?w=202&amp;h=180" alt="图片描述" title="图片描述" style="cursor: pointer; display: inline;"></span></p>
<h2 id="articleHeader5">路径、路径长度和回路</h2>
<p>路径，比如在无向图G中，存在一个顶点序列Vp,Vi1,Vi2,Vi3…，Vim，Vq，使得(Vp,Vi1)，(Vi1,Vi2)，…,(Vim,Vq)均属于边集E(G)，则称顶点Vp到Vq存在一条路径。</p>
<p>一系列顶点构成路径，路径中所有顶点都由边连接。</p>
<p>路径长度，是指一条路径上经过的边的数量。</p>
<p>回路，指一条路径的起点和终点为同一个顶点。</p>
<h1 id="articleHeader6">用图对现实中的系统建模</h1>
<blockquote>可以用图对现实中许多系统建模。</blockquote>
<p>比如对交通流量建模，顶点可以表示街道的十字路口，边表示街道。加权的边可以表示限速或者车道的数量。建模人员可以用这个系统来判断最佳路线及最有可能堵车的街道。</p>
<p><strong>任何运输系统都可以用图来建模。</strong>比如，航空公司可以用图来为其飞行系统建模。将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。加权的边可以看作从一个机场到另一个机场的航班成本，或两个机场之间的距离，这取决与建模的对象是什么。</p>
<p>包含局域网和广域网（如互联网）在内的计算机网络，同样经常用图来建模。</p>
<p>另一个可以用图来建模的实现系统是消费市场，顶点可以用来表示供应商和消费者。</p>
<h1 id="articleHeader7">图的创建和遍历</h1>
<h2 id="articleHeader8">图的两种存储结构（表示图）</h2>
<blockquote>乍看起来，图和树或者二叉树很像，我们可能会尝试用树的方式来创建一个图类，用节点来表示每个顶点。但这种情况下，如果用基于对象的方式去处理就会有问题，因为图可能增长到非常大。 用对象来表示图很快会变得效率低下，所以我们要考虑表示顶点或边的其他方案。</blockquote>
<h3 id="articleHeader9">表示顶点</h3>
<p>创建图类的第一步是要创建一个Vertex类保存顶点和边。这个类的作用与链表和二叉搜索树的Node类一样。Vertex类有两个数据成员： 一个用于标识顶点，另一个是表示这个顶点是否被访问过的布尔值。分别命名为label 和 wasVisited.这个类只需要一个函数，那就是为顶点的数据成员设定值的构造函数。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//Vertex 类

function Vertex (label wasVisited) {
  this.label = label;
  this.wasVisited = wasVisited;
}

" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-comment">//Vertex 类</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vertex</span> <span class="hljs-params">(label wasVisited)</span> </span>{
  <span class="hljs-keyword">this</span>.label = label;
  <span class="hljs-keyword">this</span>.wasVisited = wasVisited;
}

</code></pre>
<p>我们将所有顶点保存到数组中，在图类里，可以通过它们在数组中位置引用它们。</p>
<h3 id="articleHeader10">表示边</h3>
<p>图的实际信息都保存在边上，因为它们描述了图的结构。我们容易像之前提到的那样用二叉树的方式去表示图，这是不对的。二叉树的表现形式相当固定，一个父节点只能有两个子节点，而图结构却要灵活的多，一个顶点既可以有一条边，也可以有多条边与它相连。</p>
<p>我们将表示图的边的方法称为<code>邻接表</code> 或者邻接表数组。</p>
<p>这种方法将边储存为<code>由顶点的相邻顶点列表构成的数组</code>，并以此顶点作为索引。</p>
<p>当我们在程序中引用一个顶点时，可以高效地访问与这个顶点相连的所有顶点的列表。</p>
<blockquote>
<strong>邻接矩阵</strong><p>原理就是用两个数组，一个数组保存顶点集，一个数组保存边集。下面的算法实现里边我们也是采用这种存储结构。如下图所示：</p>
<p><span class="img-wrap"><img data-src="/img/bVTrFU?w=291&amp;h=86" src="https://static.alili.tech/img/bVTrFU?w=291&amp;h=86" alt="图片描述" title="图片描述" style="cursor: pointer;"></span></p>
<p><strong>邻接表</strong></p>
<p>邻接表是图的一种链式存储结构。这种存储结构类似于树的孩子链表。对于图G中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的邻接表。</p>
</blockquote>
<h2 id="articleHeader11">构建图</h2>
<p>确定了如何在代码中表图之后，构建一个表示图的类就容易了，下面是一个Graph类的定义：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Graph (v) {
  this.vertices = v;
  this.edges = 0;
  this.adj = [];
  for (var i = 0; i < this.vertices; ++i) {
    this.adj[i] = [];
    this.adj[i].push(&quot;&quot;);
  }
  this.addEdge = addEdge;
  this.toString = toString;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code>function Graph (v) {
  <span class="hljs-keyword">this</span>.vertices = v;
  <span class="hljs-keyword">this</span>.edges = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.adj = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vertices; ++i) {
    <span class="hljs-keyword">this</span>.adj[i] = [];
    <span class="hljs-keyword">this</span>.adj[i].push(<span class="hljs-string">""</span>);
  }
  <span class="hljs-keyword">this</span>.addEdge = addEdge;
  <span class="hljs-keyword">this</span>.toString = toString;
}</code></pre>
<p>这个类会记录一个图表示了多少条边，并使用一个长度与图的顶点数相同的数组来记录顶点数量。<br>通过for循环为数组中的每个元素添加一个子数组来储存所有的相邻顶点，并将所有元素初始化为空字符串。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//addEdge()  函数定义如下
 function addEdge(v,w) {
  this.adj[v].push(w);
  this.adj[w].push(v);
  this.edges++;
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-comment">//addEdge()  函数定义如下</span>
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(v,w)</span> </span>{
  <span class="hljs-keyword">this</span>.adj[v].push(w);
  <span class="hljs-keyword">this</span>.adj[w].push(v);
  <span class="hljs-keyword">this</span>.edges++;
}
</code></pre>
<p>当调用这个函数并传入顶点A 和 B 时，函数会先查找顶点A ，函数会先查找A的邻接表，将顶点B添加到列表中，然后再查找顶点B的邻接表，将顶点A加入列表。最后，这个函数会将边数加 1.</p>
<p><code>showGraph()</code> 函数会通过打印所有顶点及其相邻顶点列表的方式来显示图：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=" function showGraph() {
  for (var i = 0 ; i < this.vertices; ++i ) {
  putstr(i + &quot;->&quot;);
      for (var j  = 0; j < this.vertices; ++j) {
        if(this.adj[i][j] != undefined)
          putstr(this.adj[i][j] + ' ')
      }
      
      print();
  
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-keyword">this</span>.vertices; ++i ) {
  putstr(i + <span class="hljs-string">"-&gt;"</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j  = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">this</span>.vertices; ++j) {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.adj[i][j] != <span class="hljs-literal">undefined</span>)
          putstr(<span class="hljs-keyword">this</span>.adj[i][j] + <span class="hljs-string">' '</span>)
      }
      
      print();
  
  }
}</code></pre>
<p>一个完整的 <code>Graph</code> 类</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Graph(v) {
  this.vertices = v ;
  this.edges = 0;
  this.adj = [];
  for(var i = 0 ; i < this.vertices; ++i ){
    this.adj[i] = [];
    this.adj[i].push(&quot;&quot;);
    }
  this.addEdge = addEadge;
  this.showGraph = showGraph;
}

function addEdge(v,w)  {
  this.adj[v].push(w);
  this.adj[w].push(v);
  this.edges++;
}

function showGraph () {
  for (var i = 0; i < this.vertices; ++i) {
  putstr(i + &quot; -> &quot;);
  for (var j = 0; j < this.vertices; ++j) {
    if(this.adj[i][j] != undefined) {
      putstr(this.adj[i][j] + ' ');
    }
  }
  print()
  }
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code>function Graph(v) {
  <span class="hljs-keyword">this</span>.vertices = v ;
  <span class="hljs-keyword">this</span>.edges = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.adj = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-keyword">this</span>.vertices; ++i ){
    <span class="hljs-keyword">this</span>.adj[i] = [];
    <span class="hljs-keyword">this</span>.adj[i].push(<span class="hljs-string">""</span>);
    }
  <span class="hljs-keyword">this</span>.addEdge = addEadge;
  <span class="hljs-keyword">this</span>.showGraph = showGraph;
}

function addEdge(v,w)  {
  <span class="hljs-keyword">this</span>.adj[v].push(w);
  <span class="hljs-keyword">this</span>.adj[w].push(v);
  <span class="hljs-keyword">this</span>.edges++;
}

function showGraph () {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vertices; ++i) {
  putstr(i + <span class="hljs-string">" -&gt; "</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">this</span>.vertices; ++j) {
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.adj[i][j] != undefined) {
      putstr(<span class="hljs-keyword">this</span>.adj[i][j] + <span class="hljs-string">' '</span>);
    }
  }
  print()
  }
}
</code></pre>
<h2 id="articleHeader12">图的两种遍历方法</h2>
<p>确定从一个指定的顶点可以到达其他哪些顶点。这是经常对图执行的操作。我们可能想通过地图了解到从一个城镇到另一个城镇有哪些路，或者从一个机场到其他机场有哪些航班。</p>
<p>而图上这些操作是用算法执行的。在图上可以执行以下两种遍历算法用于搜索：</p>
<h3 id="articleHeader13">深度优先搜索遍历</h3>
<p><span class="img-wrap"><img data-src="/img/bVTChX?w=600&amp;h=290" src="https://static.alili.tech/img/bVTChX?w=600&amp;h=290" alt="图片描述" title="图片描述" style="cursor: pointer;"></span></p>
<blockquote>深度优先搜索DFS遍历类似于树的前序遍历。其基本思路是：<p>a) 假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点v为初始出发点，首先访问出发点v，并将其标记为已访问过。</p>
<p>b)然后依次从v出发搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点出发，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到。</p>
<p>c) 若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。</p>
</blockquote>
<p><strong>简单的来说，深度优先搜索包括从一条路径的起始点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止</strong></p>
<p><code>这不是在搜索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。</code></p>
<p>图示如下：</p>
<p><span class="img-wrap"><img data-src="/img/bVTuM1?w=312&amp;h=275" src="https://static.alili.tech/img/bVTuM1?w=312&amp;h=275" alt="图片描述" title="图片描述" style="cursor: pointer;"></span></p>
<p>注：红色数字代表遍历的先后顺序，所以图(e)无向图的深度优先遍历的顶点访问序列为：V0，V1，V2，V5，V4，V6，V3，V7，V8</p>
<p>如果采用邻接矩阵存储，则时间复杂度为O(n2)；当采用邻接表时时间复杂度为O(n+e)。</p>
<p><strong>深度优先搜索的<code>算法</code>比较简单： 访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在起始点的邻接表中其他没有访问过的顶点。</strong></p>
<p><span class="img-wrap"><img data-src="/img/bVTvbn?w=600&amp;h=450" src="https://static.alili.tech/img/bVTvbn?w=600&amp;h=450" alt="图片描述" title="图片描述" style="cursor: pointer;"></span></p>
<p>要让该算法运行，需要为Graph类添加一个数组，用来储存已访问过的顶点，将它所有元素的值全部初始化为false。<code>Graph类</code>的代码片段演示了这个新数组及其初始化过程：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="this.marked = [];
for(var i = 0; i < this.vertices; ++i) {
  this.marked[i] = false;
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code><span class="hljs-keyword">this</span>.marked = [];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vertices; ++i) {
  <span class="hljs-keyword">this</span>.marked[i] = <span class="hljs-literal">false</span>;
}
</code></pre>
<p>现在我们可以开始编写深度优先搜索函数：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function dfs(v) {
  this.marked[v] = true;
  //用于输出的if语句在这里不是必须的
  if(this.adj[v] != undefined)
    print(&quot;Visited vertex: &quot; + v)
  for each(var w in this.adj[v]) {
   if(!this.marked[w]) {
     this.dfs(w);
   }
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span><span class="hljs-params">(v)</span> </span>{
  <span class="hljs-keyword">this</span>.marked[v] = <span class="hljs-literal">true</span>;
  <span class="hljs-comment">//用于输出的if语句在这里不是必须的</span>
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.adj[v] != <span class="hljs-literal">undefined</span>)
    print(<span class="hljs-string">"Visited vertex: "</span> + v)
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span>(<span class="hljs-keyword">var</span> w <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.adj[v]) {
   <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.marked[w]) {
     <span class="hljs-keyword">this</span>.dfs(w);
   }
  }
}</code></pre>
<p>代码中用到了print()函数，这样我们可以查看当前正在访问的顶点。当然，dfs()不想要print()也能运行。</p>
<blockquote>
<strong>注意</strong> 深度优先算法属于盲目搜索，无法保证搜索到的路径为最短路径。</blockquote>
<h4>执行深度优先搜索</h4>
<p>下面是depthFirst() 函数 及完整的Graph类定义</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=" function Graph(v) {
  this.vertices = v;
  this.edges = 0;
  this.adj = [];
  for(var i=0;i<this.vertices;i++) {
    this.adj[i] = [];
    this.adj[i].push(&quot;&quot;);
  }
  this.addEdge = addEdge;
  this.showGragh = showGragh;
  this.dfs = dfs;
  this.marked = [];
  for(var i=0;i<this.vertices;i++){
  this.marked[i] = false; 
  }
}

function addEdge(v,w) {
  this.adj[v].push(w);
  this.adj[w].push(v);
  this.edges++;
}

function showGragh() {
  for(var i = 0;i < this.vertices; ++i) {
  putstr(i + &quot;->&quot;);
    for(var j=0;j<this.vertices;++i) {
      if(this.adj[i][j] != undefined)
        putstr(this.add[i][j] + ' ');
    }
    print();
  }
}

function dfs(v) {
  this.marked[v] = true;
  if(this.adj[v]!==undefined){
  print(&quot;Visited vertex: &quot; + v);
  }
  for each(var w in this.adj[v]) {
    if(!this.marked[w]) {
      this.dfs(w)
    }
  }
}

" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code> function Graph(v) {
  <span class="hljs-keyword">this</span>.vertices = v;
  <span class="hljs-keyword">this</span>.edges = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.adj = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">this</span>.vertices;i++) {
    <span class="hljs-keyword">this</span>.adj[i] = [];
    <span class="hljs-keyword">this</span>.adj[i].push(<span class="hljs-string">""</span>);
  }
  <span class="hljs-keyword">this</span>.addEdge = addEdge;
  <span class="hljs-keyword">this</span>.showGragh = showGragh;
  <span class="hljs-keyword">this</span>.dfs = dfs;
  <span class="hljs-keyword">this</span>.marked = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">this</span>.vertices;i++){
  <span class="hljs-keyword">this</span>.marked[i] = <span class="hljs-literal">false</span>; 
  }
}

function addEdge(v,w) {
  <span class="hljs-keyword">this</span>.adj[v].push(w);
  <span class="hljs-keyword">this</span>.adj[w].push(v);
  <span class="hljs-keyword">this</span>.edges++;
}

function showGragh() {
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-keyword">this</span>.vertices; ++i) {
  putstr(i + <span class="hljs-string">"-&gt;"</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-keyword">this</span>.vertices;++i) {
      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.adj[i][j] != undefined)
        putstr(<span class="hljs-keyword">this</span>.add[i][j] + <span class="hljs-string">' '</span>);
    }
    print();
  }
}

function dfs(v) {
  <span class="hljs-keyword">this</span>.marked[v] = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.adj[v]!==undefined){
  print(<span class="hljs-string">"Visited vertex: "</span> + v);
  }
  <span class="hljs-keyword">for</span> each(<span class="hljs-keyword">var</span> w <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.adj[v]) {
    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.marked[w]) {
      <span class="hljs-keyword">this</span>.dfs(w)
    }
  }
}

</code></pre>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 测试dfs() 函数
load(&quot;Graph.js&quot;);
g = new Gragh(5);
g.addEdge(0,1);
g.addEdge(0,2);
g.addEdge(1,3);
g.addEdge(2,4);
g.showGragh();
g.dfs(0);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lsl"><code><span class="hljs-comment">// 测试dfs() 函数</span>
load(<span class="hljs-string">"Graph.js"</span>);
g = new Gragh(<span class="hljs-number">5</span>);
g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);
g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);
g.addEdge(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);
g.addEdge(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);
g.showGragh();
g.dfs(<span class="hljs-number">0</span>);</code></pre>
<p>以上程序的输出结果：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="0 -> 1 2
1 -> 0 3
2 -> 0 4
3 -> 1
4 -> 2

Visited vertex: 0 
Visited vertex: 1
Visited vertex: 2 
Visited vertex: 3 
Visited vertex: 4" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs tap"><code>0 -&gt;<span class="hljs-number"> 1 </span>2
1 -&gt;<span class="hljs-number"> 0 </span>3
2 -&gt;<span class="hljs-number"> 0 </span>4
3 -&gt; 1
4 -&gt; 2

Visited vertex:<span class="hljs-number"> 0 </span>
Visited vertex: 1
Visited vertex:<span class="hljs-number"> 2 </span>
Visited vertex:<span class="hljs-number"> 3 </span>
Visited vertex: 4</code></pre>
<h4>完整示例</h4>
<p>戳<a href="https://zhuanlan.zhihu.com/p/28486528" rel="nofollow noreferrer" target="_blank">这里</a></p>
<h3 id="articleHeader14">广度优先搜索遍历</h3>
<p><span class="img-wrap"><img data-src="/img/bVTCh7?w=600&amp;h=292" src="https://static.alili.tech/img/bVTCh7?w=600&amp;h=292" alt="图片描述" title="图片描述" style="cursor: pointer;"></span></p>
<p>广度优先搜索遍历BFS类似于树的按层次遍历。其基本思路是：</p>
<p>a) 首先访问出发点Vi</p>
<p>b) 接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，Vi3，…，Vit并均标记为已访问过。</p>
<p>c) 然后再按照Vi1，Vi2，… ，Vit的次序，访问每一个顶点的所有未曾访问过的顶点并均标记为已访问过，依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。<br>图示如下：</p>
<p><span class="img-wrap"><img data-src="/img/bVTwBW?w=455&amp;h=356" src="https://static.alili.tech/img/bVTwBW?w=455&amp;h=356" alt="图片描述" title="图片描述" style="cursor: pointer;"></span></p>
<p>因此，图(f)采用广义优先搜索遍历以V0为出发点的顶点序列为：V0，V1，V3，V4，V2，V6，V8，V5，V7</p>
<p>如果采用邻接矩阵存储，则时间复杂度为O(n2)，若采用邻接表，则时间复杂度为O(n+e)。</p>
<p><strong>简单的来说，广度优先搜索从一个顶点开始，尝试访问尽可能靠近它的顶点。本质上这种搜索在图上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层</strong></p>
<blockquote>广度优先搜索算法使用了抽象的队列而不是数组来对已经访问过的顶点进行排序。算法工作原理如下：</blockquote>
<ol>
<li>查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中;</li>
<li>从图中取下一个顶点v，添加到已访问的顶点列表</li>
<li>将所有与v相邻的未访问顶点添加到队列。</li>
</ol>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function bfs(s) {
  var queue = [];
  this.marked[s] = true;
  queue.push(s); // 添加到队尾
  while (queue.length > 0) {
    var v =queue.shift(); //从队首移除
    if(this.adj[v]!= undefined) {
      print(&quot;Visisted  vertex: &quot; + v);
    } 
    for each(var w in this.adj[v]) {
      if(!this.marked[w]) {
        this.marked[w] = true;
        queue.push(w);
      }
    }
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span><span class="hljs-params">(s)</span> </span>{
  <span class="hljs-keyword">var</span> queue = [];
  <span class="hljs-keyword">this</span>.marked[s] = <span class="hljs-literal">true</span>;
  queue.push(s); <span class="hljs-comment">// 添加到队尾</span>
  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">var</span> v =queue.shift(); <span class="hljs-comment">//从队首移除</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.adj[v]!= <span class="hljs-literal">undefined</span>) {
      print(<span class="hljs-string">"Visisted  vertex: "</span> + v);
    } 
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span>(<span class="hljs-keyword">var</span> w <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.adj[v]) {
      <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.marked[w]) {
        <span class="hljs-keyword">this</span>.marked[w] = <span class="hljs-literal">true</span>;
        queue.push(w);
      }
    }
  }
}</code></pre>
<p>执行广度优先搜索</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="load(&quot;Graph.js&quot;);
g = new Graph(5);
g.addEdge(0,1);
g.addEdge(0,2);
g.addEdge(1,3);
g.addEdge(2,4);
g.showGragh();
g.bfs(0);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lsl"><code>load(<span class="hljs-string">"Graph.js"</span>);
g = new Graph(<span class="hljs-number">5</span>);
g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);
g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);
g.addEdge(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);
g.addEdge(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);
g.showGragh();
g.bfs(<span class="hljs-number">0</span>);</code></pre>
<p>以上程序的输出结果：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="0 -> 1 2
1 -> 0 3
2 -> 0 4
3 -> 1
4 -> 2
Visited vertex: 0
Visited vertex: 1
Visited vertex: 2
Visited vertex: 3
Visited vertex: 4" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs clean"><code><span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> <span class="hljs-number">2</span>
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> <span class="hljs-number">3</span>
<span class="hljs-number">2</span> -&gt; <span class="hljs-number">0</span> <span class="hljs-number">4</span>
<span class="hljs-number">3</span> -&gt; <span class="hljs-number">1</span>
<span class="hljs-number">4</span> -&gt; <span class="hljs-number">2</span>
Visited vertex: <span class="hljs-number">0</span>
Visited vertex: <span class="hljs-number">1</span>
Visited vertex: <span class="hljs-number">2</span>
Visited vertex: <span class="hljs-number">3</span>
Visited vertex: <span class="hljs-number">4</span></code></pre>
<p>关于广度优先遍历的应用<br>-&gt; d3中的<code>each()</code>api   <a href="http://devdocs.io/d3~4/d3-hierarchy#node_each" rel="nofollow noreferrer" target="_blank">node.each(function)</a></p>
<h2 id="articleHeader15">查找最短路径</h2>
<blockquote>图最常见的操作之一就是寻找从一个顶点到另一个顶点的最短路径.<br>考虑下面的例子：</blockquote>
<p>假期中，你将在两个星期的时间里游历10个旅游城市，去那里最富盛名的景点（1 个），你希望通过最短路径算法，找出开车游历10个城市行驶的最小历程数。<br>另一个最短路径问题涉及创建一个计算机网络时的开销，其中包括两台电脑之间传递数据的时间，或者两台电脑建立和维护连接的成本。 <br>最短路径算法可以帮助确定构建此网络的最有效方法。</p>
<h3 id="articleHeader16">广度优先搜索对应的最短路径</h3>
<p>在执行广度优先搜索时，会自动查找从一个顶点到另一个相邻顶点的最短路径。<br>例如：要查找从顶点A到顶点D的最短路径，我们首先会查找从A到D是否有任何一条单边路径，接着查找两条边的路径，以此类推。<code>这正是广度优先搜索的搜索过程，因此我们可以轻松地修改广度优先搜索算法，找出最短路径。</code></p>
<h3 id="articleHeader17">确定路径</h3>
<p>要查找最短路径，需要修改广度优先搜索算法来记录从一个顶点到另一个顶点的路径，这需要对Gragh类做一些修改。</p>
<p>首先，需要一个数组来保存从一个顶点到下一个顶点的所有边。我们将这个数组命名为edgeTo。 因为从始至终使用的都是广度优先搜索函数，所以每次都会遇到一个没有标记的顶点，除了对它进行标记外，还会从邻接列表中我们正在搜索的那个顶点添加一条边到这个顶点。<br>下面是新的<code>bfs()</code>函数 和需要添加到Gragh类的代码：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//将这行添加到Gragh类
this.edgeTo = [];

// bfs函数

function bfs(s) {
  var queque = [];
  this.marked[s] = true;
  queue.push(s); //添加到队尾
  while (queue.length > 0 ) {
   var v = queque.shift(); //从队首移除
   if(v == undefined) {
     print(&quot;Visited vertex: &quot; + v);
   }
   for each(var w in this.adj[v]) {
     if(!this.marked[w]) {
       this.edgeTo[w] = v;
       this.marked[w] = true;
       queue.push(w);
     }
   }
  }
}

" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code><span class="hljs-comment">//将这行添加到Gragh类</span>
<span class="hljs-keyword">this</span>.edgeTo = [];

<span class="hljs-comment">// bfs函数</span>

function bfs(s) {
  <span class="hljs-keyword">var</span> queque = [];
  <span class="hljs-keyword">this</span>.marked[s] = <span class="hljs-literal">true</span>;
  queue.push(s); <span class="hljs-comment">//添加到队尾</span>
  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span> ) {
   <span class="hljs-keyword">var</span> v = queque.shift(); <span class="hljs-comment">//从队首移除</span>
   <span class="hljs-keyword">if</span>(v == undefined) {
     print(<span class="hljs-string">"Visited vertex: "</span> + v);
   }
   <span class="hljs-keyword">for</span> each(<span class="hljs-keyword">var</span> w <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.adj[v]) {
     <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.marked[w]) {
       <span class="hljs-keyword">this</span>.edgeTo[w] = v;
       <span class="hljs-keyword">this</span>.marked[w] = <span class="hljs-literal">true</span>;
       queue.push(w);
     }
   }
  }
}

</code></pre>
<p>现在我们需要一个函数，用于展示图中连接到不同顶点的路径。函数pathTo() 创建了一个栈，用来储存与指定顶点有共同边的所有顶点。<br>以下是pathTo()函数的代码，以及一个简单的辅助函数：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function pathTo(v) {
  var source = 0;
  if(!this.hasPathTo(v) {
    return undefined;
  }
  var path = [];
  for (var i = v; i!= source;i = this.edgeTo[i]) {
    path.push(i);
  }
  path.push(source);
  return path;
}

function hasPathTo(v) {
  return this.marked[v];
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pathTo</span><span class="hljs-params">(v)</span> </span>{
  <span class="hljs-keyword">var</span> source = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.hasPathTo(v) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }
  <span class="hljs-keyword">var</span> path = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = v; i!= source;i = <span class="hljs-keyword">this</span>.edgeTo[i]) {
    path.push(i);
  }
  path.push(source);
  <span class="hljs-keyword">return</span> path;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasPathTo</span><span class="hljs-params">(v)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.marked[v];
}</code></pre>
<p>需要确保将以下声明添加到 Graph()构造函数中：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="this.pathTo = pathTo;
this.hasPathTo = hasPathTo;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code><span class="hljs-keyword">this</span>.pathTo = pathTo;
<span class="hljs-keyword">this</span>.hasPathTo = hasPathTo;</code></pre>
<p>有了这个函数，我们要做的就是编写一些客户端代码来显示从源顶点到某个特定顶点的最短路径。</p>
<p><strong>查找一个顶点的最短路径</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="load(&quot;Gragh.js&quot;);
g = new Gragh(5);
g.bfs(0);
g.addEdge(0,1);
g.addEdge(0,2);
g.addEdge(1,3);
g.addEdge(2,4);
var vartex = 4;
var paths = g.pathTo(vertex);
while (paths.length > 0) {
  id(paths.length > 1) {
    putstr(paths.pop() + '-');
  }
  else {
    putstr(paths.pop());
  }
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lsl"><code>load(<span class="hljs-string">"Gragh.js"</span>);
g = new Gragh(<span class="hljs-number">5</span>);
g.bfs(<span class="hljs-number">0</span>);
g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);
g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);
g.addEdge(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);
g.addEdge(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);
var vartex = <span class="hljs-number">4</span>;
var paths = g.pathTo(vertex);
while (paths.length &gt; <span class="hljs-number">0</span>) {
  id(paths.length &gt; <span class="hljs-number">1</span>) {
    putstr(paths.pop() + '-');
  }
  else {
    putstr(paths.pop());
  }
}
</code></pre>
<p>以上程序输出结果为：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="0-2-4
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lsl"><code><span class="hljs-number">0</span><span class="hljs-number">-2</span><span class="hljs-number">-4</span>
</code></pre>
<p>也就是从顶点 0 到顶点4 的最短路径</p>
<h2 id="articleHeader18">拓扑排序</h2>
<p>在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。<br>该序列必须满足下面两个条件：</p>
<ul>
<li>每个顶点出现且只出现一次</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li>
</ul>
<p><code>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</code></p>
<p><span class="img-wrap"><img data-src="/img/bVTB6h?w=335&amp;h=270" src="https://static.alili.tech/img/bVTB6h?w=335&amp;h=270" alt="图片描述" title="图片描述" style="cursor: pointer;"></span></p>
<p>它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：</p>
<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li>
</ol>
<p><span class="img-wrap"><img data-src="/img/bVTCas?w=544&amp;h=350" src="https://static.alili.tech/img/bVTCas?w=544&amp;h=350" alt="图片描述" title="图片描述" style="cursor: pointer;"></span></p>
<p>于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。</p>
<p><strong>通常，一个有向无环图可以有一个或多个拓扑排序序列。</strong></p>
<h3 id="articleHeader19">拓扑排序的应用</h3>
<blockquote>拓扑排序通常用来“排序”具有依赖关系的任务。它与深度优先搜索BFS类似。不同的是，拓扑排序算法不会立即输出已访问的顶点，而是访问当前顶点邻接表中的所有相邻顶点，直到这个列表穷尽时，才将当前顶点压入栈中。<br> 举一个例子如下图：</blockquote>
<p><span class="img-wrap"><img data-src="/img/bVTCum?w=289&amp;h=178" src="https://static.alili.tech/img/bVTCum?w=289&amp;h=178" alt="图片描述" title="图片描述" style="cursor: pointer;"></span><br>其拓扑排序可以是：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="     1,2,3,4,5,7,9,10,11,6,12,8" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lsl"><code style="word-break: break-word; white-space: initial;">     <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span></code></pre>
<p>也可以是：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="     9,10,11,6,1,12,4,2,3,5,7,8
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lsl"><code>     <span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>
</code></pre>
<p>再比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边&lt;A,B&gt;表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p>
<p><a href="https://github.com/datavis-tech/graph-data-structure#abc" rel="nofollow noreferrer" target="_blank">graph-data-structure</a></p>
<h1 id="articleHeader20">其他经典问题</h1>
<ul>
<li>有向图周期检测：</li>
<li>强连通组件图</li>
</ul>
<blockquote>以上不少内容来自《数据结构与算法 javascript》这本书<br>,感觉讲的很糟糕 ,也有可能是译者的问题。 回头翻一翻其他资料 重新整理下  并且补上相关算法的应用代码</blockquote>
<h1 id="articleHeader21">参考</h1>
<p><a href="https://en.wikipedia.org/wiki/Depth-first_search" rel="nofollow noreferrer" target="_blank">Depth-first search</a><br>[数据结构与算法 javascript描述]<br>[慕课网 算法与数据结构]<br><a href="http://www.cnblogs.com/mcgrady/archive/2013/09/23/3335847.html" rel="nofollow noreferrer" target="_blank">数据结构和算法系列17 </a><br><a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type" rel="nofollow noreferrer" target="_blank">Graph (abstract data type)</a>)<br><a href="https://en.wikipedia.org/wiki/Topological_sorting" rel="nofollow noreferrer" target="_blank">Topological sorting</a><br><a href="http://www.geeksforgeeks.org/topological-sorting/" rel="nofollow noreferrer" target="_blank">Topological Sorting</a><br><a href="http://blog.csdn.net/lisonglisonglisong/article/details/45543451" rel="nofollow noreferrer" target="_blank">拓扑排序（Topological Sorting）</a><br><a href="https://zhuanlan.zhihu.com/p/25498681" rel="nofollow noreferrer" target="_blank">数据结构与算法 - 图论</a><br><a href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="nofollow noreferrer" target="_blank">Breadth-first search 广度优先搜索</a></p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
数据结构与算法：图和图算法(一)

## 原文链接
[https://segmentfault.com/a/1190000010794621](https://segmentfault.com/a/1190000010794621)

