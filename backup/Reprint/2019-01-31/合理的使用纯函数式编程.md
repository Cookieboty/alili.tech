---
title: '合理的使用纯函数式编程' 
date: 2019-01-31 2:31:16
hidden: true
slug: bn2ca9gvn49
categories: [reprint]
---

{{< raw >}}

                    
<blockquote><p>本文是篇译文，原文链接<a href="https://www.sitepoint.com/an-introduction-to-reasonably-pure-functional-programming/" rel="nofollow noreferrer" target="_blank">An Introduction to Reasonably Pure Functional Programming</a>,不当之处还请指正。</p></blockquote>
<p>一个好的程序员应该有能力掌控你写的代码，能够以最简单的方法使你的代码正确并且可读。作为一名优秀的程序员，你会编写尽量短小的函数，使代码更好的被复用；你会编写测试代码，使自己有足够的信心相信代码会按原本的意图正确运行。没有人喜欢解bug，所以一名优秀的程序员也要会避免一些错误，这些要靠经验获得，也可以遵循一些最佳实践，比如Douglas Crockford 最著名的<a href="https://vimeo.com/8691412" rel="nofollow noreferrer" target="_blank">JavaScript:The good parts</a></p>
<p>函数式编程能够降低程序的复杂程度：函数看起来就像是一个数学公式。学习函数编程能够帮助你编写简单并且更少bug的代码。</p>
<h1 id="articleHeader0">纯函数</h1>
<blockquote><p>纯函数可以理解为一种 相同的输入必定有相同的输出的函数，没有任何可以观察到副作用</p></blockquote>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//pure
function add(a + b) {
  return a + b;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">//pure</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a + b</span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
}</code></pre>
<p>上面是一个纯函数，它不依赖也不改变任何函数以外的变量状态，对于相同的输入总能返回相同的输出。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//impure
var minimum = 21;
var checkAge = function(age) {
  return age >= minimum; // 如果minimum改变，函数结果也会改变
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">//impure</span>
<span class="hljs-keyword">var</span> minimum = <span class="hljs-number">21</span>;
<span class="hljs-keyword">var</span> checkAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">return</span> age &gt;= minimum; <span class="hljs-comment">// 如果minimum改变，函数结果也会改变</span>
}</code></pre>
<p>这个函数不是纯函数，因为它依赖外部可变的状态</p>
<p>如果我们将变量移到函数内部，那么它就变成了纯函数，这样我们就能够保证函数每次都能正确的比较年龄。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var checkAge = function(age) {
  var minimum = 21;
  return age >= minimum;
};" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> checkAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">var</span> minimum = <span class="hljs-number">21</span>;
  <span class="hljs-keyword">return</span> age &gt;= minimum;
};</code></pre>
<p>纯函数没有副作用，一些你要记住的是，它不会：</p>
<ul>
<li><p>访问函数以外的系统状态</p></li>
<li><p>修改以参数形式传递过来的对象</p></li>
<li><p>发起http请求</p></li>
<li><p>保留用户输入</p></li>
<li><p>查询DOM</p></li>
</ul>
<h2 id="articleHeader1">控制增变（controlled mutation）</h2>
<p>你需要留意一些会改变数组和对象的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Mutator_methods" rel="nofollow noreferrer" target="_blank">增变方法</a>，举例来说你要知道splice和slice之间的差异。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//impure, splice 改变了原数组
var firstThree = function(arr) {
  return arr.splice(0,3);
}

//pure, slice 返回了一个新数组
var firstThree = function(arr) {
  return arr.slice(0,3);
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">//impure, splice 改变了原数组</span>
<span class="hljs-keyword">var</span> firstThree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">return</span> arr.splice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);
}

<span class="hljs-comment">//pure, slice 返回了一个新数组</span>
<span class="hljs-keyword">var</span> firstThree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">return</span> arr.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);
}</code></pre>
<p>如果我们避免使用传入函数的对象的增变方法，我们的程序将更容易理解，我们也有理由期望我们的函数不会改变任何函数之外的东西。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let items = ['a', 'b', 'c'];
let newItems = pure(items);
//对于纯函数items始终应该是['a', 'b', 'c']" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> items = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<span class="hljs-keyword">let</span> newItems = pure(items);
<span class="hljs-comment">//对于纯函数items始终应该是['a', 'b', 'c']</span></code></pre>
<h1 id="articleHeader2">纯函数的优点</h1>
<p>相比于不纯的函数，纯函数有如下优点：</p>
<ul>
<li><p>更加容易被测试，因为它们唯一的职责就是根据输入计算输出</p></li>
<li><p>结果可以被缓存，因为相同的输入总会获得相同的输出</p></li>
<li><p>自我文档化，因为函数的依赖关系很清晰</p></li>
<li><p>更容易被调用，因为你不用担心函数会有什么副作用</p></li>
</ul>
<p>因为纯函数的结果可以被缓存，我们可以<a href="http://underscorejs.org/docs/underscore.html#section-79" rel="nofollow noreferrer" target="_blank">记住</a>他们,这样以来复杂昂贵的操作只需要在被调用时执行一次。例如，缓存一个大的查询索引的结果可以极大的改善程序的性能。</p>
<h1 id="articleHeader3">不合理的纯函数编程</h1>
<p>使用纯函数能够极大的降低程序的复杂度。但是，如果我们使用过多的函数式编程的抽象概念，我们的函数式编程也会非常难以理解。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="import _ from 'ramda';
import $ from 'jquery';

var Impure = {
  getJSON: _.curry(function(callback, url) {
    $.getJSON(url, callback);
  }),

  setHtml: _.curry(function(sel, html) {
    $(sel).html(html);
  })
};

var img = function (url) {
  return $('<img />', { src: url });
};

var url = function (t) {
  return 'http://api.flickr.com/services/feeds/photos_public.gne?tags=' +
    t + '&amp;format=json&amp;jsoncallback=?';
};

var mediaUrl = _.compose(_.prop('m'), _.prop('media'));
var mediaToImg = _.compose(img, mediaUrl);
var images = _.compose(_.map(mediaToImg), _.prop('items'));
var renderImages = _.compose(Impure.setHtml(&quot;body&quot;), images);
var app = _.compose(Impure.getJSON(renderImages), url);
app(&quot;cats&quot;);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda'</span>;
<span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;

<span class="hljs-keyword">var</span> Impure = {
  <span class="hljs-attr">getJSON</span>: _.curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, url</span>) </span>{
    $.getJSON(url, callback);
  }),

  <span class="hljs-attr">setHtml</span>: _.curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sel, html</span>) </span>{
    $(sel).html(html);
  })
};

<span class="hljs-keyword">var</span> img = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> $(<span class="hljs-string">'&lt;img /&gt;'</span>, { <span class="hljs-attr">src</span>: url });
};

<span class="hljs-keyword">var</span> url = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'http://api.flickr.com/services/feeds/photos_public.gne?tags='</span> +
    t + <span class="hljs-string">'&amp;format=json&amp;jsoncallback=?'</span>;
};

<span class="hljs-keyword">var</span> mediaUrl = _.compose(_.prop(<span class="hljs-string">'m'</span>), _.prop(<span class="hljs-string">'media'</span>));
<span class="hljs-keyword">var</span> mediaToImg = _.compose(img, mediaUrl);
<span class="hljs-keyword">var</span> images = _.compose(_.map(mediaToImg), _.prop(<span class="hljs-string">'items'</span>));
<span class="hljs-keyword">var</span> renderImages = _.compose(Impure.setHtml(<span class="hljs-string">"body"</span>), images);
<span class="hljs-keyword">var</span> app = _.compose(Impure.getJSON(renderImages), url);
app(<span class="hljs-string">"cats"</span>);</code></pre>
<p>花一分钟理解上面的代码。</p>
<p>除非你接触过函数式编程的这些概念（柯里化，组合和prop），否则很难理解上述代码。相比于纯函数式的方法，下面的代码则更加容易理解和修改，它更加清晰的描述程序并且更少的代码。</p>
<ul>
<li><p>app函数的参数是一个标签字符串</p></li>
<li><p>从<a href="https://www.flickr.com/" rel="nofollow noreferrer" target="_blank">Flickr</a>获取JSON数据</p></li>
<li><p>从返回的数据里抽出urls</p></li>
<li><p>创建&lt;img&gt;节点数组</p></li>
<li><p>将他们插入文档</p></li>
</ul>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var app = (tags) => {
  let url = `http://api.flickr.com/services/feeds/photos_public.gne?tags=${tags}&amp;format=json&amp;jsoncallback=?`;
  $.getJSON(url, (data) => {
    let urls = data.items.map((item) => item.media.m)
    let images = urls.map(url) => $('<img />', {src:url}) );
    
    $(document.body).html(images);
  })
}
app(&quot;cats&quot;);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> app = <span class="hljs-function">(<span class="hljs-params">tags</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> url = <span class="hljs-string">`http://api.flickr.com/services/feeds/photos_public.gne?tags=<span class="hljs-subst">${tags}</span>&amp;format=json&amp;jsoncallback=?`</span>;
  $.getJSON(url, (data) =&gt; {
    <span class="hljs-keyword">let</span> urls = data.items.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.media.m)
    <span class="hljs-keyword">let</span> images = urls.map(url) =&gt; $(<span class="hljs-string">'&lt;img /&gt;'</span>, {<span class="hljs-attr">src</span>:url}) );
    
    $(<span class="hljs-built_in">document</span>.body).html(images);
  })
}
app(<span class="hljs-string">"cats"</span>);</code></pre>
<p>或者可以使用<strong>fetch</strong>和<strong>Promise</strong>来更好的进行异步操作。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let flickr = (tags)=> {
  let url = `http://api.flickr.com/services/feeds/photos_public.gne?tags=${tags}&amp;format=json&amp;jsoncallback=?`
  
  return fetch(url)
    .then((resp)=> resp.json())
    .then((data)=> {
      let urls = data.items.map((item)=> item.media.m )
      let images = urls.map((url)=> $('<img />', { src: url }) )

      return images
  })
}
flickr(&quot;cats&quot;).then((images)=> {
  $(document.body).html(images)
})" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> flickr = <span class="hljs-function">(<span class="hljs-params">tags</span>)=&gt;</span> {
  <span class="hljs-keyword">let</span> url = <span class="hljs-string">`http://api.flickr.com/services/feeds/photos_public.gne?tags=<span class="hljs-subst">${tags}</span>&amp;format=json&amp;jsoncallback=?`</span>
  
  <span class="hljs-keyword">return</span> fetch(url)
    .then(<span class="hljs-function">(<span class="hljs-params">resp</span>)=&gt;</span> resp.json())
    .then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span> {
      <span class="hljs-keyword">let</span> urls = data.items.map(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span> item.media.m )
      <span class="hljs-keyword">let</span> images = urls.map(<span class="hljs-function">(<span class="hljs-params">url</span>)=&gt;</span> $(<span class="hljs-string">'&lt;img /&gt;'</span>, { <span class="hljs-attr">src</span>: url }) )

      <span class="hljs-keyword">return</span> images
  })
}
flickr(<span class="hljs-string">"cats"</span>).then(<span class="hljs-function">(<span class="hljs-params">images</span>)=&gt;</span> {
  $(<span class="hljs-built_in">document</span>.body).html(images)
})</code></pre>
<p>Ajax请求和DOM操作都不是纯的，但是我们可以将余下的操作组成纯函数，将返回的JSON数据转换成图片节点数组。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let responseToImages = (resp) => {
  let urls = resp.items.map((item) => item.media.m)
  let images = urls.map((url) => $('<img />', {src:url}))
  
  return images
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> responseToImages = <span class="hljs-function">(<span class="hljs-params">resp</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> urls = resp.items.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.media.m)
  <span class="hljs-keyword">let</span> images = urls.map(<span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> $(<span class="hljs-string">'&lt;img /&gt;'</span>, {<span class="hljs-attr">src</span>:url}))
  
  <span class="hljs-keyword">return</span> images
}</code></pre>
<p>我们的函数做了2件事情：</p>
<ul>
<li><p>将返回的数据转换成urls</p></li>
<li><p>将urls转换成图片节点</p></li>
</ul>
<p>函数式的方法是将上述2个任务拆开，然后使用<strong>compose</strong>将一个函数的结果作为参数传给另一个参数。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let urls = (data) => {
  return data.items.map((item) => item.media.m)
}
let images = (urls) => {
  return urls.map((url) => $('<img />', {src: url}))
}
let responseToImages = _.compose(images, urls)" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> urls = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> data.items.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.media.m)
}
<span class="hljs-keyword">let</span> images = <span class="hljs-function">(<span class="hljs-params">urls</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> urls.map(<span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> $(<span class="hljs-string">'&lt;img /&gt;'</span>, {<span class="hljs-attr">src</span>: url}))
}
<span class="hljs-keyword">let</span> responseToImages = _.compose(images, urls)</code></pre>
<blockquote><p>compose 返回一系列函数的组合，每个函数都会将后一个函数的结果作为自己的入参</p></blockquote>
<p>这里compose做的事情，就是将urls的结果传入images函数</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let responseToImages = (data) => {
  return images(urls(data))
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> responseToImages = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> images(urls(data))
}</code></pre>
<p>通过将代码变成纯函数，让我们在以后有机会复用他们，他们更加容易被测试和自文档化。不好的是当我们过度的使用这些函数抽象（像第一个例子那样）， 就会使事情变得复杂，这不是我们想要的。当我们重构代码的时候最重要的是要问一下自己：</p>
<p><strong>这是否让代码更加容易阅读和理解？</strong></p>
<h1 id="articleHeader4">基本功能函数</h1>
<p>我并不是要诋毁函数式编程。每个程序员都应该齐心协力去学习基础函数，这些函数让你在编程过程中使用一些抽象出的一般模式，写出更加简洁明了的代码，或者像Marijn Haverbeke说的</p>
<blockquote><p>一个程序员能够用常规的基础函数武装自己，更重要的是知道如何使用它们，要比那些苦思冥想的人高效的多。--<a href="http://eloquentjavascript.net/1st_edition/chapter6.html" rel="nofollow noreferrer" target="_blank"> Eloquent JavaScript, Marijn Haverbeke</a></p></blockquote>
<p>这里列出了一些JavaScript开发者应该掌握的基础函数<br><strong>Arrays</strong><br>-<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="nofollow noreferrer" target="_blank">forEach</a><br>-<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="nofollow noreferrer" target="_blank">map</a><br>-<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="nofollow noreferrer" target="_blank">filter</a><br>-<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="nofollow noreferrer" target="_blank">reduce</a></p>
<p><strong>Functions</strong><br>-<a href="http://underscorejs.org/docs/underscore.html#section-83" rel="nofollow noreferrer" target="_blank">debounce</a><br>-<a href="http://underscorejs.org/docs/underscore.html#section-86" rel="nofollow noreferrer" target="_blank">compose</a><br>-<a href="http://underscorejs.org/docs/underscore.html#section-77" rel="nofollow noreferrer" target="_blank">partial</a><br>-<a href="https://lodash.com/docs/4.16.6#curry" rel="nofollow noreferrer" target="_blank">curry</a></p>
<h1 id="articleHeader5">Less is More</h1>
<p>让我们来通过实践看一下函数式编程能如何改善下面的代码</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let items = ['a', 'b', 'c'];
let upperCaseItems = () => {
  let arr = [];
  for (let i=0, ii= items.length; i<ii; i++) {
    let item = items[i];
    arr.push(item.toUpperCase());
  }
  items = arr;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> items = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<span class="hljs-keyword">let</span> upperCaseItems = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">let</span> arr = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>, ii= items.length; i&lt;ii; i++) {
    <span class="hljs-keyword">let</span> item = items[i];
    arr.push(item.toUpperCase());
  }
  items = arr;
}</code></pre>
<p><strong>共享状态来简化函数</strong></p>
<p>这看起来很明显且微不足道，但是我还是让函数访问和修改了外部的状态，这让函数难以测试且容易出错。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//pure
let upperCaseItems = (items) => {
  let arr = [];
  for (let i =0, ii= items.length; i< ii; i++) {
    let item = items[i];
    arr.push(item.toUpperCase());
  }
  return arr;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">//pure</span>
<span class="hljs-keyword">let</span> upperCaseItems = <span class="hljs-function">(<span class="hljs-params">items</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> arr = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>, ii= items.length; i&lt; ii; i++) {
    <span class="hljs-keyword">let</span> item = items[i];
    arr.push(item.toUpperCase());
  }
  <span class="hljs-keyword">return</span> arr;
}</code></pre>
<p><strong>使用更加可读的语言抽象forEach来迭代</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let upperCaseItems = (items) => {
  let arr = [];
  items.forEach((item) => {
    arr.push(item.toUpperCase());
  })
  return arr;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> upperCaseItems = <span class="hljs-function">(<span class="hljs-params">items</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> arr = [];
  items.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
    arr.push(item.toUpperCase());
  })
  <span class="hljs-keyword">return</span> arr;
}</code></pre>
<p><strong>使用map进一步简化代码</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let upperCaseItems = (items) => {
  return items.map((item) => item.toUpperCase())
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> upperCaseItems = <span class="hljs-function">(<span class="hljs-params">items</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> items.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.toUpperCase())
}</code></pre>
<p><strong>进一步简化代码</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let upperCase = (item) => item.toUpperCase()
let upperCaseItems = (item) => items.map(upperCase)" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> upperCase = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.toUpperCase()
<span class="hljs-keyword">let</span> upperCaseItems = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> items.map(upperCase)</code></pre>
<p><strong>删除代码直到它不能工作</strong></p>
<p>我们不需要为这种简单的任务编写函数，语言本身就提供了足够的抽象来完成功能</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="let items = ['a', 'b', 'c']
let upperCaseItems = item.map((item) => item.toUpperCase())" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">let</span> items = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]
<span class="hljs-keyword">let</span> upperCaseItems = item.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.toUpperCase())</code></pre>
<h1 id="articleHeader6">测试</h1>
<p>纯函数的一个关键优点是易于测试，所以在这一节我会为我们之前的Flicker模块编写测试。</p>
<p>我们会使用<a href="https://mochajs.org/#getting-started" rel="nofollow noreferrer" target="_blank">Mocha</a>来运行测试，使用<a href="http://babeljs.io/" rel="nofollow noreferrer" target="_blank">Babel</a>来编译ES6代码。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="mkdir test-harness
cd test-harness
npm init -y
npm install mocha babel-register babel-preset-es2015 --save-dev
echo '{ &quot;presets&quot;: [&quot;es2015&quot;] }' > .babelrc
mkdir test
touch test/example.js" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">mkdir test-harness
cd test-harness
npm init -y
npm install mocha babel-register babel-preset-es2015 --save-dev
echo <span class="hljs-string">'{ "presets": ["es2015"] }'</span> &gt; .babelrc
mkdir test
touch test/example.js</code></pre>
<p>Mocha提供了一些好用的函数如<strong>describe</strong>和<strong>it</strong>来拆分测试和钩子(例如before和after这种用来组装和拆分任务的钩子)。<a href="https://nodejs.org/api/assert.html" rel="nofollow noreferrer" target="_blank">assert</a>是用来进行相等测试的断言库，<strong>assert</strong>和<strong>assert.deepEqual</strong>是很有用且值得注意的函数。</p>
<p>让我们来编写第一个测试<strong>test/example.js</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="import assert from 'assert';

describe('Math', () => {
  describe('.floor', () => {
    it('rounds down to the nearest whole number', () => {
      let value = Math.floor(4.24)
      assert(value === 4)
    })
  })
})" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'assert'</span>;

describe(<span class="hljs-string">'Math'</span>, () =&gt; {
  describe(<span class="hljs-string">'.floor'</span>, () =&gt; {
    it(<span class="hljs-string">'rounds down to the nearest whole number'</span>, () =&gt; {
      <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">4.24</span>)
      assert(value === <span class="hljs-number">4</span>)
    })
  })
})</code></pre>
<p>打开package.json文件，将"test"脚本修改如下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="mocha --compilers js:babel-register --recursive" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs brainfuck"><code class="shell" style="word-break: break-word; white-space: initial;"><span class="hljs-comment">mocha</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">compilers</span> <span class="hljs-comment">js:babel</span><span class="hljs-literal">-</span><span class="hljs-comment">register</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">recursive</span></code></pre>
<p>然后你就可以在命令行运行npm test</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Math
  .floor
    ✓ rounds down to the nearest whole number
1 passing (32ms)" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs livecodeserver"><code>Math
  .floor
    ✓ rounds down <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> nearest <span class="hljs-keyword">whole</span> <span class="hljs-built_in">number</span>
<span class="hljs-number">1</span> passing (<span class="hljs-number">32</span>ms)</code></pre>
<p><strong>Note:</strong>如果你想让mocha监视改变，并且自动运行测试，可以在上述命令后面加上-w选项。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="mocha --compilers js:babel-register --recursive -w" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs brainfuck"><code class="shell" style="word-break: break-word; white-space: initial;"><span class="hljs-comment">mocha</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">compilers</span> <span class="hljs-comment">js:babel</span><span class="hljs-literal">-</span><span class="hljs-comment">register</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">recursive</span> <span class="hljs-literal">-</span><span class="hljs-comment">w</span></code></pre>
<h2 id="articleHeader7">测试我们的Flicker模块</h2>
<p>我们的模块文件是lib/flickr.js</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="import $ from 'jquery';
import { compose } from 'underscore';

let urls = (data) => {
  return data.items.map((item) => item.media.m)
}

let images = (urls) => {
  return urls.map((url) => $('<img />', {src: url})[0] )
}

let responseToImages = compose(images, urls)

let flickr = (tags) => {
  let url = `http://api.flickr.com/services/feeds/photos_public.gne?tags=${tags}&amp;format=json&amp;jsoncallback=?`
  
  return fetch(url)
    .then((response) => reponse.json())
    .then(responseToImages)
}

export default {
  _responseToImages: responseToImages,
  flickr: flickr
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;
<span class="hljs-keyword">import</span> { compose } <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;

<span class="hljs-keyword">let</span> urls = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> data.items.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.media.m)
}

<span class="hljs-keyword">let</span> images = <span class="hljs-function">(<span class="hljs-params">urls</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> urls.map(<span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> $(<span class="hljs-string">'&lt;img /&gt;'</span>, {<span class="hljs-attr">src</span>: url})[<span class="hljs-number">0</span>] )
}

<span class="hljs-keyword">let</span> responseToImages = compose(images, urls)

<span class="hljs-keyword">let</span> flickr = <span class="hljs-function">(<span class="hljs-params">tags</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> url = <span class="hljs-string">`http://api.flickr.com/services/feeds/photos_public.gne?tags=<span class="hljs-subst">${tags}</span>&amp;format=json&amp;jsoncallback=?`</span>
  
  <span class="hljs-keyword">return</span> fetch(url)
    .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> reponse.json())
    .then(responseToImages)
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">_responseToImages</span>: responseToImages,
  <span class="hljs-attr">flickr</span>: flickr
}</code></pre>
<p>我们的模块暴露了2个方法：一个公有<strong>flickr</strong>和一个私有函数<strong>_responseToImages</strong>,这样就可以独立的测试他们。</p>
<p>我们使用了一组依赖：<strong>jquery</strong>,<strong>underscore</strong>和polyfill函数<strong>fetch</strong>和<strong>Promise</strong>。为了测试他们，我们使用<strong>jsdom</strong>来模拟DOM对象<strong>window</strong>和<strong>document</strong>，使用<strong>sinon</strong>包来测试fetch api。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="npm install jquery underscore whatwg-fetch es6-promise jsdom sinon --save-dev
touch test/_setup.js" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs sql"><code class="shell">npm <span class="hljs-keyword">install</span> jquery underscore whatwg-<span class="hljs-keyword">fetch</span> es6-promise jsdom sinon <span class="hljs-comment">--save-dev</span>
touch <span class="hljs-keyword">test</span>/_setup.js</code></pre>
<p>打开test/_setup.js，使用全局对象来配置jsdom</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="global.document = require('jsdom').jsdom('<html></html>');
global.window = document.defaultView;
global.$ = require('jquery')(window);
global.fetch = require('whatwg-fetch').fetch;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">global.document = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jsdom'</span>).jsdom(<span class="hljs-string">'&lt;html&gt;&lt;/html&gt;'</span>);
global.window = <span class="hljs-built_in">document</span>.defaultView;
global.$ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>)(<span class="hljs-built_in">window</span>);
global.fetch = <span class="hljs-built_in">require</span>(<span class="hljs-string">'whatwg-fetch'</span>).fetch;</code></pre>
<p>我们的测试代码在test/flickr.js，我们将为函数的输出设置断言。我们"stub"或者覆盖全局的fetch方法，来阻断和模拟HTTP请求，这样我们就可以在不直接访问Flickr api的情况下运行我们的测试。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="import assert from 'assert';
import Flickr from '../lib/flickr';
import sinon from 'sinon';
import { Promise } from 'es6-promise';
import { Response } from 'whatwg-fetch';

let sampleResponse = {
  items: [{
    media: { m: 'lolcat.jpg' }
  }, {
    media: {m: 'dancing_pug.gif'}
  }]
}

//实际项目中我们会将这个test helper移到一个模块里
let jsonResponse = (obj) => {
  let json = JSON.stringify(obj);
  var response = new Response(json, {
    status: 200,
    headers: {'Content-type': 'application/json'}
  });
  return Promise.resolve(response);
}


describe('Flickr', () => {
  describe('._responseToImages', () => {
    it(&quot;maps response JSON to a NodeList of <img>&quot;, () => {
      let images = Flickr._responseToImages(sampleResponse);
      
      assert(images.length === 2);
      assert(images[0].nodeName === 'IMG');
      assert(images[0].src === 'lolcat.jpg');
    })
  })
  
  describe('.flickr', () => {
    //截断fetch 请求，返回一个Promise对象
    before(() => {
      sinon.stub(global, 'fetch', (url) => {
        return jsonResponse(sampleResponse)
      })
    })
    
    after(() => {
      global.fetch.restore();
    })
    
    it(&quot;returns a Promise that resolve with a NodeList of <img>&quot;, (done) => {
      Flickr.flickr('cats').then((images) => {
        assert(images.length === 2);
        assert(images[1].nodeName === 'IMG');
        assert(images[1].src === 'dancing_pug.gif');
        done();
      })
    })
  })  
  
})" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'assert'</span>;
<span class="hljs-keyword">import</span> Flickr <span class="hljs-keyword">from</span> <span class="hljs-string">'../lib/flickr'</span>;
<span class="hljs-keyword">import</span> sinon <span class="hljs-keyword">from</span> <span class="hljs-string">'sinon'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-built_in">Promise</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'es6-promise'</span>;
<span class="hljs-keyword">import</span> { Response } <span class="hljs-keyword">from</span> <span class="hljs-string">'whatwg-fetch'</span>;

<span class="hljs-keyword">let</span> sampleResponse = {
  <span class="hljs-attr">items</span>: [{
    <span class="hljs-attr">media</span>: { <span class="hljs-attr">m</span>: <span class="hljs-string">'lolcat.jpg'</span> }
  }, {
    <span class="hljs-attr">media</span>: {<span class="hljs-attr">m</span>: <span class="hljs-string">'dancing_pug.gif'</span>}
  }]
}

<span class="hljs-comment">//实际项目中我们会将这个test helper移到一个模块里</span>
<span class="hljs-keyword">let</span> jsonResponse = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> json = <span class="hljs-built_in">JSON</span>.stringify(obj);
  <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">new</span> Response(json, {
    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">headers</span>: {<span class="hljs-string">'Content-type'</span>: <span class="hljs-string">'application/json'</span>}
  });
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(response);
}


describe(<span class="hljs-string">'Flickr'</span>, () =&gt; {
  describe(<span class="hljs-string">'._responseToImages'</span>, () =&gt; {
    it(<span class="hljs-string">"maps response JSON to a NodeList of &lt;img&gt;"</span>, () =&gt; {
      <span class="hljs-keyword">let</span> images = Flickr._responseToImages(sampleResponse);
      
      assert(images.length === <span class="hljs-number">2</span>);
      assert(images[<span class="hljs-number">0</span>].nodeName === <span class="hljs-string">'IMG'</span>);
      assert(images[<span class="hljs-number">0</span>].src === <span class="hljs-string">'lolcat.jpg'</span>);
    })
  })
  
  describe(<span class="hljs-string">'.flickr'</span>, () =&gt; {
    <span class="hljs-comment">//截断fetch 请求，返回一个Promise对象</span>
    before(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      sinon.stub(global, <span class="hljs-string">'fetch'</span>, (url) =&gt; {
        <span class="hljs-keyword">return</span> jsonResponse(sampleResponse)
      })
    })
    
    after(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      global.fetch.restore();
    })
    
    it(<span class="hljs-string">"returns a Promise that resolve with a NodeList of &lt;img&gt;"</span>, (done) =&gt; {
      Flickr.flickr(<span class="hljs-string">'cats'</span>).then(<span class="hljs-function">(<span class="hljs-params">images</span>) =&gt;</span> {
        assert(images.length === <span class="hljs-number">2</span>);
        assert(images[<span class="hljs-number">1</span>].nodeName === <span class="hljs-string">'IMG'</span>);
        assert(images[<span class="hljs-number">1</span>].src === <span class="hljs-string">'dancing_pug.gif'</span>);
        done();
      })
    })
  })  
  
})</code></pre>
<p>运行npm test，会得到如下结果：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Math
  .floor
    ✓ rounds down to the nearest whole number

Flickr
  ._responseToImages
    ✓ maps response JSON to a NodeList of <img>
  .flickr
    ✓ returns a Promise that resolves with a NodeList of <img>

3 passing (67ms)" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs livecodeserver"><code>Math
  .floor
    ✓ rounds down <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> nearest <span class="hljs-keyword">whole</span> <span class="hljs-built_in">number</span>

Flickr
  .<span class="hljs-title">_response</span>ToImages
    ✓ maps response JSON <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> NodeList <span class="hljs-keyword">of</span> &lt;img&gt;
  .flickr
    ✓ returns <span class="hljs-keyword">a</span> Promise that resolves <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> NodeList <span class="hljs-keyword">of</span> &lt;img&gt;

<span class="hljs-number">3</span> passing (<span class="hljs-number">67</span>ms)</code></pre>
<p>到这里，我们已经成功的测试了我们的模块以及组成它的函数，学习到了纯函数以及如何使用函数组合。我们知道了纯函数与不纯函数的区别，知道纯函数更可读，由小函数组成，更容易测试。相比于不太合理的纯函数式编程，我们的代码更加可读、理解和修改，这也是我们重构代码的目的。</p>
<h1 id="articleHeader8">Links</h1>
<ul>
<li><p><a href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/index.html" rel="nofollow noreferrer" target="_blank">Professor Frisby’s Mostly Adequate Guide to Functional Programming – @drboolean</a>-这是一本很优秀的介绍函数式编程的书，本文的很多内容和例子出自这本书</p></li>
<li><p><a href="http://eloquentjavascript.net/1st_edition/chapter6.html" rel="nofollow noreferrer" target="_blank">Eloquent Javascript – Functional Programming @marijnjh</a>-介绍编程的好书，同样有一章介绍函数式编程的内容很棒</p></li>
<li><p><a href="http://underscorejs.org/docs/underscore.html" rel="nofollow noreferrer" target="_blank">Underscore</a>-深入的挖掘像Underscore，<a href="https://lodash.com/" rel="nofollow noreferrer" target="_blank">lodash</a>,<a href="http://ramdajs.com/docs/" rel="nofollow noreferrer" target="_blank">Ramda</a>这样的工具库是成为成熟开发者的重要一步。理解如何使用这些函数将极大降低你代码的长度，让你的程序更加声明式的。</p></li>
</ul>
<p>以上就是本文的全部！非常感谢阅读，我希望这篇文章很好的向你介绍了函数式编程，重构以及测试你的JavaScript。由于目前特别火热的库如<a href="https://facebook.github.io/react/" rel="nofollow noreferrer" target="_blank">React</a>,<a href="http://redux.js.org/" rel="nofollow noreferrer" target="_blank">Redux</a>,<a href="http://elm-lang.org/" rel="nofollow noreferrer" target="_blank">Elm</a>,<a href="http://cycle.js.org/" rel="nofollow noreferrer" target="_blank">Cycle</a>和<a href="http://reactivex.io/" rel="nofollow noreferrer" target="_blank">ReactiveX</a>都在鼓励和使用这种模式，所以这个时候写这样一篇有趣的范例也算是推波助流吧。</p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
合理的使用纯函数式编程

## 原文链接
[https://segmentfault.com/a/1190000007491981](https://segmentfault.com/a/1190000007491981)

