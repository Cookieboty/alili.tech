---
title: '同步、异步、阻塞与非阻塞' 
date: 2018-12-03 2:30:08
hidden: true
slug: 8k0vk7c8gy
categories: [reprint]
---

{{< raw >}}

                    
<p>在实际应用中，只有三种调用方式：<strong>同步-阻塞、同步-非阻塞和异步</strong>。</p>
<h3>同步 (synchronous) vs. 异步 (asynchronous)</h3>
<p>同步和异步关注的是<strong>消息通信机制</strong>。</p>
<ul>
<li>
<strong>同步</strong>：发出一个调用，在没有得到结果之前，该调用不返回。一旦调用返回，就得到返回值了。</li>
<li>
<strong>异步</strong>：发出一个调用，这个调用就直接返回了，所以没有返回结果。<strong>当被调用者获得结果，会使用其他方式来通知调用者，或者通过回调函数来处理这个调用。</strong>
</li>
</ul>
<p>举个通俗的例子：</p>
<ul>
<li>你打电话问书店老板有没有《分布式系统》这本书。如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。</li>
<li>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你（回调函数）。</li>
</ul>
<h3>阻塞 (blocking) vs. 非阻塞 (non-blocking)</h3>
<p>阻塞和非阻塞关注的是<strong>程序在等待调用结果时的状态</strong>。</p>
<ul>
<li>
<strong>阻塞</strong>调用：在调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>
<li>
<strong>非阻塞</strong>调用：在不能立刻得到结果时，该调用不会阻塞当前线程。</li>
</ul>
<p>还是上面的例子：</p>
<ul>
<li>你打电话问书店老板有没有《分布式系统》这本书。如果是阻塞式调用，你会一直等待，直到得到这本书有没有的结果。</li>
<li>如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了。你可能要偶尔过几分钟询问一下老板有没有返回结果（异步-轮询），或者让老板主动打电话来告诉你结果（异步-回调）。</li>
</ul>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
同步、异步、阻塞与非阻塞

## 原文链接
[https://segmentfault.com/a/1190000014644776](https://segmentfault.com/a/1190000014644776)

