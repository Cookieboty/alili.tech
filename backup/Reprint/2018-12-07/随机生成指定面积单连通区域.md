---
title: '随机生成指定面积单连通区域' 
date: 2018-12-07 2:30:10
hidden: true
slug: ssgl9ms28o
categories: [reprint]
---

{{< raw >}}

                    
<blockquote>原文链接：<a href="https://xcoder.in/2018/04/01/random-connected-area/" rel="nofollow noreferrer" target="_blank">https://xcoder.in/2018/04/01/random-connected-area/</a>
</blockquote>
<p>最近在知乎上看到一个问题，「<a href="https://www.zhihu.com/question/269483551/answer/354477009" rel="nofollow noreferrer" target="_blank">随机生成指定面积单连通区域？</a>」，感觉还挺有意思的，于是整理一下写一篇新文章。</p>
<h2 id="articleHeader0">问题阐述</h2>
<p>如下图所示，在 10x10 的区域中，随机生成面积为 6 的单连通区域，该「随机」包括「位置随机」以及「形状随机」。</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014167828?w=2888&amp;h=3124" src="https://static.alili.tech/img/remote/1460000014167828?w=2888&amp;h=3124" alt="示意图" title="示意图" style="cursor: pointer; display: inline;"></span></p>
<p>注意：</p>
<ol>
<li>单连通区域定义是该区域每一个区块上下左右至少连着另一个区块；</li>
<li>采用周期性结构，超出右边移到最左边，以此类推。</li>
</ol>
<blockquote>其中点 2 可以分采用和不采用周期性结构分别讨论。</blockquote>
<h2 id="articleHeader1">随便说说</h2>
<p>这个问题，我不知道原题提问者想要做什么事。但是就这题本身而言，我们可以拿它去生成一个随机地图，例如：</p>
<blockquote>建造、等待的沙盒类手游，游戏中有一个空岛，玩家能在上面建造自己的建筑然后等待各种事件完成。<strong>空岛形状随机生成，并且都联通且面积一定，这样每个玩家进去的时候就能得到不同地形</strong>。</blockquote>
<h2 id="articleHeader2">解决一下</h2>
<p>在得知了问题原题之后，我们就可以照着题目的意思开始解决了。</p>
<h3 id="articleHeader3">DFS</h3>
<p>其实这么一个问题一出现，脑子里面就瞬间涌出几个词汇：<a href="https://en.wikipedia.org/wiki/Depth-first_search" rel="nofollow noreferrer" target="_blank">DFS</a>、<a href="https://en.wikipedia.org/wiki/Flood_fill" rel="nofollow noreferrer" target="_blank">Flood fill</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86" rel="nofollow noreferrer" target="_blank">并查集</a>等等。</p>
<p>那么其实这最粗暴的办法相当于你假想有一个连通区域，然后你去 Flood fill 它——至于墙在哪，在递归的每一个节点的时候<strong>随机一下搜索方向的顺序就可以了</strong>。</p>
<h4>实现外壳</h4>
<p>我们先实现一个类的框架吧（我是 Node.js 开发者，自然用 JavaScript 进行 Demo 的输出）。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const INIT = Symbol(&quot;init&quot;);

class Filler {
    /**
     * Filler 构造函数
     * @constructor
     * @param {Number} length 地图总宽高
     * @param {Number} needArea 需要填充的区域面积
     */
    constructor(length, needArea) {
        this.length = length;
        this.needArea = needArea;
    }

    /**
     * 初始化地图
     */
    [INIT]() {
        /**
         * 为了方便，地图就用一个二维字符数组表示
         *
         *   + . 代表空地
         *   + x 代表填充
         */
        this.map = [];
        this.count = 0;
        for(let i = 0; i < this.length; i++) {
            let row = [];
            for (let j = 0; j < this.length; j++) row.push(&quot;.&quot;);
            this.map.push(row);
        }
     }

     /**
      * 填充递归函数
      * @param {Number} x 坐标 X 轴的值
      * @param {Number} y 坐标 Y 轴的值
      * @return 填充好的地图二维数组
      */
     fill(x, y) {
        // 待实现
     }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">const</span> INIT = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"init"</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Filler</span> </span>{
    <span class="hljs-comment">/**
     * Filler 构造函数
     * @constructor
     * @param {Number} length 地图总宽高
     * @param {Number} needArea 需要填充的区域面积
     */</span>
    <span class="hljs-keyword">constructor</span>(length, needArea) {
        <span class="hljs-keyword">this</span>.length = length;
        <span class="hljs-keyword">this</span>.needArea = needArea;
    }

    <span class="hljs-comment">/**
     * 初始化地图
     */</span>
    [INIT]() {
        <span class="hljs-comment">/**
         * 为了方便，地图就用一个二维字符数组表示
         *
         *   + . 代表空地
         *   + x 代表填充
         */</span>
        <span class="hljs-keyword">this</span>.map = [];
        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) {
            <span class="hljs-keyword">let</span> row = [];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">this</span>.length; j++) row.push(<span class="hljs-string">"."</span>);
            <span class="hljs-keyword">this</span>.map.push(row);
        }
     }

     <span class="hljs-comment">/**
      * 填充递归函数
      * @param {Number} x 坐标 X 轴的值
      * @param {Number} y 坐标 Y 轴的值
      * @return 填充好的地图二维数组
      */</span>
     fill(x, y) {
        <span class="hljs-comment">// 待实现</span>
     }
}</code></pre>
<h4>非周期性实现</h4>
<p>有了架子之后，我们就可以实现递归函数 <code>fill</code> 了，整理一下流程如下：</p>
<ol>
<li>随机一个起点位置，并以此开始递归搜索；</li>
<li>
<p><code>fill(x, y)</code> 进入递归搜索：</p>
<ol>
<li>如果需要初始化地图就调用 <code>this[INIT]()</code>；</li>
<li>
<code>this.count++</code>，表示填充区域面积加了 <code>1</code>，并在数组中将该位置填充为 <code>x</code>；</li>
<li>
<p><code>this.count</code> 是否等于所需要的面积：</p>
<ol>
<li>若等于，则返回当前的地图状态；</li>
<li>若不等于，则继续 2.4；</li>
</ol>
</li>
<li>随机四个方向的顺序；</li>
<li>
<p>对四个方向进行循环：</p>
<ol>
<li>
<code>x</code>、<code>y</code> 轴的值按当前方向走一个算出新的坐标值 <code>newX</code> 和 <code>newY</code>；</li>
<li>
<p>判断坐标是否合法（越界算非法）：</p>
<ol>
<li>若非法则回 2.5 继续下一个方向；</li>
<li>若合法则继续 2.5.3；</li>
</ol>
</li>
<li>递归 <code>fill(newX, newY)</code> 得到结果，若有结果则返回；</li>
</ol>
</li>
<li>若循环完四个方向都还没返回结果则会跳到这一步来，这个时候进行状态还原，递归跳回上一层进行下一个状态的搜索。</li>
</ol>
</li>
</ol>
<blockquote>在这里「状态还原」表示把 <code>this.count--</code> 还原回当前坐标填充前的状态，并且把当前填充的 <code>'x'</code> 给还原回 <code>'.'</code>。</blockquote>
<p>照着上面的流程很快就能得出代码结论：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const _ = require(&quot;lodash&quot;);

class Filler {
    ...

    fill(x, y) {
        // 初始化地图
        const needInit = !arguments[2];
        if(needInit) this[INIT]();

        // 如果当前坐标已被填充，则返回空
        if(this.map[x][y] === &quot;x&quot;) return;

        // 填充当前坐标
        this.count++;
        this.map[x][y] = &quot;x&quot;;

        // 填充满了则返回当前地图
        if(this.count === this.needArea) return Object.assign([], this.map);

        // 随机四个方向的顺序
        const dirs = _.shuffle([ [ 0, 1 ], [ 0, -1 ], [ 1, 0 ], [ -1, 0 ] ]);

        // 循环四个方向
        for(let i = 0; i < 4; i++) {
            const dir = dirs[i];
            let newX = x + dir[0];
            let newY = y + dir[1];

            // 判断边界
            {
                if(newX < 0 || newX >= this.length || newY < 0 || newY >= this.length) continue;
            }

            // 进入下一层递归并得到结果
            const ret = this.fill(newX, newY, true);

            // 若结果非空则返回结果
            if(ret) return ret;
        }

        // 状态还原
        this.count--;
        this.map[x][y] = &quot;.&quot;;
    }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">"lodash"</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Filler</span> </span>{
    ...

    fill(x, y) {
        <span class="hljs-comment">// 初始化地图</span>
        <span class="hljs-keyword">const</span> needInit = !<span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>];
        <span class="hljs-keyword">if</span>(needInit) <span class="hljs-keyword">this</span>[INIT]();

        <span class="hljs-comment">// 如果当前坐标已被填充，则返回空</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.map[x][y] === <span class="hljs-string">"x"</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-comment">// 填充当前坐标</span>
        <span class="hljs-keyword">this</span>.count++;
        <span class="hljs-keyword">this</span>.map[x][y] = <span class="hljs-string">"x"</span>;

        <span class="hljs-comment">// 填充满了则返回当前地图</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.count === <span class="hljs-keyword">this</span>.needArea) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign([], <span class="hljs-keyword">this</span>.map);

        <span class="hljs-comment">// 随机四个方向的顺序</span>
        <span class="hljs-keyword">const</span> dirs = _.shuffle([ [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> ], [ <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> ] ]);

        <span class="hljs-comment">// 循环四个方向</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
            <span class="hljs-keyword">const</span> dir = dirs[i];
            <span class="hljs-keyword">let</span> newX = x + dir[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">let</span> newY = y + dir[<span class="hljs-number">1</span>];

            <span class="hljs-comment">// 判断边界</span>
            {
                <span class="hljs-keyword">if</span>(newX &lt; <span class="hljs-number">0</span> || newX &gt;= <span class="hljs-keyword">this</span>.length || newY &lt; <span class="hljs-number">0</span> || newY &gt;= <span class="hljs-keyword">this</span>.length) <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-comment">// 进入下一层递归并得到结果</span>
            <span class="hljs-keyword">const</span> ret = <span class="hljs-keyword">this</span>.fill(newX, newY, <span class="hljs-literal">true</span>);

            <span class="hljs-comment">// 若结果非空则返回结果</span>
            <span class="hljs-keyword">if</span>(ret) <span class="hljs-keyword">return</span> ret;
        }

        <span class="hljs-comment">// 状态还原</span>
        <span class="hljs-keyword">this</span>.count--;
        <span class="hljs-keyword">this</span>.map[x][y] = <span class="hljs-string">"."</span>;
    }
}</code></pre>
<p>这么一来，类就写好了。接下去我们只要实现一些交互的代码，就可以看效果了。</p>
<blockquote>
<a href="https://jsfiddle.net/XadillaX/x2ur8kvj/" rel="nofollow noreferrer" target="_blank">点我</a><button class="btn btn-xs btn-default ml10 preview" data-url="XadillaX/x2ur8kvj/" data-typeid="0">点击预览</button>进入 JSFiddle 看效果。</blockquote>
<p>如果懒得进入 JSFiddle 看，也可以看看下面的几个截图：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014167829?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167829?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></p>
<p>10x10 填 50 效果图</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014167830?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167830?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></p>
<p>10x10 填 6 效果图</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014167831?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167831?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></p>
<p>50x50 填 50 效果图</p>
<h4>周期性实现</h4>
<p>其实原题说了一个条件，那就是<strong>采用周期性结构，超出右边移到最左边，以此类推</strong>。</p>
<p>而我们前文的代码其实是照着非周期性结构来实现的。不过如果我们要将其改成周期性实现也很简单，只需要把前文代码中边界判断的那一句代码改为周期性计算的代码即可，也就是说要把这段代码：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 判断边界
{
    if(newX < 0 || newX >= this.length || newY < 0 || newY >= this.length) continue;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">// 判断边界</span>
{
    <span class="hljs-keyword">if</span>(newX &lt; <span class="hljs-number">0</span> || newX &gt;= <span class="hljs-keyword">this</span>.length || newY &lt; <span class="hljs-number">0</span> || newY &gt;= <span class="hljs-keyword">this</span>.length) <span class="hljs-keyword">continue</span>;
}</code></pre>
<p>改为：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 周期性计算
{
    if(newX < 0) newX = this.length - 1;
    if(newX >= this.length) newX = 0;
    if(newY < 0) newY = this.length - 1;
    if(newY >= this.length) newY = 0;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">// 周期性计算</span>
{
    <span class="hljs-keyword">if</span>(newX &lt; <span class="hljs-number">0</span>) newX = <span class="hljs-keyword">this</span>.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(newX &gt;= <span class="hljs-keyword">this</span>.length) newX = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(newY &lt; <span class="hljs-number">0</span>) newY = <span class="hljs-keyword">this</span>.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(newY &gt;= <span class="hljs-keyword">this</span>.length) newY = <span class="hljs-number">0</span>;
}</code></pre>
<p>这个时候出来的效果就是这样的了：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014167832?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167832?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></p>
<p>10x10 填 50 周期性效果图</p>
<h4>抛弃状态还原</h4>
<p>至此为止 DFS 的代码基本上完成了。不过目前来说，当然这个算法的一个缺陷就是，当需要面积与总面积比例比较大的时候，有可能陷入搜索的死循环（或者说效率特别低），因为要不断复盘。</p>
<p>所以我们可以做点改造——由于我们不是真的为了搜索到某个状态，而只是为了填充我们的小点点，那么 DFS 中比较经典的「状态还原」就不需要了，也就是说：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="this.count--;
this.mat[x][y] = &quot;.&quot;;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">this</span>.count--;
<span class="hljs-keyword">this</span>.mat[x][y] = <span class="hljs-string">"."</span>;</code></pre>
<p>这两行代码可以删掉了，用删掉上面两行代码的代码跑一下，我用 50x50 填充 800 格子的效果：</p>
<table><thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167833?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167833?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167834?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167834?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167835?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167835?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167836?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167836?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
</tr></thead></table>
<p>继续之前的 50x50 填充 50：</p>
<table><thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167837?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167837?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167838?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167838?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167839?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167839?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167840?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167840?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
</tr></thead></table>
<h3 id="articleHeader4">生成「胖胖的」区域</h3>
<p>上面 DFS 的方法，由于每次都要走完一条路，虽然会转弯导致黏连，但在填充区域很小的情况下，很容易生成“瘦瘦的区域”。</p>
<p>这里再给出另一个方法，一个 <code>for</code> 搞定的，思路如下：</p>
<ol>
<li>先随机一个起始点，并将该点加入边界池；</li>
<li>
<p>循环 N - 1 次（N 为所需要填充的面积）：</p>
<ol>
<li>从边界池中随机取出一个边界；</li>
<li>算出与其接壤的四个点，取出还未被填充的点；</li>
<li>在取出的点中随机一个将其填充；</li>
<li>填充后计算改点接壤的四个点是否有全都是已经填充了的，若不是，则将该坐标加入边界池；</li>
<li>拿着刚才计算的接壤的四个点，分别判断其是否周边四个点都已被填充，若是且该点在边界池中，则从边界池拿走；</li>
<li>回到第二大步继续循环；</li>
</ol>
</li>
<li>返回填充好的结果。</li>
</ol>
<p>给出代码 Demo：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function random(max) {
    return Math.round(Math.random() * max);
}

class Filler2 {
    constructor(length, needArea) {
        this.length = length;
        this.needArea = needArea;
    }

    _getContiguous(frontier) {
        return Filler2.DIRS.map(dir => ({
            x: frontier.x + dir[0],
            y: frontier.y + dir[1]
        }));
    }

    fill() {
        const mat = [];
        for (let i = 0; i < this.length; i++) {
            let row = [];
            for (let j = 0; j < this.length; j++) row.push(&quot;.&quot;);
            mat.push(row);
        }

        const start = {
            x: random(this.length - 1),
            y: random(this.length - 1)
        };
        mat[start.x][start.y] = &quot;x&quot;;

        let frontierCount = 1;
        const frontiers = {
            [`${start.x}:${start.y}`]: true
        };

        for (let i = 1; i < this.needArea; i++) {
            // 取出一个边界
            const randIdx = random(frontierCount - 1);
            const frontier = Object.keys(frontiers)[randIdx].split(&quot;:&quot;).map(n => parseInt(n));

            // _getContiguous 算出接壤坐标，filter 去除无用坐标
            const newCoors = this._getContiguous({
                x: frontier[0],
                y: frontier[1]
            }).filter(coor => {
                if (coor.x < 0 || coor.y < 0 || coor.x >= this.length || coor.y >= this.length) return false;
                if (mat[coor.x][coor.y] === &quot;x&quot;) return false;
                return true;
            });

            // 随机取一个坐标
            const newCoor = newCoors[random(0, newCoors.length - 1)];

            // 填充进去
            mat[newCoor.x][newCoor.y] = &quot;x&quot;;

            // 获取接壤坐标
            const contiguousOfNewCoor = this._getContiguous(newCoor).filter(coor => {
                if (coor.x < 0 || coor.y < 0 || coor.x >= this.length || coor.y >= this.length) return false;
                return true;
            });

            // 若有一个接壤点为空，就认为当前坐标是边界，若是边界则把当前坐标加入对象
            if (contiguousOfNewCoor.reduce((ret, coor) => {
                    if (mat[coor.x][coor.y] === &quot;x&quot;) return ret;
                    return true;
                }, false)) {
                frontiers[`${newCoor.x}:${newCoor.y}`] = true;
                frontierCount++;
            }

            // 再检查接壤的坐标是否继续为边界
            for (let i = 0; i < contiguousOfNewCoor.length; i++) {
                const cur = contiguousOfNewCoor[i];

                const isFrontier = this._getContiguous(cur).filter(coor => {
                    if (coor.x < 0 || coor.y < 0 || coor.x >= this.length || coor.y >= this.length) return false;
                    return true;
                }).reduce((ret, coor) => {
                    if (mat[coor.x][coor.y] === &quot;x&quot;) return ret;
                    return true;
                }, false);

                // 若不是边界的话，只管删除
                if (!isFrontier &amp;&amp; frontiers[`${cur.x}:${cur.y}`]) {
                    delete frontiers[`${cur.x}:${cur.y}`];
                    frontierCount--;
                }
            }
        }

        // 一圈下来，就出结果了
        return mat;
    }
}

Filler2.DIRS = [ [ 0, 1 ], [ 0, -1 ], [ 1, 0 ], [ -1, 0 ] ];" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random</span>(<span class="hljs-params">max</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.random() * max);
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Filler2</span> </span>{
    <span class="hljs-keyword">constructor</span>(length, needArea) {
        <span class="hljs-keyword">this</span>.length = length;
        <span class="hljs-keyword">this</span>.needArea = needArea;
    }

    _getContiguous(frontier) {
        <span class="hljs-keyword">return</span> Filler2.DIRS.map(<span class="hljs-function"><span class="hljs-params">dir</span> =&gt;</span> ({
            <span class="hljs-attr">x</span>: frontier.x + dir[<span class="hljs-number">0</span>],
            <span class="hljs-attr">y</span>: frontier.y + dir[<span class="hljs-number">1</span>]
        }));
    }

    fill() {
        <span class="hljs-keyword">const</span> mat = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) {
            <span class="hljs-keyword">let</span> row = [];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">this</span>.length; j++) row.push(<span class="hljs-string">"."</span>);
            mat.push(row);
        }

        <span class="hljs-keyword">const</span> start = {
            <span class="hljs-attr">x</span>: random(<span class="hljs-keyword">this</span>.length - <span class="hljs-number">1</span>),
            <span class="hljs-attr">y</span>: random(<span class="hljs-keyword">this</span>.length - <span class="hljs-number">1</span>)
        };
        mat[start.x][start.y] = <span class="hljs-string">"x"</span>;

        <span class="hljs-keyword">let</span> frontierCount = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> frontiers = {
            [<span class="hljs-string">`<span class="hljs-subst">${start.x}</span>:<span class="hljs-subst">${start.y}</span>`</span>]: <span class="hljs-literal">true</span>
        };

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-keyword">this</span>.needArea; i++) {
            <span class="hljs-comment">// 取出一个边界</span>
            <span class="hljs-keyword">const</span> randIdx = random(frontierCount - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">const</span> frontier = <span class="hljs-built_in">Object</span>.keys(frontiers)[randIdx].split(<span class="hljs-string">":"</span>).map(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-built_in">parseInt</span>(n));

            <span class="hljs-comment">// _getContiguous 算出接壤坐标，filter 去除无用坐标</span>
            <span class="hljs-keyword">const</span> newCoors = <span class="hljs-keyword">this</span>._getContiguous({
                <span class="hljs-attr">x</span>: frontier[<span class="hljs-number">0</span>],
                <span class="hljs-attr">y</span>: frontier[<span class="hljs-number">1</span>]
            }).filter(<span class="hljs-function"><span class="hljs-params">coor</span> =&gt;</span> {
                <span class="hljs-keyword">if</span> (coor.x &lt; <span class="hljs-number">0</span> || coor.y &lt; <span class="hljs-number">0</span> || coor.x &gt;= <span class="hljs-keyword">this</span>.length || coor.y &gt;= <span class="hljs-keyword">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (mat[coor.x][coor.y] === <span class="hljs-string">"x"</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            });

            <span class="hljs-comment">// 随机取一个坐标</span>
            <span class="hljs-keyword">const</span> newCoor = newCoors[random(<span class="hljs-number">0</span>, newCoors.length - <span class="hljs-number">1</span>)];

            <span class="hljs-comment">// 填充进去</span>
            mat[newCoor.x][newCoor.y] = <span class="hljs-string">"x"</span>;

            <span class="hljs-comment">// 获取接壤坐标</span>
            <span class="hljs-keyword">const</span> contiguousOfNewCoor = <span class="hljs-keyword">this</span>._getContiguous(newCoor).filter(<span class="hljs-function"><span class="hljs-params">coor</span> =&gt;</span> {
                <span class="hljs-keyword">if</span> (coor.x &lt; <span class="hljs-number">0</span> || coor.y &lt; <span class="hljs-number">0</span> || coor.x &gt;= <span class="hljs-keyword">this</span>.length || coor.y &gt;= <span class="hljs-keyword">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            });

            <span class="hljs-comment">// 若有一个接壤点为空，就认为当前坐标是边界，若是边界则把当前坐标加入对象</span>
            <span class="hljs-keyword">if</span> (contiguousOfNewCoor.reduce(<span class="hljs-function">(<span class="hljs-params">ret, coor</span>) =&gt;</span> {
                    <span class="hljs-keyword">if</span> (mat[coor.x][coor.y] === <span class="hljs-string">"x"</span>) <span class="hljs-keyword">return</span> ret;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }, <span class="hljs-literal">false</span>)) {
                frontiers[<span class="hljs-string">`<span class="hljs-subst">${newCoor.x}</span>:<span class="hljs-subst">${newCoor.y}</span>`</span>] = <span class="hljs-literal">true</span>;
                frontierCount++;
            }

            <span class="hljs-comment">// 再检查接壤的坐标是否继续为边界</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; contiguousOfNewCoor.length; i++) {
                <span class="hljs-keyword">const</span> cur = contiguousOfNewCoor[i];

                <span class="hljs-keyword">const</span> isFrontier = <span class="hljs-keyword">this</span>._getContiguous(cur).filter(<span class="hljs-function"><span class="hljs-params">coor</span> =&gt;</span> {
                    <span class="hljs-keyword">if</span> (coor.x &lt; <span class="hljs-number">0</span> || coor.y &lt; <span class="hljs-number">0</span> || coor.x &gt;= <span class="hljs-keyword">this</span>.length || coor.y &gt;= <span class="hljs-keyword">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }).reduce(<span class="hljs-function">(<span class="hljs-params">ret, coor</span>) =&gt;</span> {
                    <span class="hljs-keyword">if</span> (mat[coor.x][coor.y] === <span class="hljs-string">"x"</span>) <span class="hljs-keyword">return</span> ret;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }, <span class="hljs-literal">false</span>);

                <span class="hljs-comment">// 若不是边界的话，只管删除</span>
                <span class="hljs-keyword">if</span> (!isFrontier &amp;&amp; frontiers[<span class="hljs-string">`<span class="hljs-subst">${cur.x}</span>:<span class="hljs-subst">${cur.y}</span>`</span>]) {
                    <span class="hljs-keyword">delete</span> frontiers[<span class="hljs-string">`<span class="hljs-subst">${cur.x}</span>:<span class="hljs-subst">${cur.y}</span>`</span>];
                    frontierCount--;
                }
            }
        }

        <span class="hljs-comment">// 一圈下来，就出结果了</span>
        <span class="hljs-keyword">return</span> mat;
    }
}

Filler2.DIRS = [ [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> ], [ <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> ] ];</code></pre>
<blockquote>
<strong>注意</strong>：上面的代码是我一溜烟写出来的，所以并没有后续优化代码简洁度，其实很多地方的代码可以抽象并复用的，懒得改了，能看就好了。用的时候就跟之前 DFS 代码一样 <code>new</code> 一个 <code>Filler2</code> 出来并 <code>fill</code> 就好了。<p>效果依然可以去 <a href="https://jsfiddle.net/XadillaX/36f6obca/" rel="nofollow noreferrer" target="_blank">JSFiddle</a><button class="btn btn-xs btn-default ml10 preview" data-url="XadillaX/36f6obca/" data-typeid="0">点击预览</button> 看。</p>
</blockquote>
<p>或者也可以直接看效果图：</p>
<table><thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167841?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167841?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167842?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167842?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167843?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167843?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167844?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167844?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
</tr></thead></table>
<p>50x50 填充 800 胖胖的区域</p>
<table><thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167845?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167845?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167846?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167846?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167847?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167847?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167848?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167848?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
</tr></thead></table>
<p>50x50 填充 50 胖胖的区域</p>
<p>显而易见，跟之前 DFS 生成出来的奇形怪状相比，这种算法生成的连通区域更像是一块 Mainland，而前者则更像是一个洼地沼泽或者丛林。</p>
<h3 id="articleHeader5">结合一下？</h3>
<p>前面两种算法，一个是生成瘦瘦的稀奇古怪的面积，一个是生成胖胖的区域。有没有办法说在生成胖胖的区域的情况下允许一定的稀奇古怪的形状呢？</p>
<p>其实将两种算法结合一下就好了。结合的做法有很多，这里举一个例子，大家可以自己再去想一些出来。</p>
<ol>
<li>首先将需要的区域对半分（即配比 1 : 1），例如如果需要 800，就分为 400 跟 400。（为了长得好看，其实这个比例可以自行调配）</li>
<li>将前一半的区域用 <code>for</code> 生成胖胖的区域；</li>
<li>将剩下的区域随机几次，每次随机一个剩下所需要的面积以内的数，将这个数字作为 DFS 所需要生成的面积量，并从边界数组中随机取一个边界坐标并计算其合法接壤坐标开始进行 DFS 得到结果；</li>
<li>循环第 3 步知道所需区域面积符合要求为止。</li>
</ol>
<blockquote>
<strong>注意</strong>：为了保证每次 DFS 一开始的时候都能取到最新的边界坐标，在 DFS 流程中的时候每标一个区域填充也必须走一遍边界坐标更新的逻辑。</blockquote>
<p>具体代码就不放文章里面解析了，大家也可以到 <a href="https://jsfiddle.net/XadillaX/0bnzpw8d/" rel="nofollow noreferrer" target="_blank">JSFiddle</a><button class="btn btn-xs btn-default ml10 preview" data-url="XadillaX/0bnzpw8d/" data-typeid="0">点击预览</button> 中去观看。</p>
<p>或者也可以直接看效果图：</p>
<table><thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167849?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167849?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167850?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167850?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167851?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167851?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167852?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167852?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
</tr></thead></table>
<p>50x50 填充 800 混合区域（配比 3 : 1）</p>
<table><thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167853?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167853?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167854?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167854?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167855?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167855?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167856?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167856?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></th>
</tr></thead></table>
<p>50x50 填充 50 胖胖的区域（配比 4 : 1）</p>
<h3 id="articleHeader6">还能更丧心病狂吗？</h3>
<p>结合了两种算法，我们得到了一个我认为可能会更好看一点的区域。</p>
<p>此外，我们还能继续「丧心病狂」一点，例如两种方式交替出现，流程如下：</p>
<ol>
<li>
<p>指定特定方法和面积，奇数次用 <code>for</code>，偶数次用 DFS；</p>
<ol>
<li>如果是 <code>for</code> 则随机一个 <code>Math.min(剩余面积, 总面积 / 4)</code> 的数字；</li>
<li>如果是 DFS 则随机一个 <code>Math.min(剩余面积, 总面积 / 10)</code> 的数字；</li>
</ol>
</li>
<li>从边界数组中取一个坐标，并从合法接壤坐标中取一个坐标出来；</li>
<li>以第 2 步取出的坐标为起点，使用第 1 步指定的方法生成第 1 步指定的面积的单连通区域；</li>
<li>如果生成面积仍小于指定面积，则回到第 1 步继续循环，否则返回当前结果。</li>
</ol>
<p>依旧是给出 <a href="https://jsfiddle.net/XadillaX/5rx7vdzL/" rel="nofollow noreferrer" target="_blank">JSFiddle 的预览</a><button class="btn btn-xs btn-default ml10 preview" data-url="XadillaX/5rx7vdzL/" data-typeid="0">点击预览</button>。</p>
<p>或者也可以直接看效果图：</p>
<table><thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167857?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167857?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167858?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167858?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167859?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167859?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167860?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167860?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
</tr></thead></table>
<p>50x50 填充 800 丧病区域</p>
<table><thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167861?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167861?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167862?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167862?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167863?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167863?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167864?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167864?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
</tr></thead></table>
<p>50x50 填充 800 丧病区域</p>
<blockquote>
<strong>注意</strong>：这里只给出思路，具体配比和详细流程大家可以继续优化。</blockquote>
<h2 id="articleHeader7">几张效果对比图</h2>
<p>最后，这里给出几张 10x10 填 50 的效果图放一起对比一下。</p>
<table>
<thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167865?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167865?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167866?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167866?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167867?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167867?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167868?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167868?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167869?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167869?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167870?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167870?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167871?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014167871?w=160&amp;h=160" alt="" title="" style="cursor: pointer;"></span></th>
</tr></thead>
<tbody><tr>
<td>DFS</td>
<td>周期性 DFS</td>
<td>非还原 DFS</td>
<td>非还原周期性 DFS</td>
<td>胖胖的</td>
<td>结合</td>
<td>更丧病</td>
</tr></tbody>
</table>
<p>以及，几张 50x50 填充 800 面积的效果图对比。</p>
<table>
<thead><tr>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167872?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167872?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167872?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167872?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167873?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167873?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167874?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167874?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167875?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167875?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167876?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167876?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th><span class="img-wrap"><img data-src="/img/remote/1460000014167877?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014167877?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
</tr></thead>
<tbody><tr>
<td>DFS</td>
<td>周期性 DFS</td>
<td>非还原 DFS</td>
<td>非还原周期性 DFS</td>
<td>胖胖的</td>
<td>结合</td>
<td>更丧病</td>
</tr></tbody>
</table>
<h2 id="articleHeader8">我错了之『真·单连通区域』</h2>
<p><strong>之所以多出一节来，是因为我在写回答以及这篇文章的时候脑抽了一下，迷迷糊糊想成了连通区域，感谢评论区童鞋的提醒。实际上单连通区域要稍微复杂一些。</strong></p>
<blockquote>在拓扑学中，单连通是拓扑空间的一种性质。直观地说，单连通空间中所有闭曲线都能连续地搜索至一点。此性质可以由空间的基本群刻画。<p><span class="img-wrap"><img data-src="/img/remote/1460000014308443?w=440&amp;h=330" src="https://static.alili.tech/img/remote/1460000014308443?w=440&amp;h=330" alt="连通区域" title="连通区域" style="cursor: pointer;"></span></p>
<p>&lt;center&gt;这个空间不是单连通的，它有三个洞&lt;/center&gt;</p>
<p>——<a href="https://zh.wikipedia.org/wiki/%E5%96%AE%E9%80%A3%E9%80%9A" rel="nofollow noreferrer" target="_blank">单连通@Wikipedia</a></p>
</blockquote>
<p><strong>对于非周期性的区域来说</strong>，生成一个单连通区域只要在上面的方法里面加点料就可以了。即在一个位置填充的时候，判断一下将它填充进去之后是否会出现所谓的「洞」。而这一点在非周期性区域中，由于在填充当前坐标前，已存在的区域已经是一个单连通区域，所以枚举一下几种情况即可排除非单连通区域的情况：</p>
<ol>
<li>新加的坐标其上下都有填充，但其左右为空；或者左右都有填充，但其上下为空；</li>
<li>新加的坐标只有一面相邻有填充，但该面对面的边所对应的两个角对过去至少有一个角与其它坐标共享顶点；</li>
<li>新加的坐标同一个顶点的两条边有接壤，且其对角顶点对过去的坐标与其共享顶点。</li>
</ol>
<blockquote>而对于周期性的区域来说，暂时我还没想到很好的办法。</blockquote>
<p>对于情况一而言，如果处于对面的两接壤坐标都有填充，且再多一个接壤面的话，原小区域内只有可能是「<strong>匚</strong>」型，那么填充进去只会形成一个 2x3 的实心区域，而如果只有处于对面的两个接壤坐标有填充的话，说明原小区域有两个面对面隔空的区域，它们形成单连通区域的大前提就是从其它地方绕出去将它们连起来，若这个时候将它们闭合的话，势必会形成一个空洞，如下图所示：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014308444?w=228&amp;h=208" src="https://static.alili.tech/img/remote/1460000014308444?w=228&amp;h=208" alt="情况一" title="情况一" style="cursor: pointer; display: inline;"></span></p>
<p>对于情况二而言，如果只有一面有填充，但是对面的顶点有共享的话，可以类比为情况一，举例如下：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014308445?w=212&amp;h=257" src="https://static.alili.tech/img/remote/1460000014308445?w=212&amp;h=257" alt="情况二" title="情况二" style="cursor: pointer; display: inline;"></span></p>
<p>对于情况三而言，其实就是情况二加一条边有填充，如果在情况二的情况下，在上图“原”的区域下方的空若已有填充，那么在“新”的位置填充进去，就形不成空洞了。毕竟如果“空”的位置已有填充的话，若先前状态生成没有洞的连通区域，则“空”下方也必定不是一个空洞的区域。</p>
<p>在解析完三种情况后，算法就明朗起来——在上面的 DFS 算法每次执行填充操作的时候，都判断一下当前填充是否符合刚才列举的三种情况，若符合，则不填充该点。</p>
<p>所以只需对 DFS 的那个代码做一下修改就好了，首先把状态还原两行代码删掉，然后在之前</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="if (newX < 0 || newX >= this.length || newY < 0 || newY >= this.length) continue;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript" style="word-break: break-word; white-space: initial;"><span class="hljs-keyword">if</span> (newX &lt; <span class="hljs-number">0</span> || newX &gt;= <span class="hljs-keyword">this</span>.length || newY &lt; <span class="hljs-number">0</span> || newY &gt;= <span class="hljs-keyword">this</span>.length) <span class="hljs-keyword">continue</span>;</code></pre>
<p>这句代码之下加一个条件判断就好了：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="if(this.willBreak(newX, newY)) {
    continue;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.willBreak(newX, newY)) {
    <span class="hljs-keyword">continue</span>;
}</code></pre>
<p>剩下的就是去实现 <code>this.willBreak()</code> 函数：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="class Filler {
    ...
    
    willBreak(x, y) {
        // 九宫格除自己以外的其它格状态
        let u = false, d = false, l = false, r = false;
        let lu = false, ld = false, ru = false, rd = false;
        if(x - 1 >= 0 &amp;&amp; this.map[x - 1][y] === 'x') u = true;
        if(x + 1 < this.length &amp;&amp; this.map[x + 1][y] === 'x') d = true;
        if(y - 1 >= 0 &amp;&amp; this.map[x][y - 1] === 'x') l = true;
        if(y + 1 < this.length &amp;&amp; this.map[x][y + 1] === 'x') r = true;
        if(x - 1 >= 0 &amp;&amp; y - 1 >= 0 &amp;&amp; this.map[x - 1][y - 1] === 'x') lu = true;
        if(x - 1 >= 0 &amp;&amp; y + 1 < this.length &amp;&amp; this.map[x - 1][y + 1] === 'x') ru = true;
        if(x + 1 < this.length &amp;&amp; y - 1 >= 0 &amp;&amp; this.map[x + 1][y - 1] === 'x') ld = true;
        if(x + 1 < this.length &amp;&amp; y + 1 < this.length &amp;&amp; this.map[x + 1][y + 1] === 'x') rd = true;
        
        // 情况 1
        if((l &amp; r) ^ (u &amp; d)) return true;
        
        // 情况 2
        if(l + r + u + d === 1) {
            if(l &amp;&amp; (ru || rd)) return true;
            if(r &amp;&amp; (lu || ld)) return true;
            if(u &amp;&amp; (ld || rd)) return true;
            if(d &amp;&amp; (lu || ru)) return true;
        }
        
        // 情况 3
        if(l + r + u + d === 2) {
            // 情况 1 已经被 return 了，所以相加为 2 的肯定是共享顶点
            if(l &amp;&amp; u &amp;&amp; rd) return true;
            if(l &amp;&amp; d &amp;&amp; ru) return true;
            if(r &amp;&amp; u &amp;&amp; ld) return true;
            if(r &amp;&amp; d &amp;&amp; lu) return true;
        }
        
        return false;
    }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Filler</span> </span>{
    ...
    
    willBreak(x, y) {
        <span class="hljs-comment">// 九宫格除自己以外的其它格状态</span>
        <span class="hljs-keyword">let</span> u = <span class="hljs-literal">false</span>, d = <span class="hljs-literal">false</span>, l = <span class="hljs-literal">false</span>, r = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> lu = <span class="hljs-literal">false</span>, ld = <span class="hljs-literal">false</span>, ru = <span class="hljs-literal">false</span>, rd = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span>(x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.map[x - <span class="hljs-number">1</span>][y] === <span class="hljs-string">'x'</span>) u = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(x + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">this</span>.length &amp;&amp; <span class="hljs-keyword">this</span>.map[x + <span class="hljs-number">1</span>][y] === <span class="hljs-string">'x'</span>) d = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(y - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.map[x][y - <span class="hljs-number">1</span>] === <span class="hljs-string">'x'</span>) l = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(y + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">this</span>.length &amp;&amp; <span class="hljs-keyword">this</span>.map[x][y + <span class="hljs-number">1</span>] === <span class="hljs-string">'x'</span>) r = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; y - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.map[x - <span class="hljs-number">1</span>][y - <span class="hljs-number">1</span>] === <span class="hljs-string">'x'</span>) lu = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; y + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">this</span>.length &amp;&amp; <span class="hljs-keyword">this</span>.map[x - <span class="hljs-number">1</span>][y + <span class="hljs-number">1</span>] === <span class="hljs-string">'x'</span>) ru = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(x + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">this</span>.length &amp;&amp; y - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.map[x + <span class="hljs-number">1</span>][y - <span class="hljs-number">1</span>] === <span class="hljs-string">'x'</span>) ld = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(x + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">this</span>.length &amp;&amp; y + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">this</span>.length &amp;&amp; <span class="hljs-keyword">this</span>.map[x + <span class="hljs-number">1</span>][y + <span class="hljs-number">1</span>] === <span class="hljs-string">'x'</span>) rd = <span class="hljs-literal">true</span>;
        
        <span class="hljs-comment">// 情况 1</span>
        <span class="hljs-keyword">if</span>((l &amp; r) ^ (u &amp; d)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        
        <span class="hljs-comment">// 情况 2</span>
        <span class="hljs-keyword">if</span>(l + r + u + d === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span>(l &amp;&amp; (ru || rd)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(r &amp;&amp; (lu || ld)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(u &amp;&amp; (ld || rd)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(d &amp;&amp; (lu || ru)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        
        <span class="hljs-comment">// 情况 3</span>
        <span class="hljs-keyword">if</span>(l + r + u + d === <span class="hljs-number">2</span>) {
            <span class="hljs-comment">// 情况 1 已经被 return 了，所以相加为 2 的肯定是共享顶点</span>
            <span class="hljs-keyword">if</span>(l &amp;&amp; u &amp;&amp; rd) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(l &amp;&amp; d &amp;&amp; ru) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(r &amp;&amp; u &amp;&amp; ld) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(r &amp;&amp; d &amp;&amp; lu) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}</code></pre>
<blockquote>进 <a href="https://jsfiddle.net/XadillaX/yxjmdvh7/" rel="nofollow noreferrer" target="_blank">JSFiddle</a><button class="btn btn-xs btn-default ml10 preview" data-url="XadillaX/yxjmdvh7/" data-typeid="0">点击预览</button> 看完整代码。</blockquote>
<p>然后是 50x50 填充 800 的效果：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014308446?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014308446?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></p>
<p>以及 10x10 填充 50：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014308447?w=160&amp;h=160" src="https://static.alili.tech/img/remote/1460000014308447?w=160&amp;h=160" alt="" title="" style="cursor: pointer; display: inline;"></span></p>
<blockquote>
<strong>注意：</strong>左下角的洞看起来是洞，实际上是处于边界了，而填充区域无法与边界合成闭合区域，实际上将地图往外想想空一格就可以知道它并不是一个洞了。当然如果读者执意不允许这种情况发生，那么只需要在 <code>willBreak()</code> 函数判断的时候做点手脚就可以了，至于怎么做手脚大家自己想吧。</blockquote>
<p>这种情况生成的地图比较像迷宫，哪怕是针对「胖胖的区域」做这个改进，<a href="https://jsfiddle.net/XadillaX/qswaevtL/" rel="nofollow noreferrer" target="_blank">JSFiddle</a><button class="btn btn-xs btn-default ml10 preview" data-url="XadillaX/qswaevtL/" data-typeid="0">点击预览</button> 出来的也是下面的效果：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014308448?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014308448?w=800&amp;h=800" alt="" title="" style="cursor: pointer; display: inline;"></span></p>
<p>所以呢，继续优化——我们知道有三种情况是会生成非单连通区域的，所以当我们探测到这种情况的时候，去 BFS 它内外区域，看看究竟是哪个区域被封闭出一个空洞来，探测出来之后再看看我们目前还需要填充的区域面积跟这个空洞的面积是否够用，若够用则将空洞补起来，不够用则当前一步重新来过——即再随机一个坐标看看行不行。</p>
<p>思想说出来了，具体的实现还是看看我写在 <a href="https://jsfiddle.net/XadillaX/2mkce52a/" rel="nofollow noreferrer" target="_blank">JSFiddle</a><button class="btn btn-xs btn-default ml10 preview" data-url="XadillaX/2mkce52a/" data-typeid="0">点击预览</button> 里面的代码吧。</p>
<p>50x50 填充 800 的效果如下：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000014308449?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014308449?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></p>
<p>这么一来，我们很容易能跟 DFS 的算法结合起来，即之前说过的更丧病的算法。结合方法很简单，分别把改进过的 DFS 和胖胖区域的算法一起融合进之前丧病算法的代码中就好了。老样子我还是把代码更新到了 <a href="https://jsfiddle.net/XadillaX/5rx7vdzL/" rel="nofollow noreferrer" target="_blank">JSFiddle</a><button class="btn btn-xs btn-default ml10 preview" data-url="XadillaX/5rx7vdzL/" data-typeid="0">点击预览</button> 里面。大家看看 50x50 填充 800 的效果吧：</p>
<table><thead><tr>
<th align="center"><span class="img-wrap"><img data-src="/img/remote/1460000014308450?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014308450?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th align="center"><span class="img-wrap"><img data-src="/img/remote/1460000014308451?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014308451?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th align="center"><span class="img-wrap"><img data-src="/img/remote/1460000014308452?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014308452?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
<th align="center"><span class="img-wrap"><img data-src="/img/remote/1460000014308453?w=800&amp;h=800" src="https://static.alili.tech/img/remote/1460000014308453?w=800&amp;h=800" alt="" title="" style="cursor: pointer;"></span></th>
</tr></thead></table>
<p>最后，由于一开始文章写的概念性错误给大家带来的不变表示非常抱歉，好在最后我还是补全了一下文章。</p>
<h2 id="articleHeader9">小结</h2>
<p>本文主要还是讲了，如何随机生成一个指定面积的单连通区域。从一开始拍脑袋就能想到 DFS 开始，延伸到胖胖的区域，然后从个人认为「图不好看」开始，想办法如何结合一下两种算法使其变得更自然。</p>
<p>针对同一件事的算法们并非一成不变或者不可结合的。不是说该 DFS 就只能 DFS，该 <code>for</code> 就只能 <code>for</code>，稍微结合一下也许食用效果更佳哦。</p>
<p>哦对了，在这之前还有一个例子就是我在三年多前写的主题色提取的文章《<a href="https://xcoder.in/2014/09/17/theme-color-extract/#%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84" rel="nofollow noreferrer" target="_blank">图片主题色提取算法小结</a>》，其中就讲到我最后的方法就是结合了八叉树算法和最小差值法，使其在提取比较贴近的颜色同时又能够规范化提取出来的颜色。</p>
<p>总之就是多想想，与诸君共勉。</p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
随机生成指定面积单连通区域

## 原文链接
[https://segmentfault.com/a/1190000014167823](https://segmentfault.com/a/1190000014167823)

