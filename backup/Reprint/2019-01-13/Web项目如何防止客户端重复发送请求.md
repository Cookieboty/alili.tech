---
title: 'Web项目如何防止客户端重复发送请求' 
date: 2019-01-13 2:30:11
hidden: true
slug: uq53s5fh9cg
categories: [reprint]
---

{{< raw >}}

                    
<p>在Web项目中，有一些请求或操作会对数据产生影响（比如新增、删除、更新），针对这类请求一般都需要做一些保护，以防止用户有意或无意的重复发起这样的请求导致的数据错乱。</p>
<p>本文总结了一些防止客户端重复发送请求的方法。</p>
<h2 id="articleHeader0">方法一：JS监听Form的onsubmit事件</h2>
<p>在经典场景下，浏览器通过Form发送请求。因此只需要在Form onsubmit时将Submit按钮disable，就能够防止用户双击导致的重复请求（这种问题一般发生在年纪大的用户身上，他们分不清单击和双击）。</p>
<p>但是随着前端的发展，Form以外的请求方式也越来越多，比如利用各种前端框架（Vue、AngularJs、Backbone等）写的App，他们更多的采用的是ajax的方式和后端交互。那么前端开发人员必须在开发时针对每个代表<strong>发起请求</strong>的UI元素做处理，像Form一样，在发起请求的时候把相关UI元素<strong>禁用</strong>掉。</p>
<p>而有些交互方式则可能连代表<strong>发起请求</strong>的UI元素都没有，比如Segmentfault的markdown编辑器就是在一边输入的时候一边保存的。那么这时就需要前端代码采用其他手段来控制重复请求的发生。</p>
<p><strong>优点：</strong></p>
<ol><li>不需要后端写代码</li></ol>
<p><strong>缺点：</strong></p>
<ol>
<li>不存在统一的解决方案，必须针对每种情况写处理代码</li>
<li>无法控制浏览器刷新发起的重复请求</li>
<li>前端开发人员忘记写相关代码</li>
<li>无法控制恶意的重复请求，比如绕过浏览器直接发起</li>
</ol>
<h2 id="articleHeader1">方法二：Http Status Code 302（后端重定向）</h2>
<p>服务端采用重定向的方式，防止用户刷新浏览器发出重复请求。这是比较经典的后端控制重复请求的方式，因为一旦<strong>重定向成功</strong>后，用户刷新浏览器所刷新的是那个重定向地址，而不是数据操作地址。</p>
<p><strong>优点：</strong></p>
<ol><li>不需要写前端代码</li></ol>
<p><strong>缺点：</strong></p>
<ol>
<li>在还未响应302之前，所发起的重复请求，比如：用户快速的双击、刷新浏览器</li>
<li>在某些前端程序里（比如SPA），不能使用重定向</li>
<li>后端开发人员忘记写相关代码</li>
<li>无法控制恶意的重复请求，比如绕过浏览器直接发起</li>
</ol>
<h2 id="articleHeader2">方法三：结合方法一和方法二</h2>
<p>结合方法一和方法二的话倒是可以解决大部分问题，但是解决不了以下问题：</p>
<ol>
<li>在还未响应302之前，用户刷新浏览器导致的重复请求</li>
<li>有些场景下压根不能使用重定向</li>
<li>前、后端开发人员忘记写相关代码</li>
<li>无法控制恶意的重复请求，比如绕过浏览器直接发起</li>
</ol>
<h2 id="articleHeader3">方法四：token方式</h2>
<p>token的流程是这样的：</p>
<ol>
<li>在浏览器发送请求前，先到服务端索要token</li>
<li>浏览器发送请求时，将token一并提交</li>
<li>服务端检查请求是否携带token、token是否有效（比如是否正确、是否过期）。如果不正确则响应失败；如果正确则销毁token，继续业务逻辑。</li>
</ol>
<p>关键点在于：</p>
<ol>
<li>每个token都是一次性且有过期时间的，能够防止token前端代码bug造成的重复利用和无限利用。</li>
<li>服务器要求请求必须携带token，能够避免前端开发人员漏写相关代码。</li>
</ol>
<p>那么token是以怎样的形式传输的呢？我认为有以下两种方式：</p>
<p><strong>Cookie</strong>：</p>
<p>推荐使用这种方式，因为浏览器每次都会将cookie携带在请求里一并发出，所以前端发送请求的代码都不需要修改，只要在发送请求前问服务器拿token就行了。</p>
<p>比如在进入Form页面时，服务器将token以cookie的形式一并携带在响应中，那么前端Form提交时，就会将cookie一并携带在请求中，前端的代码一点都不需要修改。</p>
<p><strong>json</strong>：</p>
<p>前端发起ajax请求像后端拿token，后端以json的形式返回token，前端发送请求时将token携带在请求中，后端检验。</p>
<p>这种方式比Cookie稍微麻烦的地方是，前端必须写一些代码来保存这个token，然后在发送请求的地方要写一些代码把token携带在请求里。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>前端代码可以写的少一些，比如禁用UI元素的代码可以不写</li>
<li>能够解决在还未响应302之前，用户刷新浏览器导致的重复请求</li>
<li>适应有些场景下压根不能使用重定向</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>前、后端开发人员忘记写相关代码。这个真的解决不了。</li>
<li>无法控制通过脚本运行的，具有整套流程的恶意请求。这种请求在程序看来完全合法，但却属于恶意行为，针对这类恶意行为的防控属于另一个话题，本人不懂，所以在这里就不多讲了。</li>
</ol>
<h2 id="articleHeader4">方法五：利用数据库的唯一约束</h2>
<p>如果请求会insert数据，而这个数据正好存在业务主键，那么可以利用数据库的唯一约束来做进一步的防御。</p>
<h2 id="articleHeader5">方法六：请求幂等化</h2>
<p>有些业务情形下，请求是幂等的，这就意味着可以不用为重复发生请求而烦恼了——至少在业务逻辑层面不用烦恼了。</p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
Web项目如何防止客户端重复发送请求

## 原文链接
[https://segmentfault.com/a/1190000009717705](https://segmentfault.com/a/1190000009717705)

