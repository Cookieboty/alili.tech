---
title: 'D3 源代码解构' 
date: 2019-02-07 2:30:16
hidden: true
slug: qedetadudk
categories: [reprint]
---

{{< raw >}}

                    
<blockquote><p>D3是一个数据可视化的javascript库，相对于highchart和echarts专注图表可视化的库，D3更适合做大数据处理的可视化，它只提供基础的可视化功能，灵活而丰富的接口让我们能开发出各式各样的图表。</p></blockquote>
<p>D3代码版本：“3.5.17”</p>
<p>D3的代码骨架比较简洁，相比jquery来说更适合阅读，你可以很舒服地自上而下的看下去而不用看到一个新的函数发现声明在千里之外，然后在代码中跳来跳去。</p>
<h2 id="articleHeader0">内部代码流水线</h2>
<ul>
<li><p>基本的数学计算：最小最大、均值中值方差、偏分值……</p></li>
<li><p>各种集合类型： map、set、nest……</p></li>
<li><p>集合的操作、方法： text、html、append、insert、remove</p></li>
<li><p>d3的dragging</p></li>
<li><p>图形操作</p></li>
<li><p>……</p></li>
</ul>
<h2 id="articleHeader1">自执行匿名函数</h2>
<p>首先是典型的自执行匿名函数，对外提供接口，隐藏实现方式，实现私有变量等等功能。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="!function() {
   // code here
}()" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="bash hljs"><code class="bash">!<span class="hljs-function"><span class="hljs-title">function</span></span>() {
   // code here
}()</code></pre>
<p>这里用到的是感叹号，其实和使用括号是一样的作用，就是将函数声明变成函数表达式，以便于函数的自执行调用，你可以试试</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function() {
  console.log('no console')
}()" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="bash hljs"><code class="bash"><span class="hljs-function"><span class="hljs-title">function</span></span>() {
  console.log(<span class="hljs-string">'no console'</span>)
}()</code></pre>
<p>这是因为JS禁止函数声明和函数调用混用，而括号、逻辑运算符（+、-、&amp;&amp;、||）、逗号、new等都可以将函数声明变成函数表达式，然后便可以自执行。有人做过调查关于这些转化的方法哪个更快，可以查看这篇<a href="http://blog.sina.com.cn/s/blog_775f158f01016j12.html" rel="nofollow noreferrer" target="_blank">博客</a>，大概new是最慢的，相比使用括号是基本最快，感叹号反而性能一般，所以其实用哪个都没什么区别，当然如果你想省敲一个符号也是可以用感叹号的。</p>
<h2 id="articleHeader2">对外暴露私有变量d3</h2>
<p>对于d3，采用的是创建私有变量对象，然后对它进行扩展，最后对外暴露</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var d3 = {
  version: '3.5.17'
};

// code here
//...

if (typeof define === 'function' &amp;&amp; defind.amd) 
  this.d3 = d3, define(d3);
else if (typeof module == 'object' &amp;&amp; module.exports)
  module.exports = d3;
else
  this.d3 = d3;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> d3 = {
  <span class="hljs-attr">version</span>: <span class="hljs-string">'3.5.17'</span>
};

<span class="hljs-comment">// code here</span>
<span class="hljs-comment">//...</span>

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; defind.amd) 
  <span class="hljs-keyword">this</span>.d3 = d3, define(d3);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> == <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-built_in">module</span>.exports)
  <span class="hljs-built_in">module</span>.exports = d3;
<span class="hljs-keyword">else</span>
  <span class="hljs-keyword">this</span>.d3 = d3;</code></pre>
<p>第一种为异步模块加载模式，第二种为同步模块加载或者是ecma6的import机制，第三种则是将d3设置为全局变量，因为匿名自执行函数中，函数的环境就是全局的，所以this == window。</p>
<h2 id="articleHeader3">创建公用方法</h2>
<p>d3的方法是属于d3对象的属性：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="d3_xhr( url, mimeType, response, callback) {
  // code 
}
d3.json = function(url, callback) {
  return d3_xhr(url, 'application/json', d3_json, callback);
};
function d3_json(request) {
  return JSON.parse(request.responseText);
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs qml"><code>d3_xhr( <span class="hljs-built_in">url</span>, mimeType, response, callback) {
  <span class="hljs-comment">// code </span>
}
d3.json = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url, callback</span>) </span>{
  <span class="hljs-keyword">return</span> d3_xhr(<span class="hljs-built_in">url</span>, <span class="hljs-string">'application/json'</span>, d3_json, callback);
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d3_json</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(request.responseText);
}</code></pre>
<p>不太好的是d3没有在命名上区分哪些是私有函数，哪些是公用函数，不过对于通过创建对象来对外暴露接口的对象来说，应该也不用去区分吧。</p>
<h2 id="articleHeader4">提取一些常用的原生函数</h2>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var d3_arraySlice = [].slice, d3_array = function(list) {
  return d3_arraySlice.call(list);
};
var d3_document = this.document;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs qml"><code><span class="hljs-built_in">var</span> d3_arraySlice = [].slice, d3_array = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>) </span>{
  <span class="hljs-keyword">return</span> d3_arraySlice.call(<span class="hljs-built_in">list</span>);
};
<span class="hljs-built_in">var</span> d3_document = <span class="hljs-keyword">this</span>.document;</code></pre>
<p>提取slice方法，使用它来生成数组的副本，slice不会对原生数组做切割，而是会返回数组的复制品，但是要注意是浅复制，对于数组中的对象、数组，是单纯的引用，所以对原数组中的对象或数组的更改还是会影响到复制品。</p>
<h2 id="articleHeader5">部分代码实现阅读</h2>
<h3 id="articleHeader6">一段用来测试d3_array的函数，但什么情况下会重写d3_array函数呢？</h3>
<p>【line15】</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="if (d3_document) {
  var test = d3_array(d3_document.documentElement.childNodes);
  console.log(test);
  try {
    d3_array(d3_document.documentElement.childNodes)[0].nodeType;
  } catch (e) {
    console.log('catch error:', e);
    d3_array = function(list) {
      var i = list.length, array = new Array(i);
      while (i--) array[i] = list[i];
      return array;
    };
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs php"><code><span class="hljs-keyword">if</span> (d3_document) {
  <span class="hljs-keyword">var</span> test = d3_array(d3_document.documentElement.childNodes);
  console.log(test);
  <span class="hljs-keyword">try</span> {
    d3_array(d3_document.documentElement.childNodes)[<span class="hljs-number">0</span>].nodeType;
  } <span class="hljs-keyword">catch</span> (e) {
    console.log(<span class="hljs-string">'catch error:'</span>, e);
    d3_array = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(list)</span> </span>{
      <span class="hljs-keyword">var</span> i = <span class="hljs-keyword">list</span>.length, <span class="hljs-keyword">array</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Array</span>(i);
      <span class="hljs-keyword">while</span> (i--) <span class="hljs-keyword">array</span>[i] = <span class="hljs-keyword">list</span>[i];
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>;
    };
  }
}</code></pre>
<p>由前面我们可以知道d3_array可以用来获取传入数组的副本，通过try来测试document的子节点的第一个子元素，一般就是header这个元素，我们通过查询<a href="http://www.w3school.com.cn/jsref/prop_node_nodetype.asp" rel="nofollow noreferrer" target="_blank">w3c</a>可以知道nodeType为1，表示html element，感觉应该是测试是否是浏览器环境，如果不是的话，就换成自己写的函数的意思吗？还是为了兼容一些少数的浏览器呢？</p>
<h4>设置对象属性的兼容？</h4>
<p>【line 30】</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="if (d3_document) {
  try {
    d3_document.createElement(&quot;DIV&quot;).style.setProperty(&quot;opacity&quot;, 0, &quot;&quot;);
  } catch (error) {
    var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_element_prototype.setAttribute = function(name, value) {
      d3_element_setAttribute.call(this, name, value + &quot;&quot;);
    };
    d3_element_prototype.setAttributeNS = function(space, local, value) {
      d3_element_setAttributeNS.call(this, space, local, value + &quot;&quot;);
    };
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + &quot;&quot;, priority);
    };
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-keyword">if</span> (d3_document) {
  <span class="hljs-keyword">try</span> {
    d3_document.createElement(<span class="hljs-string">"DIV"</span>).style.setProperty(<span class="hljs-string">"opacity"</span>, <span class="hljs-number">0</span>, <span class="hljs-string">""</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">var</span> d3_element_prototype = <span class="hljs-keyword">this</span>.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = <span class="hljs-keyword">this</span>.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_element_prototype.setAttribute = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, value)</span> </span>{
      d3_element_setAttribute.call(<span class="hljs-keyword">this</span>, name, value + <span class="hljs-string">""</span>);
    };
    d3_element_prototype.setAttributeNS = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(space, local, value)</span> </span>{
      d3_element_setAttributeNS.call(<span class="hljs-keyword">this</span>, space, local, value + <span class="hljs-string">""</span>);
    };
    d3_style_prototype.setProperty = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, value, priority)</span> </span>{
      d3_style_setProperty.call(<span class="hljs-keyword">this</span>, name, value + <span class="hljs-string">""</span>, priority);
    };
  }
}</code></pre>
<p>暂时不知道是为了跨浏览器还是跨文档而做的检测，待研究。</p>
<h3 id="articleHeader7">数组最小值函数</h3>
<p>【line 53】</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null &amp;&amp; b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null &amp;&amp; a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; a > b) a = b;
    }
    return a;
  };" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs armasm"><code>  <span class="hljs-built_in">d3</span>.min = <span class="hljs-meta">function</span>(array, f) {
    var i = -<span class="hljs-number">1</span>, n = array.length, a, <span class="hljs-keyword">b;
</span>    <span class="hljs-meta">if</span> (arguments.length === <span class="hljs-number">1</span>) {
      <span class="hljs-meta">while</span> (++i &lt; n) <span class="hljs-meta">if</span> ((<span class="hljs-keyword">b </span>= array[i]) != null &amp;&amp; <span class="hljs-keyword">b </span>&gt;= <span class="hljs-keyword">b) </span>{
        a = <span class="hljs-keyword">b;
</span>        <span class="hljs-keyword">break;
</span>      }
      <span class="hljs-meta">while</span> (++i &lt; n) <span class="hljs-meta">if</span> ((<span class="hljs-keyword">b </span>= array[i]) != null &amp;&amp; a &gt; <span class="hljs-keyword">b) </span>a = <span class="hljs-keyword">b;
</span>    } <span class="hljs-meta">else</span> {
      <span class="hljs-meta">while</span> (++i &lt; n) <span class="hljs-meta">if</span> ((<span class="hljs-keyword">b </span>= f.call(array, array[i], i)) != null &amp;&amp; <span class="hljs-keyword">b </span>&gt;= <span class="hljs-keyword">b) </span>{
        a = <span class="hljs-keyword">b;
</span>        <span class="hljs-keyword">break;
</span>      }
      <span class="hljs-meta">while</span> (++i &lt; n) <span class="hljs-meta">if</span> ((<span class="hljs-keyword">b </span>= f.call(array, array[i], i)) != null &amp;&amp; a &gt; <span class="hljs-keyword">b) </span>a = <span class="hljs-keyword">b;
</span>    }
    return a<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span></code></pre>
<p>首先获取第一个可比较的元素，测试了下，发现对于<strong>b &gt;= b</strong>，无论b是数字、字符串、数组甚至是对象都是可以比较的，那么什么情况下 b&gt;=b == false呢，对于NaN来说，无论和哪个数字比较，都是false的，但是对于Infinity却返回真，是个点。所以应该是为了排除NaN这种有问题的数字。</p>
<h3 id="articleHeader8">d3的洗牌方法</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
      console.log(i, m);
    }
    return array;
  };" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs maxima"><code>  d3.shuffle = function(<span class="hljs-built_in">array</span>, <span class="hljs-built_in">i0</span>, <span class="hljs-built_in">i1</span>) {
    <span class="hljs-keyword">if</span> ((m = arguments.<span class="hljs-built_in">length</span>) &lt; <span class="hljs-number">3</span>) {
      <span class="hljs-built_in">i1</span> = <span class="hljs-built_in">array</span>.<span class="hljs-built_in">length</span>;
      <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">2</span>) <span class="hljs-built_in">i0</span> = <span class="hljs-number">0</span>;
    }
    <span class="hljs-built_in">var</span> m = <span class="hljs-built_in">i1</span> - <span class="hljs-built_in">i0</span>, t, i;
    <span class="hljs-keyword">while</span> (m) {
      i = Math.<span class="hljs-built_in">random</span>() * m-- | <span class="hljs-number">0</span>;
      t = <span class="hljs-built_in">array</span>[m + <span class="hljs-built_in">i0</span>], <span class="hljs-built_in">array</span>[m + <span class="hljs-built_in">i0</span>] = <span class="hljs-built_in">array</span>[i + <span class="hljs-built_in">i0</span>], <span class="hljs-built_in">array</span>[i + <span class="hljs-built_in">i0</span>] = t;
      console.<span class="hljs-built_in">log</span>(i, m);
    }
    <span class="hljs-built_in">return</span> <span class="hljs-built_in">array</span>;
  };</code></pre>
<p>d3使用的<a href="https://github.com/d3/d3-array/blob/master/README.md#shuffle" rel="nofollow noreferrer" target="_blank">洗牌算法</a>,关于<a href="https://bost.ocks.org/mike/shuffle/" rel="nofollow noreferrer" target="_blank">Fisher-Yates shuffle</a>的文章可以参考一下，它的演变思路简单而优雅：</p>
<p><strong>正常的思路是</strong></p>
<ul>
<li><p>每次从原数组中随机选择一个元素，判断是否已经被选取，是的话删除并放入新的数组中，不是的话重新选择。</p></li>
<li><p>缺点：越到后面重复选择的概率越大，放入新数组的时间越长。</p></li>
</ul>
<p><strong>优化</strong></p>
<ul>
<li><p>为了防止重复，每次随机选择第m张卡牌，m为待洗牌组从原始长度n逐步递减的值</p></li>
<li><p>缺点：每次都要重新获取剩余数组中的卡牌的紧凑数组，实际的效率为n2</p></li>
</ul>
<p><strong>再次优化</strong></p>
<ul><li><p>就地随机洗牌，使用数组的后一部分作为存储新的洗牌后的地方，前一部分为洗牌前的地方，从而将效率提升为n。</p></li></ul>
<h3 id="articleHeader9">d3.map 关于内置对象</h3>
<p>【line 291】</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = &quot;__proto__&quot;, d3_map_zero = &quot;\x00&quot;;
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs maxima"><code>  function d3_class(ctor, <span class="hljs-built_in">properties</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">properties</span>) {
      Object.defineProperty(ctor.prototype, <span class="hljs-built_in">key</span>, {
        value: <span class="hljs-built_in">properties</span>[<span class="hljs-built_in">key</span>],
        enumerable: <span class="hljs-literal">false</span>
      });
    }
  }
  d3.<span class="hljs-built_in">map</span> = function(object, f) {
    <span class="hljs-built_in">var</span> <span class="hljs-built_in">map</span> = <span class="hljs-built_in">new</span> d3_Map();
    <span class="hljs-keyword">if</span> (object instanceof d3_Map) {
      object.forEach(function(<span class="hljs-built_in">key</span>, value) {
        <span class="hljs-built_in">map</span>.set(<span class="hljs-built_in">key</span>, value);
      });
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Array.isArray(object)) {
      <span class="hljs-built_in">var</span> i = -<span class="hljs-number">1</span>, n = object.<span class="hljs-built_in">length</span>, o;
      <span class="hljs-keyword">if</span> (arguments.<span class="hljs-built_in">length</span> === <span class="hljs-number">1</span>) <span class="hljs-keyword">while</span> (++i &lt; n) <span class="hljs-built_in">map</span>.set(i, object[i]); <span class="hljs-keyword">else</span> <span class="hljs-keyword">while</span> (++i &lt; n) <span class="hljs-built_in">map</span>.set(f.call(object, o = object[i], i), o);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> object) <span class="hljs-built_in">map</span>.set(<span class="hljs-built_in">key</span>, object[<span class="hljs-built_in">key</span>]);
    }
    <span class="hljs-built_in">return</span> <span class="hljs-built_in">map</span>;
  };
  function d3_Map() {
    this.<span class="hljs-symbol">_</span> = Object.create(null);
  }
  <span class="hljs-built_in">var</span> d3_map_proto = <span class="hljs-string">"__proto__"</span>, d3_map_zero = <span class="hljs-string">"\x00"</span>;
  d3_class(d3_Map, {
    has: d3_map_has,
    <span class="hljs-built_in">get</span>: function(<span class="hljs-built_in">key</span>) {
      <span class="hljs-built_in">return</span> this.<span class="hljs-symbol">_</span>[d3_map_escape(<span class="hljs-built_in">key</span>)];
    },
    set: function(<span class="hljs-built_in">key</span>, value) {
      <span class="hljs-built_in">return</span> this.<span class="hljs-symbol">_</span>[d3_map_escape(<span class="hljs-built_in">key</span>)] = value;
    },
    <span class="hljs-built_in">remove</span>: d3_map_remove,
    keys: d3_map_keys,
    <span class="hljs-built_in">values</span>: function() {
      <span class="hljs-built_in">var</span> <span class="hljs-built_in">values</span> = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> this.<span class="hljs-symbol">_</span>) <span class="hljs-built_in">values</span>.<span class="hljs-built_in">push</span>(this.<span class="hljs-symbol">_</span>[<span class="hljs-built_in">key</span>]);
      <span class="hljs-built_in">return</span> <span class="hljs-built_in">values</span>;
    },
    entries: function() {
      <span class="hljs-built_in">var</span> entries = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> this.<span class="hljs-symbol">_</span>) entries.<span class="hljs-built_in">push</span>({
        <span class="hljs-built_in">key</span>: d3_map_unescape(<span class="hljs-built_in">key</span>),
        value: this.<span class="hljs-symbol">_</span>[<span class="hljs-built_in">key</span>]
      });
      <span class="hljs-built_in">return</span> entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> this.<span class="hljs-symbol">_</span>) f.call(this, d3_map_unescape(<span class="hljs-built_in">key</span>), this.<span class="hljs-symbol">_</span>[<span class="hljs-built_in">key</span>]);
    }
  });</code></pre>
<p><strong> 关于enumerable</strong></p>
<p>在这里，使用d3_Map来作为对象的构造函数，d3_class来封装类，这里调用了Object.defineProperty来设置属性和值，这里有一个enumerable: false的属性，它将该属性的可枚举性设置为false，使得该属性在一般的遍历中（for...in...)等中无法被获取，但是还是可以通过obj.key直接获取到，如果需要获取对象自身的所有属性，不管enumerable的值，可以使用 Object.getOwnPropertyNames 方法。</p>
<p>为什么要设置这个属性呢？我们可以看到对d3_Map构造对象时，引入了一些原生内置的方法，其中有一个叫做empty的方法用来判断后来设置的属性是否为空，我们来看看这个函数的实现：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d3_map_empty</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }</code></pre>
<p>看完之后再结合上面提到的enumerable设置为false的属性在for循环中会被忽略，这样的话就不用再写额外地条件去判断是否为内置属性，很棒的实现方式。</p>
<h3 id="articleHeader10">数据绑定函数data</h3>
<p>还记得D3独特的将数据和图形领域联系起来的方式吗？<code>进入(enter)--更新(update)--退出(exit)</code> 模式。</p>
<p>【line 832】</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="d3.selectAll('div')
  .data(dataSet)
  .enter()
  .append('div')
  ;
d3.selectAll('div')
  .data(data)
  .style('width', function(d) {
     return d + 'px';
  })
 ;
d3.selectAll('div')
  .data(newDataSet)
  .exit()
  .remove()
  ;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs awk"><code>d3.selectAll(<span class="hljs-string">'div'</span>)
  .data(dataSet)
  .enter()
  .append(<span class="hljs-string">'div'</span>)
  ;
d3.selectAll(<span class="hljs-string">'div'</span>)
  .data(data)
  .style(<span class="hljs-string">'width'</span>, <span class="hljs-keyword">function</span>(d) {
     return d + <span class="hljs-string">'px'</span>;
  })
 ;
d3.selectAll(<span class="hljs-string">'div'</span>)
  .data(newDataSet)
  .<span class="hljs-keyword">exit</span>()
  .remove()
  ;</code></pre>
<p>这里涉及到了三个函数，data、enter、exit，每次进行操作前我们需要先调用data对数据进行绑定，然后再调用enter或者exit对图形领域进行操作，那么内部实现原理是怎么样的呢，看完下面这段代码就恍然大悟了：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues &amp;&amp; nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === &quot;function&quot;) {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs cs"><code>  d3_selectionPrototype.data = function(<span class="hljs-keyword">value</span>, key) {
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">-1</span>, n = <span class="hljs-keyword">this</span>.length, <span class="hljs-keyword">group</span>, node;
    <span class="hljs-keyword">if</span> (!arguments.length) {
      <span class="hljs-keyword">value</span> = <span class="hljs-keyword">new</span> Array(n = (<span class="hljs-keyword">group</span> = <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>]).length);
      <span class="hljs-keyword">while</span> (++i &lt; n) {
        <span class="hljs-keyword">if</span> (node = <span class="hljs-keyword">group</span>[i]) {
          <span class="hljs-keyword">value</span>[i] = node.__data__;
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;
    }
    <span class="hljs-function">function <span class="hljs-title">bind</span>(<span class="hljs-params"><span class="hljs-keyword">group</span>, groupData</span>) </span>{
      <span class="hljs-keyword">var</span> i, n = <span class="hljs-keyword">group</span>.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = <span class="hljs-keyword">new</span> Array(m), enterNodes = <span class="hljs-keyword">new</span> Array(m), exitNodes = <span class="hljs-keyword">new</span> Array(n), node, nodeData;
      <span class="hljs-keyword">if</span> (key) {
        <span class="hljs-keyword">var</span> nodeByKeyValue = <span class="hljs-keyword">new</span> d3_Map(), keyValues = <span class="hljs-keyword">new</span> Array(n), keyValue;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">-1</span>; ++i &lt; n; ) {
          <span class="hljs-keyword">if</span> (node = <span class="hljs-keyword">group</span>[i]) {
            <span class="hljs-keyword">if</span> (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } <span class="hljs-keyword">else</span> {
              nodeByKeyValue.<span class="hljs-keyword">set</span>(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">-1</span>; ++i &lt; m; ) {
          <span class="hljs-keyword">if</span> (!(node = nodeByKeyValue.<span class="hljs-keyword">get</span>(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> (<span class="hljs-params">node !== <span class="hljs-literal">true</span></span>) </span>{
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.<span class="hljs-keyword">set</span>(keyValue, <span class="hljs-literal">true</span>);
        }
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">-1</span>; ++i &lt; n; ) {
          <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> keyValues &amp;&amp; nodeByKeyValue.<span class="hljs-keyword">get</span>(keyValues[i]) !== <span class="hljs-literal">true</span>) {
            exitNodes[i] = <span class="hljs-keyword">group</span>[i];
          }
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">-1</span>; ++i &lt; n0; ) {
          node = <span class="hljs-keyword">group</span>[i];
          nodeData = groupData[i];
          <span class="hljs-keyword">if</span> (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } <span class="hljs-keyword">else</span> {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        <span class="hljs-keyword">for</span> (;i &lt; m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        <span class="hljs-keyword">for</span> (;i &lt; n; ++i) {
          exitNodes[i] = <span class="hljs-keyword">group</span>[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = <span class="hljs-keyword">group</span>.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    <span class="hljs-keyword">var</span> enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">value</span> === <span class="hljs-string">"function"</span>) {
      <span class="hljs-keyword">while</span> (++i &lt; n) {
        bind(<span class="hljs-keyword">group</span> = <span class="hljs-keyword">this</span>[i], <span class="hljs-keyword">value</span>.call(<span class="hljs-keyword">group</span>, <span class="hljs-keyword">group</span>.parentNode.__data__, i));
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">while</span> (++i &lt; n) {
        bind(<span class="hljs-keyword">group</span> = <span class="hljs-keyword">this</span>[i], <span class="hljs-keyword">value</span>);
      }
    }
    update.enter = function() {
      <span class="hljs-keyword">return</span> enter;
    };
    update.exit = function() {
      <span class="hljs-keyword">return</span> exit;
    };
    <span class="hljs-keyword">return</span> update;
  };</code></pre>
<p>数据绑定函数data最终返回了变量update，这个变量update一开始为一个空集合，它拥有d3的集合操作方法，然后data函数通过调用bind函数对传入的参数进行逐项绑定，获得update集合作为本身，以及enter集合和exit集合，最后在update上绑定了函数enter和exit，使得用户在调用data后，可以再次调用enter和exit去获取另外两个集合。</p>
<h4>关于后期debug的足迹</h4>
<p>d3也会有bug的时候，这个时候需要对bug进行修复，然后再更新，为了方便下次找到修改的bug，在代码里面对其进行命名，是很好的做法：</p>
<p>【1167】</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var d3_mouse_bug44083 = this.navigator &amp;&amp; /WebKit/.test(this.navigator.userAgent) ? -1 : 0;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code style="word-break: break-word; white-space: initial;"><span class="hljs-keyword">var</span> d3_mouse_bug44083 = <span class="hljs-keyword">this</span>.navigator &amp;&amp; /WebKit/.test(<span class="hljs-keyword">this</span>.navigator.userAgent) ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>;</code></pre>
<h3 id="articleHeader11">D3的颜色空间</h3>
<p>D3支持五种颜色表示方式，除了我们常常接触了rgb、hsl外，还有lab、hcl、cubehelix，它们之间都可以转化为rgb，内部的实现方式值得参考：</p>
<p>【line 1582】</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs ada"><code>  <span class="hljs-keyword">function</span> <span class="hljs-title">d3_hsl_rgb</span>(h, s, l) {
    var m1, m2;
    h = <span class="hljs-keyword">is</span>NaN(h) ? <span class="hljs-number">0</span> : (<span class="hljs-type">h</span> %= <span class="hljs-number">360</span>) &lt; <span class="hljs-number">0</span> ? h + <span class="hljs-number">360</span> : <span class="hljs-type">h</span>;
    s = isNaN(s) ? <span class="hljs-number">0</span> : <span class="hljs-type">s</span> &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-type">s</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-type">s</span>;
    l = l &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-type">l</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-type">l</span>;
    m2 = l &lt;= .<span class="hljs-number">5</span> ? l * (<span class="hljs-number">1</span> + s) : <span class="hljs-type">l</span> + s - l * s;
    m1 = <span class="hljs-number">2</span> * l - m2;
    <span class="hljs-keyword">function</span> <span class="hljs-title">v</span>(h) {
      if (h &gt; 360) h -= 360; else if (h &lt; 0) h += 360;
      if (h &lt; 60) <span class="hljs-keyword">return</span> <span class="hljs-type">m1</span> + (m2 - m1) * h / <span class="hljs-number">60</span>;
      <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">180</span>) <span class="hljs-keyword">return</span> m2;
      <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">240</span>) <span class="hljs-keyword">return</span> m1 + (m2 - m1) * (<span class="hljs-number">240</span> - h) / <span class="hljs-number">60</span>;
      <span class="hljs-keyword">return</span> m1;
    }
    <span class="hljs-keyword">function</span> <span class="hljs-title">vv</span>(h) {
      <span class="hljs-keyword">return</span> <span class="hljs-type">Math.round(v(h)</span> * <span class="hljs-number">255</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> d3_rgb(vv(h + <span class="hljs-number">120</span>), vv(h), vv(h - <span class="hljs-number">120</span>));
  }</code></pre>
<h3 id="articleHeader12">关于csv、dsv、tsv存储方式</h3>
<blockquote><p>看代码的好处之一是能看到很多平时不会用到的接口，然后会主动去了解是<a href="http://www.cnblogs.com/weidagang2046/archive/2012/04/02/dsv.html" rel="nofollow noreferrer" target="_blank">干什么</a>的。</p></blockquote>
<p><strong>csv格式</strong></p>
<p>在文本数据处理和传输过程中，我们常常遇到把多个字段通过分隔符连接在一起的需求，如采用著名的CSV格式(comma-separated values)。CSV文件的每一行是一条记录（record），每一行的各个字段通过逗号','分隔。</p>
<p><strong>dsv格式</strong></p>
<p>由于逗号和双引号这两个特殊字符的存在，我们不能简单地通过字符串的split操作对CSV文件进行解析，而必须进行CSV语法分析。虽然我们可以通过库的形式进行封装，或者直接采用现成的库，但毕竟各种平台下库的丰富程度差异很大，这些库和split、join这样的简单字符串操作相比也更加复杂。为此，我们在CSV格式的基础上设计了一种DSV (double separated values)格式。DSV格式的主要设计目的就是为了简化CSV语法，生成和解析只需要replace, join, split这3个基本的字符串操作，而不需要进行语法分析。</p>
<p>DSV的语法非常简单，只包括以下两点：</p>
<ul>
<li><p>通过双竖线'||'作为字段分隔符</p></li>
<li><p>把字段值中的'|'替换为'_|'进行转义</p></li>
</ul>
<p><strong> tsv格式</strong> </p>
<p>TSV 是Tab-separated values的缩写，即制表符分隔值。</p>
<p>查询网上关于这三种格式的定义是如上所示，不过d3的<a href="https://github.com/d3/d3-dsv/blob/master/README.md#d3-dsv" rel="nofollow noreferrer" target="_blank">实现</a>不太一样，dsv是可以定义为任何一种分隔符，但是分隔符只能为长度为1的字符，csv是以半角符逗号作为分割符，tsv则是以斜杠作为分隔符。</p>
<h3 id="articleHeader13">d3.geo</h3>
<p>【line 2854】</p>
<p>geo是d3的图形处理实现，应该算是核心代码了，不过到了4.0版本被分割成依赖，并且不再有d3.geo.path了，而是改用d3.geoPath的方式去引用。</p>
<h2 id="articleHeader14">总结</h2>
<p>版本3的d3九千多行代码，版本4的d4则进行了依赖分割，如果全部依赖引入的话不压缩就要过16000行了，如果想整体去看骨架的话，版本3是比较清晰的，版本4则适合深入研究每一部分的实现，因为依赖都分割得很清晰了，并且相互独立开。</p>
<p>初步了解整个d3的骨架后，接下来可以深入到代码函数实现中去研究其中奥妙。</p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
D3 源代码解构

## 原文链接
[https://segmentfault.com/a/1190000005893218](https://segmentfault.com/a/1190000005893218)

