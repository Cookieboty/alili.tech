<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript常用八种继承方案"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript常用八种继承方案 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/183cav6qpdb/",
				"appid": "1613049289050283", 
				"title": "JavaScript常用八种继承方案 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-03-02T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/5tpnsqmgslq/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/0dlsi4qmvsvf/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f&text=JavaScript%e5%b8%b8%e7%94%a8%e5%85%ab%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f&text=JavaScript%e5%b8%b8%e7%94%a8%e5%85%ab%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f&title=JavaScript%e5%b8%b8%e7%94%a8%e5%85%ab%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f&is_video=false&description=JavaScript%e5%b8%b8%e7%94%a8%e5%85%ab%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e5%b8%b8%e7%94%a8%e5%85%ab%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f&title=JavaScript%e5%b8%b8%e7%94%a8%e5%85%ab%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f&title=JavaScript%e5%b8%b8%e7%94%a8%e5%85%ab%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f&title=JavaScript%e5%b8%b8%e7%94%a8%e5%85%ab%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f183cav6qpdb%2f&title=JavaScript%e5%b8%b8%e7%94%a8%e5%85%ab%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript常用八种继承方案</h1><div class="meta"><div class="postdate"><time datetime="2019-03-02" itemprop="datePublished">2019-03-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e更新：在常用七种继承方案的基础之上增加了ES6的类继承，所以现在变成八种啦，欢迎加高级前端进阶群一起学习（文末）。\x3c\/p\x3e\n\x3cp\x3e--- 2018.10.30\x3c\/p\x3e\n\x3ch4\x3e1、原型链继承\x3c\/h4\x3e\n\x3cp\x3e构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。\x3c\/p\x3e\n\x3cp\x3e继承的本质就是\x3cstrong\x3e复制，即重写原型对象，代之以一个新类型的实例\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function SuperType() {\n    this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function() {\n    return this.property;\n}\n\nfunction SubType() {\n    this.subproperty = false;\n}\n\n\/\/ 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype\nSubType.prototype = new SuperType(); \n\nSubType.prototype.getSubValue = function() {\n    return this.subproperty;\n}\n\nvar instance = new SubType();\nconsole.log(instance.getSuperValue()); \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuperType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.property = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\n\nSuperType.prototype.getSuperValue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.property;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSubType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subproperty = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype\x3c\/span\x3e\nSubType.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SuperType(); \n\nSubType.prototype.getSubValue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subproperty;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(instance.getSuperValue()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016891012?w=800\x26amp;h=417\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016891012?w=800\x26amp;h=417\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function SuperType(){\n  this.colors = [\x26quot;red\x26quot;, \x26quot;blue\x26quot;, \x26quot;green\x26quot;];\n}\nfunction SubType(){}\n\nSubType.prototype = new SuperType();\n\nvar instance1 = new SubType();\ninstance1.colors.push(\x26quot;black\x26quot;);\nalert(instance1.colors); \/\/\x26quot;red,blue,green,black\x26quot;\n\nvar instance2 = new SubType(); \nalert(instance2.colors); \/\/\x26quot;red,blue,green,black\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuperType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.colors = [\x3cspan class=\x22hljs-string\x22\x3e\x22red\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22green\x22\x3c\/span\x3e];\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSubType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\nSubType.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SuperType();\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType();\ninstance1.colors.push(\x3cspan class=\x22hljs-string\x22\x3e\x22black\x22\x3c\/span\x3e);\nalert(instance1.colors); \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22red,blue,green,black\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType(); \nalert(instance2.colors); \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22red,blue,green,black\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e2、借用构造函数继承\x3c\/h4\x3e\n\x3cp\x3e使用父类的构造函数来增强子类\x3cstrong\x3e实例\x3c\/strong\x3e，等同于复制父类的实例给子类（不使用原型）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function  SuperType(){\n    this.color=[\x26quot;red\x26quot;,\x26quot;green\x26quot;,\x26quot;blue\x26quot;];\n}\nfunction  SubType(){\n    \/\/继承自SuperType\n    SuperType.call(this);\n}\nvar instance1 = new SubType();\ninstance1.color.push(\x26quot;black\x26quot;);\nalert(instance1.color);\/\/\x26quot;red,green,blue,black\x26quot;\n\nvar instance2 = new SubType();\nalert(instance2.color);\/\/\x26quot;red,green,blue\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e  \x3cspan class=\x22hljs-title\x22\x3eSuperType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color=[\x3cspan class=\x22hljs-string\x22\x3e\x22red\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22green\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e];\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e  \x3cspan class=\x22hljs-title\x22\x3eSubType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/继承自SuperType\x3c\/span\x3e\n    SuperType.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType();\ninstance1.color.push(\x3cspan class=\x22hljs-string\x22\x3e\x22black\x22\x3c\/span\x3e);\nalert(instance1.color);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22red,green,blue,black\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType();\nalert(instance2.color);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22red,green,blue\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e核心代码是\x3ccode\x3eSuperType.call(this)\x3c\/code\x3e，创建子类实例时调用\x3ccode\x3eSuperType\x3c\/code\x3e构造函数，于是\x3ccode\x3eSubType\x3c\/code\x3e的每个实例都会将SuperType中的属性复制一份。\x3c\/p\x3e\n\x3cp\x3e缺点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e只能继承父类的\x3cstrong\x3e实例\x3c\/strong\x3e属性和方法，不能继承原型属性\/方法\x3c\/li\x3e\n\x3cli\x3e无法实现复用，每个子类都有父类实例函数的副本，影响性能\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e3、组合继承\x3c\/h4\x3e\n\x3cp\x3e组合上述两种方法就是组合继承。用原型链实现对\x3cstrong\x3e原型\x3c\/strong\x3e属性和方法的继承，用借用构造函数技术来实现\x3cstrong\x3e实例\x3c\/strong\x3e属性的继承。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function SuperType(name){\n  this.name = name;\n  this.colors = [\x26quot;red\x26quot;, \x26quot;blue\x26quot;, \x26quot;green\x26quot;];\n}\nSuperType.prototype.sayName = function(){\n  alert(this.name);\n};\n\nfunction SubType(name, age){\n  \/\/ 继承属性\n  \/\/ 第二次调用SuperType()\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n\/\/ 继承方法\n\/\/ 构建原型链\n\/\/ 第一次调用SuperType()\nSubType.prototype = new SuperType(); \n\/\/ 重写SubType.prototype的constructor属性，指向自己的构造函数SubType\nSubType.prototype.constructor = SubType; \nSubType.prototype.sayAge = function(){\n    alert(this.age);\n};\n\nvar instance1 = new SubType(\x26quot;Nicholas\x26quot;, 29);\ninstance1.colors.push(\x26quot;black\x26quot;);\nalert(instance1.colors); \/\/\x26quot;red,blue,green,black\x26quot;\ninstance1.sayName(); \/\/\x26quot;Nicholas\x26quot;;\ninstance1.sayAge(); \/\/29\n\nvar instance2 = new SubType(\x26quot;Greg\x26quot;, 27);\nalert(instance2.colors); \/\/\x26quot;red,blue,green\x26quot;\ninstance2.sayName(); \/\/\x26quot;Greg\x26quot;;\ninstance2.sayAge(); \/\/27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuperType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.colors = [\x3cspan class=\x22hljs-string\x22\x3e\x22red\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22green\x22\x3c\/span\x3e];\n}\nSuperType.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSubType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继承属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第二次调用SuperType()\x3c\/span\x3e\n  SuperType.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继承方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构建原型链\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一次调用SuperType()\x3c\/span\x3e\nSubType.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SuperType(); \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重写SubType.prototype的constructor属性，指向自己的构造函数SubType\x3c\/span\x3e\nSubType.prototype.constructor = SubType; \nSubType.prototype.sayAge = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age);\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType(\x3cspan class=\x22hljs-string\x22\x3e\x22Nicholas\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e29\x3c\/span\x3e);\ninstance1.colors.push(\x3cspan class=\x22hljs-string\x22\x3e\x22black\x22\x3c\/span\x3e);\nalert(instance1.colors); \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22red,blue,green,black\x22\x3c\/span\x3e\ninstance1.sayName(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22Nicholas\x22;\x3c\/span\x3e\ninstance1.sayAge(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/29\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType(\x3cspan class=\x22hljs-string\x22\x3e\x22Greg\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e);\nalert(instance2.colors); \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22red,blue,green\x22\x3c\/span\x3e\ninstance2.sayName(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22Greg\x22;\x3c\/span\x3e\ninstance2.sayAge(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016891013?w=800\x26amp;h=234\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016891013?w=800\x26amp;h=234\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e缺点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e第一次调用\x3ccode\x3eSuperType()\x3c\/code\x3e：给\x3ccode\x3eSubType.prototype\x3c\/code\x3e写入两个属性name，color。\x3c\/li\x3e\n\x3cli\x3e第二次调用\x3ccode\x3eSuperType()\x3c\/code\x3e：给\x3ccode\x3einstance1\x3c\/code\x3e写入两个属性name，color。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e实例对象\x3ccode\x3einstance1\x3c\/code\x3e上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性\/方法。\x3c\/p\x3e\n\x3ch4\x3e4、原型式继承\x3c\/h4\x3e\n\x3cp\x3e利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function object(obj){\n  function F(){}\n  F.prototype = obj;\n  return new F();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eobject\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eF\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n  F.prototype = obj;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eobject()对传入其中的对象执行了一次\x3ccode\x3e浅复制\x3c\/code\x3e，将构造函数F的原型直接指向传入的对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var person = {\n  name: \x26quot;Nicholas\x26quot;,\n  friends: [\x26quot;Shelby\x26quot;, \x26quot;Court\x26quot;, \x26quot;Van\x26quot;]\n};\n\nvar anotherPerson = object(person);\nanotherPerson.name = \x26quot;Greg\x26quot;;\nanotherPerson.friends.push(\x26quot;Rob\x26quot;);\n\nvar yetAnotherPerson = object(person);\nyetAnotherPerson.name = \x26quot;Linda\x26quot;;\nyetAnotherPerson.friends.push(\x26quot;Barbie\x26quot;);\n\nalert(person.friends);   \/\/\x26quot;Shelby,Court,Van,Rob,Barbie\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Nicholas\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3efriends\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22Shelby\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Court\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Van\x22\x3c\/span\x3e]\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e anotherPerson = object(person);\nanotherPerson.name = \x3cspan class=\x22hljs-string\x22\x3e\x22Greg\x22\x3c\/span\x3e;\nanotherPerson.friends.push(\x3cspan class=\x22hljs-string\x22\x3e\x22Rob\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e yetAnotherPerson = object(person);\nyetAnotherPerson.name = \x3cspan class=\x22hljs-string\x22\x3e\x22Linda\x22\x3c\/span\x3e;\nyetAnotherPerson.friends.push(\x3cspan class=\x22hljs-string\x22\x3e\x22Barbie\x22\x3c\/span\x3e);\n\nalert(person.friends);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22Shelby,Court,Van,Rob,Barbie\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e缺点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。\x3c\/li\x3e\n\x3cli\x3e无法传递参数\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e另外，ES5中存在\x3ccode\x3eObject.create()\x3c\/code\x3e的方法，能够代替上面的object方法。\x3c\/p\x3e\n\x3ch4\x3e5、寄生式继承\x3c\/h4\x3e\n\x3cp\x3e核心：在原型式继承的基础上，增强对象，返回构造函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createAnother(original){\n  var clone = object(original); \/\/ 通过调用 object() 函数创建一个新对象\n  clone.sayHi = function(){  \/\/ 以某种方式来增强对象\n    alert(\x26quot;hi\x26quot;);\n  };\n  return clone; \/\/ 返回这个对象\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateAnother\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoriginal\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e clone = object(original); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过调用 object() 函数创建一个新对象\x3c\/span\x3e\n  clone.sayHi = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以某种方式来增强对象\x3c\/span\x3e\n    alert(\x3cspan class=\x22hljs-string\x22\x3e\x22hi\x22\x3c\/span\x3e);\n  };\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e clone; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回这个对象\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数的主要作用是为构造函数新增属性和方法，以\x3cstrong\x3e增强函数\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var person = {\n  name: \x26quot;Nicholas\x26quot;,\n  friends: [\x26quot;Shelby\x26quot;, \x26quot;Court\x26quot;, \x26quot;Van\x26quot;]\n};\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi(); \/\/\x26quot;hi\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Nicholas\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3efriends\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22Shelby\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Court\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Van\x22\x3c\/span\x3e]\n};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e anotherPerson = createAnother(person);\nanotherPerson.sayHi(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22hi\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e缺点（同原型式继承）：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。\x3c\/li\x3e\n\x3cli\x3e无法传递参数\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e6、寄生组合式继承\x3c\/h4\x3e\n\x3cp\x3e结合借用构造函数传递参数和寄生模式实现继承\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function inheritPrototype(subType, superType){\n  var prototype = Object.create(superType.prototype); \/\/ 创建对象，创建父类原型的一个副本\n  prototype.constructor = subType;                    \/\/ 增强对象，弥补因重写原型而失去的默认的constructor 属性\n  subType.prototype = prototype;                      \/\/ 指定对象，将新创建的对象赋值给子类的原型\n}\n\n\/\/ 父类初始化实例属性和原型属性\nfunction SuperType(name){\n  this.name = name;\n  this.colors = [\x26quot;red\x26quot;, \x26quot;blue\x26quot;, \x26quot;green\x26quot;];\n}\nSuperType.prototype.sayName = function(){\n  alert(this.name);\n};\n\n\/\/ 借用构造函数传递增强子类实例属性（支持传参和避免篡改）\nfunction SubType(name, age){\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n\/\/ 将父类原型指向子类\ninheritPrototype(SubType, SuperType);\n\n\/\/ 新增子类原型属性\nSubType.prototype.sayAge = function(){\n  alert(this.age);\n}\n\nvar instance1 = new SubType(\x26quot;xyc\x26quot;, 23);\nvar instance2 = new SubType(\x26quot;lxy\x26quot;, 23);\n\ninstance1.colors.push(\x26quot;2\x26quot;); \/\/ [\x26quot;red\x26quot;, \x26quot;blue\x26quot;, \x26quot;green\x26quot;, \x26quot;2\x26quot;]\ninstance1.colors.push(\x26quot;3\x26quot;); \/\/ [\x26quot;red\x26quot;, \x26quot;blue\x26quot;, \x26quot;green\x26quot;, \x26quot;3\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einheritPrototype\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esubType, superType\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(superType.prototype); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建对象，创建父类原型的一个副本\x3c\/span\x3e\n  prototype.constructor = subType;                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 增强对象，弥补因重写原型而失去的默认的constructor 属性\x3c\/span\x3e\n  subType.prototype = prototype;                      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定对象，将新创建的对象赋值给子类的原型\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 父类初始化实例属性和原型属性\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuperType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.colors = [\x3cspan class=\x22hljs-string\x22\x3e\x22red\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22green\x22\x3c\/span\x3e];\n}\nSuperType.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 借用构造函数传递增强子类实例属性（支持传参和避免篡改）\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSubType\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age\x3c\/span\x3e)\x3c\/span\x3e{\n  SuperType.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将父类原型指向子类\x3c\/span\x3e\ninheritPrototype(SubType, SuperType);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新增子类原型属性\x3c\/span\x3e\nSubType.prototype.sayAge = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType(\x3cspan class=\x22hljs-string\x22\x3e\x22xyc\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e23\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instance2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SubType(\x3cspan class=\x22hljs-string\x22\x3e\x22lxy\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e23\x3c\/span\x3e);\n\ninstance1.colors.push(\x3cspan class=\x22hljs-string\x22\x3e\x222\x22\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22red\x22, \x22blue\x22, \x22green\x22, \x222\x22]\x3c\/span\x3e\ninstance1.colors.push(\x3cspan class=\x22hljs-string\x22\x3e\x223\x22\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22red\x22, \x22blue\x22, \x22green\x22, \x223\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016891014\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016891014\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这个例子的高效率体现在它只调用了一次\x3ccode\x3eSuperType\x3c\/code\x3e\x26nbsp;构造函数，并且因此避免了在\x3ccode\x3eSubType.prototype\x3c\/code\x3e\x26nbsp;上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用\x3ccode\x3einstanceof\x3c\/code\x3e\x26nbsp;和\x3ccode\x3eisPrototypeOf()\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e这是最成熟的方法，也是现在库实现的方法\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch4\x3e7、混入方式继承多个对象\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function MyClass() {\n     SuperClass.call(this);\n     OtherSuperClass.call(this);\n}\n\n\/\/ 继承一个类\nMyClass.prototype = Object.create(SuperClass.prototype);\n\/\/ 混合其它\nObject.assign(MyClass.prototype, OtherSuperClass.prototype);\n\/\/ 重新指定constructor\nMyClass.prototype.constructor = MyClass;\n\nMyClass.prototype.myMethod = function() {\n     \/\/ do something\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyClass\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n     SuperClass.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n     OtherSuperClass.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继承一个类\x3c\/span\x3e\nMyClass.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(SuperClass.prototype);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 混合其它\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(MyClass.prototype, OtherSuperClass.prototype);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重新指定constructor\x3c\/span\x3e\nMyClass.prototype.constructor = MyClass;\n\nMyClass.prototype.myMethod = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do something\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eObject.assign\x3c\/code\x3e会把  \x3ccode\x3eOtherSuperClass\x3c\/code\x3e原型上的函数拷贝到 \x3ccode\x3eMyClass\x3c\/code\x3e原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。\x3c\/p\x3e\n\x3ch4\x3e8、ES6类继承extends\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eextends\x3c\/code\x3e关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中\x3ccode\x3econstructor\x3c\/code\x3e表示构造函数，一个类中只能有一个构造函数，有多个会报出\x3ccode\x3eSyntaxError\x3c\/code\x3e错误,如果没有显式指定构造方法，则会添加默认的 \x3ccode\x3econstructor\x3c\/code\x3e方法，使用例子如下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Rectangle {\n    \/\/ constructor\n    constructor(height, width) {\n        this.height = height;\n        this.width = width;\n    }\n    \n    \/\/ Getter\n    get area() {\n        return this.calcArea()\n    }\n    \n    \/\/ Method\n    calcArea() {\n        return this.height * this.width;\n    }\n}\n\nconst rectangle = new Rectangle(10, 20);\nconsole.log(rectangle.area);\n\/\/ 输出 200\n\n-----------------------------------------------------------------\n\/\/ 继承\nclass Square extends Rectangle {\n\n  constructor(length) {\n    super(length, length);\n    \n    \/\/ 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。\n    this.name = \x27Square\x27;\n  }\n\n  get area() {\n    return this.height * this.width;\n  }\n}\n\nconst square = new Square(10);\nconsole.log(square.area);\n\/\/ 输出 100\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRectangle\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ constructor\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(height, width) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.height = height;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.width = width;\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Getter\x3c\/span\x3e\n    get area() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.calcArea()\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Method\x3c\/span\x3e\n    calcArea() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.height * \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.width;\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e rectangle = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Rectangle(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(rectangle.area);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 200\x3c\/span\x3e\n\n-----------------------------------------------------------------\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继承\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSquare\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRectangle\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(length) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(length, length);\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Square\x27\x3c\/span\x3e;\n  }\n\n  get area() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.height * \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.width;\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e square = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Square(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(square.area);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 100\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eextends\x3c\/code\x3e继承的核心代码如下，其实现和上述的寄生组合式继承方式一样\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function _inherits(subType, superType) {\n  \n    \/\/ 创建对象，创建父类原型的一个副本\n    \/\/ 增强对象，弥补因重写原型而失去的默认的constructor 属性\n    \/\/ 指定对象，将新创建的对象赋值给子类的原型\n    subType.prototype = Object.create(superType \x26amp;\x26amp; superType.prototype, {\n        constructor: {\n            value: subType,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    \n    if (superType) {\n        Object.setPrototypeOf \n            ? Object.setPrototypeOf(subType, superType) \n            : subType.__proto__ = superType;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_inherits\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esubType, superType\x3c\/span\x3e) \x3c\/span\x3e{\n  \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建对象，创建父类原型的一个副本\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 增强对象，弥补因重写原型而失去的默认的constructor 属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定对象，将新创建的对象赋值给子类的原型\x3c\/span\x3e\n    subType.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(superType \x26amp;\x26amp; superType.prototype, {\n        \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: {\n            \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: subType,\n            \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n        }\n    });\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (superType) {\n        \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf \n            ? \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(subType, superType) \n            : subType.__proto__ = superType;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e总结\x3c\/h4\x3e\n\x3cp\x3e1、函数声明和类声明的区别\x3c\/p\x3e\n\x3cp\x3e函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let p = new Rectangle(); \n\/\/ ReferenceError\n\nclass Rectangle {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e p = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Rectangle(); \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ReferenceError\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRectangle\x3c\/span\x3e \x3c\/span\x3e{}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2、ES5继承和ES6继承的区别\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.\x3c\/li\x3e\n\x3cli\x3eES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\n\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000011917606\x22\x3e《javascript高级程序设计》笔记：继承\x3c\/a\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/create\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN之Object.create()\x3c\/a\x3e  \x3cbr\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Classes\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN之Class\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch4\x3e交流\x3c\/h4\x3e\n\x3cp\x3e本人Github链接如下，欢迎各位Star\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/github.com\/yygmind\/blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/github.com\/yygmind\/blog\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e我是木易杨，现在是网易高级前端工程师，目前维护了一个高级前端进阶群，欢迎加入。接下来让我带你走进高级前端的世界，在进阶的路上，共勉！\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016890954?w=1325\x26amp;h=897\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016890954?w=1325\x26amp;h=897\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript常用八种继承方案</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016891009">https://segmentfault.com/a/1190000016891009</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/183cav6qpdb/" target="_blank">https://alili.tech/archive/183cav6qpdb/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/ol9qis0n8xe/">2019年04月Github Javascript开源项目精选<aside class="dates">2019-04-08</aside></a></li><li><a href="/archive/7815p445rtf/">记一次MongoDB迁移 - 备份与恢复<aside class="dates">2019-03-27</aside></a></li><li><a href="/archive/a5ficy1jp7n/">2019年03月Github Javascript开源项目精选<aside class="dates">2019-03-08</aside></a></li><li><a href="/archive/nyhmtbanv2e/">Alili Weekly 前端周刊 第二十一期<aside class="dates">2019-03-08</aside></a></li><li><a href="/archive/304a32r2py8/">30分钟精通React今年最劲爆的新特性——React Hooks<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/sj4oqgzx0rk/">CSS6：flex布局<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/wedm7eypuhb/">ES6 系列之 Babel 将 Async 编译成了什么样子<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/cazifdrck0u/">ES6 系列之我们来聊聊 Async<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/0dlsi4qmvsvf/">Express的基本使用<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/5tpnsqmgslq/">React 手稿 - Component state<aside class="dates">2019-03-02</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>