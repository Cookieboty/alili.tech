<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="30分钟精通React今年最劲爆的新特性——React Hooks"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>30分钟精通React今年最劲爆的新特性——React Hooks | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/304a32r2py8/",
				"appid": "1613049289050283", 
				"title": "30分钟精通React今年最劲爆的新特性——React Hooks | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-03-02T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/sj4oqgzx0rk/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/nyhmtbanv2e/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f&text=30%e5%88%86%e9%92%9f%e7%b2%be%e9%80%9aReact%e4%bb%8a%e5%b9%b4%e6%9c%80%e5%8a%b2%e7%88%86%e7%9a%84%e6%96%b0%e7%89%b9%e6%80%a7%e2%80%94%e2%80%94React%20Hooks"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f&text=30%e5%88%86%e9%92%9f%e7%b2%be%e9%80%9aReact%e4%bb%8a%e5%b9%b4%e6%9c%80%e5%8a%b2%e7%88%86%e7%9a%84%e6%96%b0%e7%89%b9%e6%80%a7%e2%80%94%e2%80%94React%20Hooks"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f&title=30%e5%88%86%e9%92%9f%e7%b2%be%e9%80%9aReact%e4%bb%8a%e5%b9%b4%e6%9c%80%e5%8a%b2%e7%88%86%e7%9a%84%e6%96%b0%e7%89%b9%e6%80%a7%e2%80%94%e2%80%94React%20Hooks"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f&is_video=false&description=30%e5%88%86%e9%92%9f%e7%b2%be%e9%80%9aReact%e4%bb%8a%e5%b9%b4%e6%9c%80%e5%8a%b2%e7%88%86%e7%9a%84%e6%96%b0%e7%89%b9%e6%80%a7%e2%80%94%e2%80%94React%20Hooks"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=30%e5%88%86%e9%92%9f%e7%b2%be%e9%80%9aReact%e4%bb%8a%e5%b9%b4%e6%9c%80%e5%8a%b2%e7%88%86%e7%9a%84%e6%96%b0%e7%89%b9%e6%80%a7%e2%80%94%e2%80%94React%20Hooks&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f&title=30%e5%88%86%e9%92%9f%e7%b2%be%e9%80%9aReact%e4%bb%8a%e5%b9%b4%e6%9c%80%e5%8a%b2%e7%88%86%e7%9a%84%e6%96%b0%e7%89%b9%e6%80%a7%e2%80%94%e2%80%94React%20Hooks"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f&title=30%e5%88%86%e9%92%9f%e7%b2%be%e9%80%9aReact%e4%bb%8a%e5%b9%b4%e6%9c%80%e5%8a%b2%e7%88%86%e7%9a%84%e6%96%b0%e7%89%b9%e6%80%a7%e2%80%94%e2%80%94React%20Hooks"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f&title=30%e5%88%86%e9%92%9f%e7%b2%be%e9%80%9aReact%e4%bb%8a%e5%b9%b4%e6%9c%80%e5%8a%b2%e7%88%86%e7%9a%84%e6%96%b0%e7%89%b9%e6%80%a7%e2%80%94%e2%80%94React%20Hooks"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f304a32r2py8%2f&title=30%e5%88%86%e9%92%9f%e7%b2%be%e9%80%9aReact%e4%bb%8a%e5%b9%b4%e6%9c%80%e5%8a%b2%e7%88%86%e7%9a%84%e6%96%b0%e7%89%b9%e6%80%a7%e2%80%94%e2%80%94React%20Hooks"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">30分钟精通React今年最劲爆的新特性——React Hooks</h1><div class="meta"><div class="postdate"><time datetime="2019-03-02" itemprop="datePublished">2019-03-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e你还在为该使用无状态组件（Function）还是有状态组件（Class）而烦恼吗？\x3cbr\x3e  ——拥有了hooks，你再也不需要写Class了，你的所有组件都将是Function。\x3c\/p\x3e\n\x3cp\x3e你还在为搞不清使用哪个生命周期钩子函数而日夜难眠吗？\x3cbr\x3e  ——拥有了Hooks，生命周期钩子函数可以先丢一边了。\x3c\/p\x3e\n\x3cp\x3e你在还在为组件中的this指向而晕头转向吗？\x3cbr\x3e  ——既然Class都丢掉了，哪里还有this？你的人生第一次不再需要面对this。\x3c\/p\x3e\n\x3cp\x3e这样看来，说React Hooks是今年最劲爆的新特性真的毫不夸张。如果你也对react感兴趣，或者正在使用react进行项目开发，答应我，请一定抽出至少30分钟的时间来阅读本文好吗？所有你需要了解的React Hooks的知识点，本文都涉及到了，相信完整读完后你一定会有所收获。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e一个最简单的Hooks\x3c\/h2\x3e\n\x3cp\x3e首先让我们看一下一个简单的有状态组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3cp\x3eYou clicked {this.state.count} times\x3c\/p\x3e\n        \x3cbutton onClick={() =\x3e this.setState({ count: this.state.count \x2b 1 })}\x3e\n          Click me\n        \x3c\/button\x3e\n      \x3c\/div\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3eclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = {\n      count: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    };\n  }\n\n  render() {\n    return (\n      \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;div\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;p\x26gt;\x3c\/span\x3eYou clicked {this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.count} times\x26lt;\/p\x26gt;\n        \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;button onClick={() =\x26gt;\x3c\/span\x3e this.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3eState({ count: this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e })}\x26gt;\n          Click me\n        \x26lt;\/button\x26gt;\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们再来看一下使用hooks后的版本：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { useState } from \x27react\x27;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \x3cdiv\x3e\n      \x3cp\x3eYou clicked {count} times\x3c\/p\x3e\n      \x3cbutton onClick={() =\x3e setCount(count \x2b 1)}\x3e\n        Click me\n      \x3c\/button\x3e\n    \x3c\/div\x3e\n  );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { useState } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExample\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [count, setCount] = useState(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eYou clicked {count} times\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e setCount(count \x2b 1)}\x26gt;\n        Click me\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e是不是简单多了！可以看到，\x3ccode\x3eExample\x3c\/code\x3e变成了一个函数，但这个函数却有自己的状态（count），同时它还可以更新自己的状态（setCount）。这个函数之所以这么了不得，就是因为它注入了一个hook--\x3ccode\x3euseState\x3c\/code\x3e，就是这个hook让我们的函数变成了一个有状态的函数。\x3c\/p\x3e\n\x3cp\x3e除了\x3ccode\x3euseState\x3c\/code\x3e这个hook外，还有很多别的hook，比如\x3ccode\x3euseEffect\x3c\/code\x3e提供了类似于\x3ccode\x3ecomponentDidMount\x3c\/code\x3e等生命周期钩子的功能，\x3ccode\x3euseContext\x3c\/code\x3e提供了上下文（context）的功能等等。\x3c\/p\x3e\n\x3cp\x3eHooks本质上就是一类特殊的函数，它们可以为你的函数型组件（function component）注入一些特殊的功能。咦？这听起来有点像被诟病的Mixins啊？难道是Mixins要在react中死灰复燃了吗？当然不会了，等会我们再来谈两者的区别。总而言之，这些hooks的目标就是让你不再写class，让function一统江湖。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eReact为什么要搞一个Hooks？\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e想要复用一个有状态的组件太麻烦了！\x3c\/h3\x3e\n\x3cp\x3e我们都知道react都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用react，你会发现你的项目中实际上很多react组件冗长且难以复用。尤其是那些写成class的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。\x3c\/p\x3e\n\x3cp\x3e那之前，官方推荐怎么解决这个问题呢？答案是：\x3ca href=\x22https:\/\/reactjs.org\/docs\/render-props.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e渲染属性（Render Props）\x3c\/a\x3e和\x3ca href=\x22\/img\/bVbjfuz\x22\x3e高阶组件（Higher-Order Components）\x3c\/a\x3e。我们可以稍微跑下题简单看一下这两种模式。\x3c\/p\x3e\n\x3cp\x3e渲染属性指的是使用一个值为函数的prop来传递需要动态渲染的nodes或组件。如下面的代码可以看到我们的\x3ccode\x3eDataProvider\x3c\/code\x3e组件包含了所有跟状态相关的代码，而\x3ccode\x3eCat\x3c\/code\x3e组件则可以是一个单纯的展示型组件，这样一来\x3ccode\x3eDataProvider\x3c\/code\x3e就可以单独复用了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Cat from \x27components\/cat\x27\nclass DataProvider extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { target: \x27Zac\x27 };\n  }\n\n  render() {\n    return (\n      \x3cdiv\x3e\n        {this.props.render(this.state)}\n      \x3c\/div\x3e\n    )\n  }\n}\n\n\x3cDataProvider render={data =\x3e (\n  \x3cCat target={data.target} \/\x3e\n)}\/\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eCat\x3c\/span\x3e from \x3cspan class=\x22hljs-symbol\x22\x3e\x27components\x3c\/span\x3e\/cat\x27\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDataProvider\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { target: \x3cspan class=\x22hljs-symbol\x22\x3e\x27Za\x3c\/span\x3ec\x27 };\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.render(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state)}\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\n\n\x26lt;\x3cspan class=\x22hljs-type\x22\x3eDataProvider\x3c\/span\x3e render={data =\x26gt; (\n  \x26lt;\x3cspan class=\x22hljs-type\x22\x3eCat\x3c\/span\x3e target={data.target} \/\x26gt;\n)}\/\x26gt;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然这个模式叫Render Props，但不是说非用一个叫render的props不可，习惯上大家更常写成下面这种：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22...\n\x3cDataProvider\x3e\n  {data =\x3e (\n    \x3cCat target={data.target} \/\x3e\n  )}\n\x3c\/DataProvider\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e...\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eDataProvider\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  {data =\x26gt; (\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCat\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etarget\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{data.target}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  )}\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eDataProvider\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e高阶组件这个概念就更好理解了，说白了就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，\x3ccode\x3ewithUser\x3c\/code\x3e函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const withUser = WrappedComponent =\x3e {\n  const user = sessionStorage.getItem(\x26quot;user\x26quot;);\n  return props =\x3e \x3cWrappedComponent user={user} {...props} \/\x3e;\n};\n\nconst UserPage = props =\x3e (\n  \x3cdiv class=\x26quot;user-container\x26quot;\x3e\n    \x3cp\x3eMy name is {props.user}!\x3c\/p\x3e\n  \x3c\/div\x3e\n);\n\nexport default withUser(UserPage);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e withUser = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e user = sessionStorage.getItem(\x3cspan class=\x22hljs-string\x22\x3e\x22user\x22\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x26lt;WrappedComponent user={user} {...props} \/\x26gt;;\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e UserPage = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e =\x26gt;\x3c\/span\x3e (\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22user-container\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eMy name is {props.user}!\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n);\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e withUser(UserPage);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上这两种模式看上去都挺不错的，很多库也运用了这种模式，比如我们常用的React Router。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开devtool看看你的组件层级嵌套是不是很夸张吧。这时候再回过头看我们上一节给出的hooks例子，是不是简洁多了，没有多余的层级嵌套。把各种想要的功能写成一个一个可复用的自定义hook，当你的组件想用什么功能时，直接在组件里调用这个hook即可。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbjfuz?w=923\x26amp;h=590\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbjfuz?w=923\x26amp;h=590\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e生命周期钩子函数里的逻辑太乱了吧！\x3c\/h3\x3e\n\x3cp\x3e我们通常希望一个函数只做一件事情，但我们的生命周期钩子函数里通常同时做了很多事情。比如我们需要在\x3ccode\x3ecomponentDidMount\x3c\/code\x3e中发起ajax请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e做一遍同样的事情。当项目变复杂后，这一块的代码也变得不那么直观。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eclasses真的太让人困惑了！\x3c\/h3\x3e\n\x3cp\x3e我们用class来创建react组件时，还有一件很麻烦的事情，就是this的指向问题。为了保证this的指向正确，我们要经常写这样的代码：\x3ccode\x3ethis.handleClick = this.handleClick.bind(this)\x3c\/code\x3e，或者是这样的代码：\x3ccode\x3e\x26lt;button onClick={() =\x26gt; this.handleClick(e)}\x26gt;\x3c\/code\x3e。一旦我们不小心忘了绑定this，各种bug就随之而来，很麻烦。\x3c\/p\x3e\n\x3cp\x3e还有一件让我很苦恼的事情。我在之前的react系列文章当中曾经说过，尽可能把你的组件写成无状态组件的形式，因为它们更方便复用，可独立测试。然而很多时候，我们用function写了一个简洁完美的无状态组件，后来因为需求变动这个组件必须得有自己的state，我们又得很麻烦的把function改成class。\x3c\/p\x3e\n\x3cp\x3e在这样的背景下，Hooks便横空出世了！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e什么是State Hooks？\x3c\/h2\x3e\n\x3cp\x3e回到一开始我们用的例子，我们分解来看到底state hooks做了什么：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { useState } from \x27react\x27;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \x3cdiv\x3e\n      \x3cp\x3eYou clicked {count} times\x3c\/p\x3e\n      \x3cbutton onClick={() =\x3e setCount(count \x2b 1)}\x3e\n        Click me\n      \x3c\/button\x3e\n    \x3c\/div\x3e\n  );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { useState } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExample\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [count, setCount] = useState(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eYou clicked {count} times\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e setCount(count \x2b 1)}\x26gt;\n        Click me\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e声明一个状态变量\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { useState } from \x27react\x27;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { useState } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExample\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [count, setCount] = useState(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3euseState\x3c\/code\x3e是react自带的一个hook函数，它的作用就是用来声明状态变量。\x3ccode\x3euseState\x3c\/code\x3e这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第\x3ccode\x3e[0]\x3c\/code\x3e项是当前当前的状态值，第\x3ccode\x3e[1]\x3c\/code\x3e项是可以改变状态值的方法函数。\x3c\/p\x3e\n\x3cp\x3e所以我们做的事情其实就是，声明了一个状态变量count，把它的初始值设为0，同时提供了一个可以更改count的函数setCount。\x3c\/p\x3e\n\x3cp\x3e上面这种表达形式，是借用了es6的数组解构（\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Operators\/Destructuring_assignment#Array_destructuring\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3earray destructuring\x3c\/a\x3e），它可以让我们的代码看起来更简洁。不清楚这种用法的可以先去看下我的这篇文章\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004365693\x22\x3e30分钟掌握ES6\/ES2015核心内容（上）\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e如果不用数组解构的话，可以写成下面这样。实际上数组解构是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。具体可以去这篇文章的分析\x3ca href=\x22https:\/\/docs.google.com\/document\/d\/1hWb-lQW4NSG9yRpyyiAA_9Ktytd5lypLnVLhPX9vamE\/edit#\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eArray destructuring for multi-value returns (in light of React hooks)\x3c\/a\x3e，这里不详细展开，我们就按照官方推荐使用数组解构就好。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let _useState = useState(0);\nlet count = _useState[0];\nlet setCount = _useState[1];\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nix\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3e_useState\x3c\/span\x3e = useState(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e = _useState[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esetCount\x3c\/span\x3e = _useState[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e读取状态值\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cp\x3eYou clicked {count} times\x3c\/p\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e\x26lt;p\x26gt;\x3c\/span\x3eYou \x3cspan class=\x22hljs-class\x22\x3eclicked \x3c\/span\x3e{count} times\x3cspan class=\x22hljs-params\x22\x3e\x26lt;\/p\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e是不是超简单？因为我们的状态count就是一个单纯的变量而已，我们再也不需要写成\x3ccode\x3e{this.state.count}\x3c\/code\x3e这样了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e更新状态\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \x3cbutton onClick={() =\x3e setCount(count \x2b 1)}\x3e\n    Click me\n  \x3c\/button\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e setCount(count \x2b 1)}\x26gt;\n    Click me\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当用户点击按钮时，我们调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给react了，react将会重新渲染我们的Example组件，并且使用的是更新后的新的状态，即count=1。这里我们要停下来思考一下，Example本质上也是一个普通的函数，为什么它可以记住之前的状态？\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e一个至关重要的问题\x3c\/h3\x3e\n\x3cp\x3e这里我们就发现了问题，通常来说我们在一个函数中声明的变量，当函数运行完成后，这个变量也就销毁了（这里我们先不考虑闭包等情况），比如考虑下面的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add(n) {\n    const result = 0;\n    return result \x2b 1;\n}\n\nadd(1); \/\/1\nadd(1); \/\/1\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dockerfile\x22\x3e\x3ccode\x3efunction \x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e(n) {\n\x3c\/span\x3e    const result = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    return result \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e(1); \/\/1\n\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e(1); \/\/1\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不管我们反复调用add函数多少次，结果都是1。因为每一次我们调用add时，result变量都是从初始值0开始的。那为什么上面的Example函数每次执行的时候，都是拿的上一次执行完的状态值作为初始值？答案是：是react帮我们记住的。至于react是用什么机制记住的，我们可以再思考一下。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e假如一个组件有多个状态值怎么办？\x3c\/h3\x3e\n\x3cp\x3e首先，useState是可以多次调用的，所以我们完全可以这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function ExampleWithManyStates() {\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState(\x27banana\x27);\n  const [todos, setTodos] = useState([{ text: \x27Learn Hooks\x27 }]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleWithManyStates\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [age, setAge] = useState(\x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [fruit, setFruit] = useState(\x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [todos, setTodos] = useState([{ text: \x3cspan class=\x22hljs-string\x22\x3e\x27Learn Hooks\x27\x3c\/span\x3e }]);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其次，useState接收的初始值没有规定一定要是string\/number\/boolean这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的\x3ccode\x3ethis.setState\x3c\/code\x3e做的是合并状态后返回一个新状态，而\x3ccode\x3euseState\x3c\/code\x3e是直接替换老状态后返回新状态。最后，react也给我们提供了一个useReducer的hook，如果你更喜欢redux式的状态管理方案的话。\x3c\/p\x3e\n\x3cp\x3e从ExampleWithManyStates函数我们可以看到，useState无论调用多少次，相互之间是独立的。这一点至关重要。为什么这么说呢？\x3c\/p\x3e\n\x3cp\x3e其实我们看hook的“形态”，有点类似之前被官方否定掉的Mixins这种方案，都是提供一种“插拔式的功能注入”的能力。而mixins之所以被否定，是因为Mixins机制是让多个Mixins共享一个对象的数据空间，这样就很难确保不同Mixins依赖的状态不发生冲突。\x3c\/p\x3e\n\x3cp\x3e而现在我们的hook，一方面它是直接用在function当中，而不是class；另一方面每一个hook都是相互独立的，不同组件调用同一个hook也能保证各自状态的独立性。这就是两者的本质区别了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3ereact是怎么保证多个useState的相互独立的？\x3c\/h3\x3e\n\x3cp\x3e还是看上面给出的ExampleWithManyStates例子，我们调用了三次useState，每次我们传的参数只是一个值（如42，‘banana’），我们根本没有告诉react这些值对应的key是哪个，那react是怎么保证这三个useState找到它对应的state呢？\x3c\/p\x3e\n\x3cp\x3e答案是，react是根据useState出现的顺序来定的。我们具体来看一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/第一次渲染\n  useState(42);  \/\/将age初始化为42\n  useState(\x27banana\x27);  \/\/将fruit初始化为banana\n  useState([{ text: \x27Learn Hooks\x27 }]); \/\/...\n\n  \/\/第二次渲染\n  useState(42);  \/\/读取状态变量age的值（这时候传的参数42直接被忽略）\n  useState(\x27banana\x27);  \/\/读取状态变量fruit的值（这时候传的参数banana直接被忽略）\n  useState([{ text: \x27Learn Hooks\x27 }]); \/\/...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/第一次渲染\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/将age初始化为42\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/将fruit初始化为banana\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e([{ \x3cspan class=\x22hljs-attribute\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Learn Hooks\x27\x3c\/span\x3e }]); \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/第二次渲染\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/读取状态变量age的值（这时候传的参数42直接被忽略）\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/读取状态变量fruit的值（这时候传的参数banana直接被忽略）\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e([{ \x3cspan class=\x22hljs-attribute\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Learn Hooks\x27\x3c\/span\x3e }]); \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e假如我们改一下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let showFruit = true;\nfunction ExampleWithManyStates() {\n  const [age, setAge] = useState(42);\n  \n  if(showFruit) {\n    const [fruit, setFruit] = useState(\x27banana\x27);\n    showFruit = false;\n  }\n \n  const [todos, setTodos] = useState([{ text: \x27Learn Hooks\x27 }]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e showFruit = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleWithManyStates\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [age, setAge] = useState(\x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e);\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(showFruit) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [fruit, setFruit] = useState(\x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e);\n    showFruit = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  }\n \n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [todos, setTodos] = useState([{ \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Learn Hooks\x27\x3c\/span\x3e }]);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样一来，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/第一次渲染\n  useState(42);  \/\/将age初始化为42\n  useState(\x27banana\x27);  \/\/将fruit初始化为banana\n  useState([{ text: \x27Learn Hooks\x27 }]); \/\/...\n\n  \/\/第二次渲染\n  useState(42);  \/\/读取状态变量age的值（这时候传的参数42直接被忽略）\n  \/\/ useState(\x27banana\x27);  \n  useState([{ text: \x27Learn Hooks\x27 }]); \/\/读取到的却是状态变量fruit的值，导致报错\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/第一次渲染\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/将age初始化为42\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/将fruit初始化为banana\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e([{ \x3cspan class=\x22hljs-attribute\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Learn Hooks\x27\x3c\/span\x3e }]); \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/第二次渲染\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/读取状态变量age的值（这时候传的参数42直接被忽略）\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ useState(\x27banana\x27);  \x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3euseState\x3c\/span\x3e([{ \x3cspan class=\x22hljs-attribute\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Learn Hooks\x27\x3c\/span\x3e }]); \x3cspan class=\x22hljs-comment\x22\x3e\/\/读取到的却是状态变量fruit的值，导致报错\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e鉴于此，react规定我们必须把hooks写在函数的最外层，不能写在ifelse等条件语句当中，来确保hooks的执行顺序一致。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e什么是Effect Hooks?\x3c\/h2\x3e\n\x3cp\x3e我们在上一节的例子中增加一个新功能：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { useState, useEffect } from \x27react\x27;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  \/\/ 类似于componentDidMount 和 componentDidUpdate:\n  useEffect(() =\x3e {\n    \/\/ 更新文档的标题\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    \x3cdiv\x3e\n      \x3cp\x3eYou clicked {count} times\x3c\/p\x3e\n      \x3cbutton onClick={() =\x3e setCount(count \x2b 1)}\x3e\n        Click me\n      \x3c\/button\x3e\n    \x3c\/div\x3e\n  );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { useState, useEffect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExample\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [count, setCount] = useState(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 类似于componentDidMount 和 componentDidUpdate:\x3c\/span\x3e\n  useEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更新文档的标题\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.title = \x3cspan class=\x22hljs-string\x22\x3e`You clicked \x3cspan class=\x22hljs-subst\x22\x3e${count}\x3c\/span\x3e times`\x3c\/span\x3e;\n  });\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eYou clicked {count} times\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e setCount(count \x2b 1)}\x26gt;\n        Click me\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们对比着看一下，如果没有hooks，我们会怎么写？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3cp\x3eYou clicked {this.state.count} times\x3c\/p\x3e\n        \x3cbutton onClick={() =\x3e this.setState({ count: this.state.count \x2b 1 })}\x3e\n          Click me\n        \x3c\/button\x3e\n      \x3c\/div\x3e\n    );\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3eclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = {\n      count: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.count} times`;\n  }\n\n  componentDidUpdate() {\n    document.title = `You clicked ${this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.count} times`;\n  }\n\n  render() {\n    return (\n      \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;div\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;p\x26gt;\x3c\/span\x3eYou clicked {this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.count} times\x26lt;\/p\x26gt;\n        \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;button onClick={() =\x26gt;\x3c\/span\x3e this.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3eState({ count: this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e })}\x26gt;\n          Click me\n        \x26lt;\/button\x26gt;\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起ajax请求获取数据，添加一些监听的注册和取消注册，手动修改dom等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如componentDidMount，componentDidUpdate和componentWillUnmount。而现在的useEffect就相当与这些声明周期函数钩子的集合体。它以一抵三。\x3c\/p\x3e\n\x3cp\x3e同时，由于前文所说hooks可以反复多次使用，相互独立。所以我们合理的做法是，给每一个副作用一个单独的useEffect钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3euseEffect做了什么？\x3c\/h3\x3e\n\x3cp\x3e我们再梳理一遍下面代码的逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =\x3e {\n    document.title = `You clicked ${count} times`;\n  });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExample\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [count, setCount] = useState(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n  useEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.title = \x3cspan class=\x22hljs-string\x22\x3e`You clicked \x3cspan class=\x22hljs-subst\x22\x3e${count}\x3c\/span\x3e times`\x3c\/span\x3e;\n  });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先，我们声明了一个状态变量\x3ccode\x3ecount\x3c\/code\x3e，将它的初始值设为0。然后我们告诉react，我们的这个组件有一个副作用。我们给\x3ccode\x3euseEffect\x3c\/code\x3ehook传了一个匿名函数，这个匿名函数就是我们的副作用。在这个例子里，我们的副作用是调用browser API来修改文档标题。当react要渲染我们的组件时，它会先记住我们用到的副作用。等react更新了DOM之后，它再依次执行我们定义的副作用函数。\x3c\/p\x3e\n\x3cp\x3e这里要注意几点：\x3cbr\x3e第一，react首次渲染和之后的每次渲染都会调用一遍传给useEffect的函数。而之前我们要用两个声明周期函数来分别表示首次渲染（componentDidMount），和之后的更新导致的重新渲染（componentDidUpdate）。\x3c\/p\x3e\n\x3cp\x3e第二，useEffect中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的componentDidMount或componentDidUpdate中的代码则是同步执行的。这种安排对大多数副作用说都是合理的，但有的情况除外，比如我们有时候需要先根据DOM计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3euseEffect怎么解绑一些副作用\x3c\/h3\x3e\n\x3cp\x3e这种场景很常见，当我们在componentDidMount里添加了一个注册，我们得马上在componentWillUnmount中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。\x3c\/p\x3e\n\x3cp\x3e怎么清除呢？让我们传给useEffect的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些pubsub模式的实现中很常见。看下面的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { useState, useEffect } from \x27react\x27;\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() =\x3e {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    \/\/ 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return \x27Loading...\x27;\n  }\n  return isOnline ? \x27Online\x27 : \x27Offline\x27;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { useState, useEffect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFriendStatus\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [isOnline, setIsOnline] = useState(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleStatusChange\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estatus\x3c\/span\x3e) \x3c\/span\x3e{\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecleanup\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isOnline === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Loading...\x27\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e isOnline ? \x3cspan class=\x22hljs-string\x22\x3e\x27Online\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27Offline\x27\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有一个点需要重视！这种解绑的模式跟componentWillUnmount不一样。componentWillUnmount只会在组件被销毁前执行一次而已，而useEffect里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e为什么要让副作用函数每次组件更新都执行一遍？\x3c\/h3\x3e\n\x3cp\x3e我们先看以前的模式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.friend.id,\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleStatusChange\n    );\n  }\n\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.friend.id,\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleStatusChange\n    );\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很清除，我们在componentDidMount注册，再在componentWillUnmount清除注册。但假如这时候\x3ccode\x3eprops.friend.id\x3c\/code\x3e变了怎么办？我们不得不再添加一个componentDidUpdate来处理这种情况：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22...\n  componentDidUpdate(prevProps) {\n    \/\/ 先把上一个friend.id解绑\n    ChatAPI.unsubscribeFromFriendStatus(\n      prevProps.friend.id,\n      this.handleStatusChange\n    );\n    \/\/ 再重新注册新但friend.id\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e...\n  componentDidUpdate(prevProps) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 先把上一个friend.id解绑\x3c\/span\x3e\n    ChatAPI.unsubscribeFromFriendStatus(\n      prevProps.friend.id,\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleStatusChange\n    );\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 再重新注册新但friend.id\x3c\/span\x3e\n    ChatAPI.subscribeToFriendStatus(\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.friend.id,\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleStatusChange\n    );\n  }\n...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看到了吗？很繁琐，而我们但useEffect则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221.页面首次渲染\n2.替friend.id=1的朋友注册\n\n3.突然friend.id变成了2\n4.页面重新渲染\n5.清除friend.id=1的绑定\n6.替friend.id=2的朋友注册\n...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e页面首次渲染\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e替friend.id=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e的朋友注册\n\n\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3e突然friend.id变成了\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e4.\x3c\/span\x3e页面重新渲染\n\x3cspan class=\x22hljs-number\x22\x3e5.\x3c\/span\x3e清除friend.id=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e的绑定\n\x3cspan class=\x22hljs-number\x22\x3e6.\x3c\/span\x3e替friend.id=\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e的朋友注册\n...\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e怎么跳过一些不必要的副作用函数\x3c\/h3\x3e\n\x3cp\x3e按照上一节的思路，每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22useEffect(() =\x3e {\n  document.title = `You clicked ${count} times`;\n}, [count]); \/\/ 只有当count的值发生变化时，才会重新执行`document.title`这一句\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3euseEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.title = `\x3cspan class=\x22javascript\x22\x3eYou clicked ${count} times\x3c\/span\x3e`;\n}, [count]); \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 只有当count的值发生变化时，才会重新执行`\x3cspan class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.title\x3c\/span\x3e`这一句\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是componentDidMount加componentWillUnmount的模式。不过这种用法可能带来bug，少用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e还有哪些自带的Effect Hooks?\x3c\/h2\x3e\n\x3cp\x3e除了上文重点介绍的useState和useEffect，react还给我们提供来很多有用的hooks：\x3c\/p\x3e\n\x3cp\x3euseContext\x3cbr\x3euseReducer\x3cbr\x3euseCallback\x3cbr\x3euseMemo\x3cbr\x3euseRef\x3cbr\x3euseImperativeMethods\x3cbr\x3euseMutationEffect\x3cbr\x3euseLayoutEffect\x3c\/p\x3e\n\x3cp\x3e我不再一一介绍，大家自行去查阅官方文档。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3e怎么写自定义的Effect Hooks?\x3c\/h2\x3e\n\x3cp\x3e为什么要自己去写一个Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。\x3c\/p\x3e\n\x3cp\x3e比如我们可以把上面写的FriendStatus组件中判断朋友是否在线的功能抽出来，新建一个useFriendStatus的hook专门用来判断某个id是否在线。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { useState, useEffect } from \x27react\x27;\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() =\x3e {\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    return () =\x3e {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  return isOnline;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { useState, useEffect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3euseFriendStatus\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efriendID\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [isOnline, setIsOnline] = useState(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleStatusChange\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estatus\x3c\/span\x3e) \x3c\/span\x3e{\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e isOnline;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时候FriendStatus组件就可以简写为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  if (isOnline === null) {\n    return \x27Loading...\x27;\n  }\n  return isOnline ? \x27Online\x27 : \x27Offline\x27;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFriendStatus\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(props)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isOnline = useFriendStatus(props.friend.id);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isOnline === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Loading...\x27\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e isOnline ? \x3cspan class=\x22hljs-string\x22\x3e\x27Online\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27Offline\x27\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e简直Perfect！假如这个时候我们又有一个朋友列表也需要显示是否在线的信息：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function FriendListItem(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  return (\n    \x3cli style=\x22{{\x22 color: isOnline ? \x27green\x27 : \x27black\x27 \x22}}\x22\x3e\n      {props.friend.name}\n    \x3c\/li\x3e\n  );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFriendListItem\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isOnline = useFriendStatus(props.friend.id);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22{{\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecolor:\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eisOnline\x3c\/span\x3e ? \x27\x3cspan class=\x22hljs-attr\x22\x3egreen\x3c\/span\x3e\x27 \x3cspan class=\x22hljs-attr\x22\x3e:\x3c\/span\x3e \x27\x3cspan class=\x22hljs-attr\x22\x3eblack\x3c\/span\x3e\x27 \x22}}\x22\x26gt;\x3c\/span\x3e\n      {props.friend.name}\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e简直Fabulous!\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader19\x22\x3e结尾\x3c\/h2\x3e\n\x3cp\x3e不知道你阅读完整篇文章的感受如何，或者对hooks有任何角度的看法和思考都欢迎在评论区一起讨论。另外如果你有换工作的打算，我们部门真的很缺人，欢迎私信勾搭～（阿里巴巴，base在深圳的部门）\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>30分钟精通React今年最劲爆的新特性——React Hooks</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016950339">https://segmentfault.com/a/1190000016950339</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/304a32r2py8/" target="_blank">https://alili.tech/archive/304a32r2py8/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/9xuojm75d2a/">前端微服务化进阶1 - 基于umi的子模块方案<aside class="dates">2019-04-13</aside></a></li><li><a href="/archive/ol9qis0n8xe/">2019年04月Github Javascript开源项目精选<aside class="dates">2019-04-08</aside></a></li><li><a href="/archive/7815p445rtf/">记一次MongoDB迁移 - 备份与恢复<aside class="dates">2019-03-27</aside></a></li><li><a href="/archive/a5ficy1jp7n/">2019年03月Github Javascript开源项目精选<aside class="dates">2019-03-08</aside></a></li><li><a href="/archive/nyhmtbanv2e/">Alili Weekly 前端周刊 第二十一期<aside class="dates">2019-03-08</aside></a></li><li><a href="/archive/sj4oqgzx0rk/">CSS6：flex布局<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/wedm7eypuhb/">ES6 系列之 Babel 将 Async 编译成了什么样子<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/cazifdrck0u/">ES6 系列之我们来聊聊 Async<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/0dlsi4qmvsvf/">Express的基本使用<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/183cav6qpdb/">JavaScript常用八种继承方案<aside class="dates">2019-03-02</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>