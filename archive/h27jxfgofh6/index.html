<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.每天碰到那么多问题,终归还是需要一个记录的地方. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="精读《谈谈 Web Workers》"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.每天碰到那么多问题,终归还是需要一个记录的地方. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js"><meta property="og:site_name" content="Alili"><title>精读《谈谈 Web Workers》 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/h27jxfgofh6/",
				"appid": "1613049289050283", 
				"title": "精读《谈谈 Web Workers》 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-03-02T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/gile08zdbpl/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ft16mznsx5f/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f&text=%e7%b2%be%e8%af%bb%e3%80%8a%e8%b0%88%e8%b0%88%20Web%20Workers%e3%80%8b"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f&text=%e7%b2%be%e8%af%bb%e3%80%8a%e8%b0%88%e8%b0%88%20Web%20Workers%e3%80%8b"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f&title=%e7%b2%be%e8%af%bb%e3%80%8a%e8%b0%88%e8%b0%88%20Web%20Workers%e3%80%8b"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f&is_video=false&description=%e7%b2%be%e8%af%bb%e3%80%8a%e8%b0%88%e8%b0%88%20Web%20Workers%e3%80%8b"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%b2%be%e8%af%bb%e3%80%8a%e8%b0%88%e8%b0%88%20Web%20Workers%e3%80%8b&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f&title=%e7%b2%be%e8%af%bb%e3%80%8a%e8%b0%88%e8%b0%88%20Web%20Workers%e3%80%8b"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f&title=%e7%b2%be%e8%af%bb%e3%80%8a%e8%b0%88%e8%b0%88%20Web%20Workers%e3%80%8b"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f&title=%e7%b2%be%e8%af%bb%e3%80%8a%e8%b0%88%e8%b0%88%20Web%20Workers%e3%80%8b"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fh27jxfgofh6%2f&title=%e7%b2%be%e8%af%bb%e3%80%8a%e8%b0%88%e8%b0%88%20Web%20Workers%e3%80%8b"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">精读《谈谈 Web Workers》</h1><div class="meta"><div class="postdate"><time datetime="2019-03-02" itemprop="datePublished">2019-03-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.每天碰到那么多问题,终归还是需要一个记录的地方. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e1 引言\x3c\/h2\x3e\n\x3cp\x3e本周精读的文章是 \x3ca href=\x22https:\/\/auth0.com\/blog\/speedy-introduction-to-web-workers\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3espeedy-introduction-to-web-workers\x3c\/a\x3e，是一篇 Web Workers 快速入门的文章，借精读这篇文章的机会，谈谈对 Web Workers 的理解与运用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2 概述\x3c\/h2\x3e\n\x3cblockquote\x3e就像分工，你只负责编码，而你的朋友负责设计，那你就可以专心把自己的事情做好，而且更快速的完成任务。\x3c\/blockquote\x3e\n\x3cp\x3e本文通过一个比方，描述了 Web Workers 的两大特征：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e高效。\x3c\/li\x3e\n\x3cli\x3e并行。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e因为浏览器是单线程的，任何大量耗时的 JS 任务都会卡住界面，使浏览器无法响应任何操作，这样的用户体验非常糟糕。Web Workers 可以将耗时任务拆解出去，降低主线程的压力，避免主线程无响应。\x3c\/p\x3e\n\x3cblockquote\x3e但 CPU 资源是有限的，Web Workers 并不能增加总体运行效率，算上通信的损耗，整体计算效率会有一定的下降。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e创建 Web Workers\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const worker = new Worker(\x26quot;..\/src\/worker.js\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e worker = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Worker(\x3cspan class=\x22hljs-string\x22\x3e\x22..\/src\/worker.js\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码中，\x3ccode\x3eworker\x3c\/code\x3e 就是一个 Web Workers 实例，执行的代码是 \x3ccode\x3e..\/src\/worker.js\x3c\/code\x3e 路径下的文件。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e收发消息\x3c\/h3\x3e\n\x3cp\x3eWeb Workers 用来执行异步脚本，只要掌握了它与主线程通信的方式，就可以在指定时机运行异步脚本，并在运行完时将结果传递给主线程。\x3c\/p\x3e\n\x3ch4\x3e主线程接收发 Web Workers 消息\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const worker = new Worker(\x26quot;..\/src\/worker.js\x26quot;);\n\nworker.onmessage = e =\x3e {};\n\nworker.postMessage(\x26quot;Marco!\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e worker = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Worker(\x3cspan class=\x22hljs-string\x22\x3e\x22..\/src\/worker.js\x22\x3c\/span\x3e);\n\nworker.onmessage = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {};\n\nworker.postMessage(\x3cspan class=\x22hljs-string\x22\x3e\x22Marco!\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每个 \x3ccode\x3eworker\x3c\/code\x3e 实例通过 \x3ccode\x3eonmessage\x3c\/code\x3e 接收消息，通过 \x3ccode\x3epostMessage\x3c\/code\x3e 发送消息。\x3c\/p\x3e\n\x3ch4\x3eWeb Workers 收发主线程消息\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22self.onmessage = e =\x3e {};\n\nself.postMessage(\x26quot;Marco!\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eself.onmessage = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {};\n\nself.postMessage(\x3cspan class=\x22hljs-string\x22\x3e\x22Marco!\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和主线程代码类似，在 Web Workers 代码中，也是 \x3ccode\x3eonmessage\x3c\/code\x3e 接收消息，这个消息来自主线程或者其它 Workers。也可以通过 \x3ccode\x3epostMessage\x3c\/code\x3e 发送消息。\x3c\/p\x3e\n\x3ch4\x3e销毁 Web Workers\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22worker.terminate();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eworker.terminate();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e文章内容就这么多，是不是有写太简单了呢！笔者结合自己的使用经验，再补充一些知识。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e3 精读\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e对象转移（Transferable Objects）\x3c\/h3\x3e\n\x3cp\x3e对象转移就是将对象引用零成本转交给 Web Workers 的上下文，而不需要进行结构拷贝。\x3c\/p\x3e\n\x3cp\x3e这里要解释的是，\x3cstrong\x3e主线程与 Web Workers 之间的通信，并不是对象引用的传递，而是序列化\/反序列化的过程\x3c\/strong\x3e，当对象非常庞大时，序列化和反序列化都会消耗大量计算资源，降低运行速度。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016756469?w=577\x26amp;h=318\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016756469?w=577\x26amp;h=318\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面的图充分证明了，大对象传递，使用对象转移各项指标都优于结构拷贝。\x3c\/p\x3e\n\x3cp\x3e对象转移使用方式很简单，给 \x3ccode\x3epostMessage\x3c\/code\x3e 增加一个参数，把对象引用传过去即可：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var ab = new ArrayBuffer(1);\nworker.postMessage(ab, [ab]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ab = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArrayBuffer\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\nworker.postMessage(ab, [ab]);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e浏览器兼容性也不错：Currently Chrome 17\x2b, Firefox, Opera, Safari, IE10\x2b。更具体内容，可以看 \x3ca href=\x22https:\/\/developers.google.com\/web\/updates\/2011\/12\/Transferable-Objects-Lightning-Fast\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTransferable Objects: Lightning Fast!\x3c\/a\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e需要注意的是，对象引用转移后，原先上下文就无法访问此对象了，需要在 Web Workers 再次将对象还原到主线程上下文后，主线程才能正常访问被转交的对象。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e如何不用 JS 文件创建 Web Workers\x3c\/h3\x3e\n\x3cp\x3eWeb Workers 优势这么大，但用起来需要在同域下创建一个 JS 文件实在不方便，尤其在前后端分离做的比较彻底的团队，前端团队能控制的仅仅是一个 JS 文件。那么下面给出几个不用 JS 文件，就创建 Web Workers 的方法：\x3c\/p\x3e\n\x3ch4\x3ewebpack 插件 - worker-loader\x3c\/h4\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/webpack-contrib\/worker-loader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eworker-loader\x3c\/a\x3e 是一个 webpack 插件，可以将一个普通 JS 文件的全部依赖提取后打包并替换调用处，以 Blob 形式内联在源码中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Worker from \x26quot;worker-loader!.\/file.worker.js\x26quot;;\n\nconst worker = new Worker();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Worker \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22worker-loader!.\/file.worker.js\x22\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e worker = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Worker();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码的魔术在于，转化成下面的方式执行：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const blob = new Blob([codeFromFileWorker], { type: \x26quot;application\/javascript\x26quot; });\nconst worker = new Worker(URL.createObjectURL(blob));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e blob = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Blob([codeFromFileWorker], { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22application\/javascript\x22\x3c\/span\x3e });\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e worker = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Worker(URL.createObjectURL(blob));\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eBlob URL\x3c\/h4\x3e\n\x3cp\x3e第二种方式由第一种方式自然带出：如果不想用 webpack 插件，那自己通过 Blob 的方式创建也可以：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const code = `\n  importScripts(\x27https:\/\/xxx.com\/xxx.js\x27);\n  self.onmessage = e =\x3e {};\n`;\n\nconst blob = new Blob([code], { type: \x26quot;application\/javascript\x26quot; });\nconst worker = new Worker(URL.createObjectURL(blob));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e code = \x3cspan class=\x22hljs-string\x22\x3e`\n  importScripts(\x27https:\/\/xxx.com\/xxx.js\x27);\n  self.onmessage = e =\x26gt; {};\n`\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e blob = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Blob([code], { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22application\/javascript\x22\x3c\/span\x3e });\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e worker = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Worker(URL.createObjectURL(blob));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看上去代码更轻量一些，不过问题是当遇到复杂依赖时，如果不能把依赖都转化为脚本通过 \x3ccode\x3eimportScripts\x3c\/code\x3e 方式引用，就无法访问到主线程环境中的包。如果真的遇到了这个问题，可以用第一种 webpack 插件的方式解决，这个插件会自动把文件所有依赖都打包进源码。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e管理 postMessage 队列\x3c\/h3\x3e\n\x3cp\x3e为什么 postMessage 会形成队列，为什么要管理它？\x3c\/p\x3e\n\x3cp\x3e首先在 Web Workers 架构设计上就必须做成队列，因为调用 \x3ccode\x3epostMessage\x3c\/code\x3e 时，对应的 Web Workers 不一定完成了初始化，所以浏览器底层必须管理一个队列，在 Web Workers 初始化完毕时，依次消费，这样才能确保任何时候发出的 \x3ccode\x3epostMessage\x3c\/code\x3e 都能被 Web Workers 接收到。\x3c\/p\x3e\n\x3cp\x3e其次，为什么要手动维护这个队列，原因可能取决于如下几点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e业务原因，前面的 \x3ccode\x3epostMessage\x3c\/code\x3e 还没来得及消费，就不要发送新的消息，或者丢弃新的消息，这时候需要通过双向通信拿到 Web Workers 的执行结果回执，手动控制队列。\x3c\/li\x3e\n\x3cli\x3e性能原因，一般 Web Workers 都会被用来执行耗时的同步运算，如果运算时间比较长，那短期塞入多个消息队列是没有意义的。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016756470\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016756470\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如上图所示，对于每次用户输入都要进行的 SQL Parser 很耗时，及时放在 Web Workers 也可能导致将 Workers 撑爆到无响应，这是不仅要使用多 Workers 缓冲池，还要对待执行队列进行过滤，因为用户永远只关心最后一次输入的 Parser 结果。\x3c\/p\x3e\n\x3cp\x3e由于 Web Workers 运算被卡住时，除了销毁 Worker 没有别的办法，而销毁 Worker 的成本比较高，不能对每一个用户输入都销毁并新建 Web Workers，所以利用 Workers 缓冲池，当缓冲池满了，新的消费队列又进来的时候，可以销毁全部 Workers 缓冲池，换一批新缓冲池重新消费用户输入。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e4 总结\x3c\/h2\x3e\n\x3cp\x3eWeb Workers 是拆解异步计算的好帮手，vscode 网页版也通过 Web Workers 异步完成代码提示和高亮，笔者有对比过，发现 Web Workers 性能提升非常明显。\x3c\/p\x3e\n\x3cp\x3e管理好你的 Web Workers 消息队列，谨防同步计算让 Web Workers 失去响应！建立一个智能的消息队列，根据业务需求设计一个最好的队列消费模型吧！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e5 更多讨论\x3c\/h2\x3e\n\x3cblockquote\x3e讨论地址是：\x3ca href=\x22https:\/\/github.com\/dt-fe\/weekly\/issues\/108\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e精读《谈谈 Web Workers》 · Issue #108 · dt-fe\/weekly\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e如果你想参与讨论，请\x3ca href=\x22https:\/\/github.com\/dt-fe\/weekly\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点击这里\x3c\/a\x3e，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。\x3c\/strong\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>精读《谈谈 Web Workers》</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016756466">https://segmentfault.com/a/1190000016756466</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/h27jxfgofh6/" target="_blank">https://alili.tech/archive/h27jxfgofh6/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/3xwbcv1w21i/">前端微服务化进阶2 - 本地开发指南<aside class="dates">2019-04-22</aside></a></li><li><a href="/archive/9xuojm75d2a/">前端微服务化进阶1 - 基于umi的子模块方案<aside class="dates">2019-04-13</aside></a></li><li><a href="/archive/ol9qis0n8xe/">2019年04月Github Javascript开源项目精选<aside class="dates">2019-04-08</aside></a></li><li><a href="/archive/7815p445rtf/">记一次MongoDB迁移 - 备份与恢复<aside class="dates">2019-03-27</aside></a></li><li><a href="/archive/a5ficy1jp7n/">2019年03月Github Javascript开源项目精选<aside class="dates">2019-03-08</aside></a></li><li><a href="/archive/nyhmtbanv2e/">Alili Weekly 前端周刊 第二十一期<aside class="dates">2019-03-08</aside></a></li><li><a href="/archive/304a32r2py8/">30分钟精通React今年最劲爆的新特性——React Hooks<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/sj4oqgzx0rk/">CSS6：flex布局<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/wedm7eypuhb/">ES6 系列之 Babel 将 Async 编译成了什么样子<aside class="dates">2019-03-02</aside></a></li><li><a href="/archive/cazifdrck0u/">ES6 系列之我们来聊聊 Async<aside class="dates">2019-03-02</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>