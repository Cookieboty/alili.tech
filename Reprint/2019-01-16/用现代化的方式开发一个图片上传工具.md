---
title: '用现代化的方式开发一个图片上传工具' 
date: 2019-01-16 2:30:08
hidden: true
slug: ighps7ts2as
categories: [reprint]
---

{{< raw >}}

                    
<p>对于图片上传，大家一定不陌生。最近工作中遇到了关于图片上传的内容，借此机会认真研究了一番，遂一发不可收拾，最后琢磨了一个东西出来。在开发的过程中有不少的体会，于是打算写一篇文章分享一下心得体会。<br>本文将会以这个名为<code>Dolu</code>的项目为例子，一步步介绍我是如何进行环境搭建、代码设计以及实际开发的。内容较多，还请耐心读完。</p>
<p>项目地址：<a href="https://github.com/jrainlau/dolu" rel="nofollow noreferrer" target="_blank">https://github.com/jrainlau/dolu</a></p>
<h1 id="articleHeader0">一、环境搭建</h1>
<p>本项目使用目前最新的<code>webpack 2</code>和<code>es7</code>进行开发，所以环境的搭建必不可少。但是由于这个项目比较简单，所以环境的搭建也是非常简单的，只有一个<code>webpack.config.js</code>文件:</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var path = require('path')
var webpack = require('webpack')

module.exports = {
  entry: './src/main.js', // 开发模式用
  // entry: './src/dolu.js', // 生产模式用
  output: {
    path: path.resolve(__dirname, './dist'),
    publicPath: '/dist/',
    filename: 'build.js',  // 开发模式用
    // filename: 'index.js',  // 生产模式用
    libraryTarget: 'umd'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules|dist/,
        use: [
          'babel-loader',
          'eslint-loader'
        ]
      }
    ]
  },
  devServer: {
    historyApiFallback: true,
    noInfo: true,
    host: '0.0.0.0'
  },
  performance: {
    hints: false
  },
  devtool: '#eval-source-map'
}

if (process.env.NODE_ENV === 'production') {
  module.exports.devtool = '#source-map'
  module.exports.plugins = (module.exports.plugins || []).concat([
    new webpack.DefinePlugin({
      'process.env': {
        NODE_ENV: '&quot;production&quot;'
      }
    }),
    new webpack.optimize.UglifyJsPlugin({
      sourceMap: true,
      compress: {
        warnings: false
      }
    }),
    new webpack.LoaderOptionsPlugin({
      minimize: true
    })
  ])
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs typescript"><code><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)

<span class="hljs-built_in">module</span>.exports = {
  entry: <span class="hljs-string">'./src/main.js'</span>, <span class="hljs-comment">// 开发模式用</span>
  <span class="hljs-comment">// entry: './src/dolu.js', // 生产模式用</span>
  output: {
    path: path.resolve(__dirname, <span class="hljs-string">'./dist'</span>),
    publicPath: <span class="hljs-string">'/dist/'</span>,
    filename: <span class="hljs-string">'build.js'</span>,  <span class="hljs-comment">// 开发模式用</span>
    <span class="hljs-comment">// filename: 'index.js',  // 生产模式用</span>
    libraryTarget: <span class="hljs-string">'umd'</span>
  },
  <span class="hljs-keyword">module</span>: {
    rules: [
      {
        test: <span class="hljs-regexp">/\.js$/</span>,
        exclude: <span class="hljs-regexp">/node_modules|dist/</span>,
        use: [
          <span class="hljs-string">'babel-loader'</span>,
          <span class="hljs-string">'eslint-loader'</span>
        ]
      }
    ]
  },
  devServer: {
    historyApiFallback: <span class="hljs-literal">true</span>,
    noInfo: <span class="hljs-literal">true</span>,
    host: <span class="hljs-string">'0.0.0.0'</span>
  },
  performance: {
    hints: <span class="hljs-literal">false</span>
  },
  devtool: <span class="hljs-string">'#eval-source-map'</span>
}

<span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) {
  <span class="hljs-built_in">module</span>.exports.devtool = <span class="hljs-string">'#source-map'</span>
  <span class="hljs-built_in">module</span>.exports.plugins = (<span class="hljs-built_in">module</span>.exports.plugins || []).concat([
    <span class="hljs-keyword">new</span> webpack.DefinePlugin({
      <span class="hljs-string">'process.env'</span>: {
        NODE_ENV: <span class="hljs-string">'"production"'</span>
      }
    }),
    <span class="hljs-keyword">new</span> webpack.optimize.UglifyJsPlugin({
      sourceMap: <span class="hljs-literal">true</span>,
      compress: {
        warnings: <span class="hljs-literal">false</span>
      }
    }),
    <span class="hljs-keyword">new</span> webpack.LoaderOptionsPlugin({
      minimize: <span class="hljs-literal">true</span>
    })
  ])
}</code></pre>
<p>考虑到“生产模式”使用的次数不多，所以并没有区分<code>dev</code>和<code>prod</code>模式，而是手动注释对应的内容进行切换。</p>
<p>定义好入口文件和输出路径后，我使用了<code>babel-loader</code>和<code>eslint-loader</code>。这两个loader的作用就不多作介绍了，值得注意的是养成使用<code>eslint</code>的习惯是极好的，能够有效减少代码的错误，并且能够改掉很多坏习惯。同时在编辑器里（我用VSCODE）中也能够实时进行代码检查，非常方便。</p>
<p>为了使用最新的<code>es7</code>，我们也需要在根目录下配置一份<code>.babelrc</code>文件：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="{
  &quot;presets&quot;: [
    [&quot;latest&quot;, {
      &quot;es2015&quot;: { &quot;modules&quot;: false }
    }]
  ],
  &quot;plugins&quot;: [
    [&quot;transform-runtime&quot;]
  ]
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs json"><code>{
  <span class="hljs-attr">"presets"</span>: [
    [<span class="hljs-string">"latest"</span>, {
      <span class="hljs-attr">"es2015"</span>: { <span class="hljs-attr">"modules"</span>: <span class="hljs-literal">false</span> }
    }]
  ],
  <span class="hljs-attr">"plugins"</span>: [
    [<span class="hljs-string">"transform-runtime"</span>]
  ]
}</code></pre>
<p>配置好了<code>webpack.config.js</code>和<code>.babelrc</code>以后，我们打开<code>package.json</code>，来看看需要安装的依赖都有哪些：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  &quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.24.0&quot;,
    &quot;babel-loader&quot;: &quot;^6.4.1&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;,
    &quot;babel-polyfill&quot;: &quot;^6.23.0&quot;,
    &quot;babel-preset-latest&quot;: &quot;^6.24.0&quot;,
    &quot;cors&quot;: &quot;^2.8.3&quot;,
    &quot;cross-env&quot;: &quot;^3.2.4&quot;,
    &quot;eslint&quot;: &quot;^3.19.0&quot;,
    &quot;eslint-config-standard&quot;: &quot;^10.2.1&quot;,
    &quot;eslint-loader&quot;: &quot;^1.7.1&quot;,
    &quot;eslint-plugin-import&quot;: &quot;^2.2.0&quot;,
    &quot;eslint-plugin-node&quot;: &quot;^4.2.2&quot;,
    &quot;eslint-plugin-promise&quot;: &quot;^3.5.0&quot;,
    &quot;eslint-plugin-standard&quot;: &quot;^3.0.1&quot;,
    &quot;multer&quot;: &quot;^1.3.0&quot;,
    &quot;webpack&quot;: &quot;^2.3.1&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.4.2&quot;
  }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xquery"><code>  <span class="hljs-string">"devDependencies"</span>: {
    <span class="hljs-string">"babel-core"</span>: <span class="hljs-string">"^6.24.0"</span>,
    <span class="hljs-string">"babel-loader"</span>: <span class="hljs-string">"^6.4.1"</span>,
    <span class="hljs-string">"babel-plugin-transform-runtime"</span>: <span class="hljs-string">"^6.23.0"</span>,
    <span class="hljs-string">"babel-polyfill"</span>: <span class="hljs-string">"^6.23.0"</span>,
    <span class="hljs-string">"babel-preset-latest"</span>: <span class="hljs-string">"^6.24.0"</span>,
    <span class="hljs-string">"cors"</span>: <span class="hljs-string">"^2.8.3"</span>,
    <span class="hljs-string">"cross-env"</span>: <span class="hljs-string">"^3.2.4"</span>,
    <span class="hljs-string">"eslint"</span>: <span class="hljs-string">"^3.19.0"</span>,
    <span class="hljs-string">"eslint-config-standard"</span>: <span class="hljs-string">"^10.2.1"</span>,
    <span class="hljs-string">"eslint-loader"</span>: <span class="hljs-string">"^1.7.1"</span>,
    <span class="hljs-string">"eslint-plugin-import"</span>: <span class="hljs-string">"^2.2.0"</span>,
    <span class="hljs-string">"eslint-plugin-node"</span>: <span class="hljs-string">"^4.2.2"</span>,
    <span class="hljs-string">"eslint-plugin-promise"</span>: <span class="hljs-string">"^3.5.0"</span>,
    <span class="hljs-string">"eslint-plugin-standard"</span>: <span class="hljs-string">"^3.0.1"</span>,
    <span class="hljs-string">"multer"</span>: <span class="hljs-string">"^1.3.0"</span>,
    <span class="hljs-string">"webpack"</span>: <span class="hljs-string">"^2.3.1"</span>,
    <span class="hljs-string">"webpack-dev-server"</span>: <span class="hljs-string">"^2.4.2"</span>
  }</code></pre>
<p>当中的<code>cors</code>模块和<code>multer</code>模块为我们之后搭建node服务器需要用的，其他都是运行所需。</p>
<p>然后在"scripts"里面写上我们要用到的几条命令：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --hot&quot;,
    &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --progress --hide-modules&quot;,
    &quot;server&quot;: &quot;node ./server/index.js&quot;
  }," title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xquery"><code>  <span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"dev"</span>: <span class="hljs-string">"cross-env NODE_ENV=development webpack-dev-server --hot"</span>,
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"cross-env NODE_ENV=production webpack --progress --hide-modules"</span>,
    <span class="hljs-string">"server"</span>: <span class="hljs-string">"node ./server/index.js"</span>
  },</code></pre>
<p>分别对应<code>开发模式</code>，<code>生产模式</code>，<code>启动本地后台服务器</code>。</p>
<p>然后我们在根目录下新建一个<code>src</code>目录，一个<code>index.html</code>，一个<code>/src/main.js</code>。这时候整个项目的目录结构如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="├── index.html
├── package.json
├── src
│&nbsp;&nbsp; └── main.js
├── webpack.config.js
└── .babelrc" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code>├── index<span class="hljs-selector-class">.html</span>
├── package<span class="hljs-selector-class">.json</span>
├── src
│&nbsp;&nbsp; └── main<span class="hljs-selector-class">.js</span>
├── webpack<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>
└── .babelrc</code></pre>
<p>至此，我们的开发环境已经搭建完毕。</p>
<h1 id="articleHeader1">二、功能设计</h1>
<p><span class="img-wrap"><img data-src="/img/bVMk8P?w=318&amp;h=452" src="https://static.alili.tech/img/bVMk8P?w=318&amp;h=452" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>基本的流程及功能如上图所示，其中的每一步我们都将以模块的方式进行开发。</p>
<p>当然，我们不能满足于这么一点点的功能，我们需要考虑更多的情况更多的可能，扩展一下，也许我们可以这么做：</p>
<p><span class="img-wrap"><img data-src="/img/bVMlaN?w=819&amp;h=806" src="https://static.alili.tech/img/bVMlaN?w=819&amp;h=806" alt="clipboard.png" title="clipboard.png" style="cursor: pointer; display: inline;"></span></p>
<p>比如我们在获取图片之后先不进行上传，也许我们还要对转出来的<code>base64</code>进行处理或使用，也许我们能够直接上传一堆由第三方提供的<code>base64</code>甚至<code>formdata</code>。另外我们还需要对上传的方法进行自定义，又或者可以选择多张图片什么的……除此之外，可能还有许许多多的场景，为了开发一个通用的组件，我们需要思考的地方实在有很多很多。</p>
<p>当然，这一次我们的任务比较简单，上面这么多功能已经够我们玩的了，下面我们进入实际的开发。</p>
<h1 id="articleHeader2">三、开始coding！</h1>
<p>在<code>/src</code>目录下新建一个<code>dolu.js</code>文件，这将会是我们整个项目的核心。</p>
<p>首先定义一个类：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="class Dolulu {
  constructor (config = {}) {}
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dolulu</span> </span>{
  <span class="hljs-keyword">constructor</span> (config = {}) {}
}</code></pre>
<p>然后我们按照上一节脑图的思路，先完成“图片选取”相关的功能。</p>
<p>在这个类里面我们定义一个名为<code>_pickFile()</code>的私有方法，这个方法我们不希望被外部调用，只是作为<code>Dolu</code>内置的方法。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  _pickFile () {
    const picker = document.querySelector(this.config.picker)

    picker.addEventListener('change', () => {
      if (!picker.files.length) {
        return
      }
      const files = [...picker.files]

      if (files.length > this.config.quantity) {
        throw new Error('Out of file quantity limit!')
      }

      /*
       * 这时候我们已经拿到了文件数组files，可以马上进行转码
       * _transformer()函数是另一个私有方法，用于格式转码
       */
      this._transformer(files)
      
      /*
       * 加入这一行以实现重复选中同一张图片
       */
      picker.value = null
    })
  }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code>  _pickFile () {
    const picker = document.querySelector(this<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.picker</span>)

    picker.addEventListener(<span class="hljs-string">'change'</span>, () =&gt; {
      <span class="hljs-keyword">if</span> (!picker<span class="hljs-selector-class">.files</span><span class="hljs-selector-class">.length</span>) {
        return
      }
      const files = [..<span class="hljs-selector-class">.picker</span><span class="hljs-selector-class">.files</span>]

      <span class="hljs-keyword">if</span> (files<span class="hljs-selector-class">.length</span> &gt; this<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.quantity</span>) {
        throw new Error(<span class="hljs-string">'Out of file quantity limit!'</span>)
      }

      <span class="hljs-comment">/*
       * 这时候我们已经拿到了文件数组files，可以马上进行转码
       * _transformer()函数是另一个私有方法，用于格式转码
       */</span>
      this._transformer(files)
      
      <span class="hljs-comment">/*
       * 加入这一行以实现重复选中同一张图片
       */</span>
      picker<span class="hljs-selector-class">.value</span> = null
    })
  }</code></pre>
<p>然后写一个初始化的方法，让<code>Dolu</code>实例能够自动开启文件选取功能：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  _init () {
    if (this.config.picker) {
      return this._pickFile()
    }
  }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code>  _init () {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.config.picker) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._pickFile()
    }
  }</code></pre>
<p>只要在<code>constructor</code>里面调用这个方法就可以了。</p>
<p>选择完图片，我们就要对它进行转码了。为了更好地组织我们的代码，我们把这个“图片转成base64”的函数封装成一个模块。在<code>/src</code>目录下新建<code>fileToBase64.js</code>：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const fileToBase64 = (file) => {
  const reader = new FileReader()

  reader.readAsDataURL(file)

  return new Promise((resolve) => {
    reader.addEventListener('load', () => {
      const result = reader.result
      resolve(result)
    })
  })
}

export default fileToBase64
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs typescript"><code><span class="hljs-keyword">const</span> fileToBase64 = <span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader()

  reader.readAsDataURL(file)

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    reader.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> result = reader.result
      resolve(result)
    })
  })
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> fileToBase64
</code></pre>
<p>代码内容只有15行，其输入为一个图片文件，输出为一串base64编码。返回一个Promise方便接下来我们使用<code>async/await</code>语法。</p>
<p>同样的道理，我们新建一个<code>base64ToBlob.js</code>文件，以实现输入为base64，输出为formdata的功能：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const base64ToBlob = (base64) => {
  const byteString = atob(base64.split(',')[1])
  const mimeString = base64.split(',')[0].split(':')[1].split(';')[0]
  const ab = new ArrayBuffer(byteString.length)
  const ia = new Uint8Array(ab)
  for (let i = 0, len = byteString.length; i < len; i += 1) {
    ia[i] = byteString.charCodeAt(i)
  }

  let Builder = window.WebKitBlobBuilder || window.MozBlobBuilder
  let blobUrl

  if (Builder) {
    const builder = new Builder()
    builder.append(ab)
    blobUrl = builder.getBlob(mimeString)
  } else {
    blobUrl = new window.Blob([ab], { type: mimeString })
  }

  const fd = new FormData()
  fd.append('file', blobUrl)

  return fd
}

export default base64ToBlob
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs typescript"><code><span class="hljs-keyword">const</span> base64ToBlob = <span class="hljs-function">(<span class="hljs-params">base64</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> byteString = atob(base64.split(<span class="hljs-string">','</span>)[<span class="hljs-number">1</span>])
  <span class="hljs-keyword">const</span> mimeString = base64.split(<span class="hljs-string">','</span>)[<span class="hljs-number">0</span>].split(<span class="hljs-string">':'</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">';'</span>)[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">const</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(byteString.length)
  <span class="hljs-keyword">const</span> ia = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(ab)
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = byteString.length; i &lt; len; i += <span class="hljs-number">1</span>) {
    ia[i] = byteString.charCodeAt(i)
  }

  <span class="hljs-keyword">let</span> Builder = <span class="hljs-built_in">window</span>.WebKitBlobBuilder || <span class="hljs-built_in">window</span>.MozBlobBuilder
  <span class="hljs-keyword">let</span> blobUrl

  <span class="hljs-keyword">if</span> (Builder) {
    <span class="hljs-keyword">const</span> builder = <span class="hljs-keyword">new</span> Builder()
    builder.append(ab)
    blobUrl = builder.getBlob(mimeString)
  } <span class="hljs-keyword">else</span> {
    blobUrl = <span class="hljs-keyword">new</span> <span class="hljs-built_in">window</span>.Blob([ab], { <span class="hljs-keyword">type</span>: mimeString })
  }

  <span class="hljs-keyword">const</span> fd = <span class="hljs-keyword">new</span> FormData()
  fd.append(<span class="hljs-string">'file'</span>, blobUrl)

  <span class="hljs-keyword">return</span> fd
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> base64ToBlob
</code></pre>
<p>接下来我们利用这两个模块，构建我们的<code>_transformer()</code>方法：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  _transformer (files, manually = false) {
    files.forEach(async (file, index) => {
      if (isObject(file)) {
        if (!/\/(?:jpeg|png|gif)/i.test(file.type)) {
          return
        }

        const dataUrl = await fileToBase64(file)
        const formData = await base64ToBlob(dataUrl)

        if (this.config.autoSend || manually) {
          this._uploader(formData, index)
        }
      }
    })" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs dart"><code>  _transformer (files, manually = <span class="hljs-keyword">false</span>) {
    files.forEach(<span class="hljs-keyword">async</span> (file, index) =&gt; {
      <span class="hljs-keyword">if</span> (isObject(file)) {
        <span class="hljs-keyword">if</span> (!/\/(?:jpeg|png|gif)/i.test(file.type)) {
          <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">const</span> dataUrl = <span class="hljs-keyword">await</span> fileToBase64(file)
        <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">await</span> base64ToBlob(dataUrl)

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.config.autoSend || manually) {
          <span class="hljs-keyword">this</span>._uploader(formData, index)
        }
      }
    })</code></pre>
<p>可以看到，这个方法会遍历整个files数组，通过筛选保证其文件类型为图片，然后连续转码生成formdata格式数据，作为参数传入<code>_uploader()</code>方法中。另外为了方便扩展和使用，同时传入了图片的下标。图片的下标能够方便在上传函数中让用户知道“现在是第几张图片被处理”。</p>
<p><code>_upload()</code>函数将会直接调用<code>Dolu</code>实例中所定义的上传方法，这个稍后再述。</p>
<p>到这里，我们已经完成了上一节第一张图片的几个“基本功能”了，和外面一捞一大把的教程相差无几。别急，我们马上进入对扩展功能的开发。</p>
<h1 id="articleHeader3">四、实现向外输出完整的base64字符串数组</h1>
<p>我们重新把目光投向上一节的<code>_transformer()</code>函数。这个函数接受一个<strong>数组</strong>，在内部使用<code>.forEach()</code>方法遍历每一个文件，对它进行转码处理。为了向外输出完整的转码后的数组，关键的步骤在于如何确定转码已经完成了。从最简单的想法开始，在<code>forEach</code>循环体的外部直接把数组抛出去行不行？比如这样：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  _transformer (files, manually = false) {
    files.forEach(async (file, index) => {
      if (isObject(file)) {
        if (!/\/(?:jpeg|png|gif)/i.test(file.type)) {
          return
        }

        const dataUrl = await fileToBase64(file)
        const formData = await base64ToBlob(dataUrl)

        this.dataUrlArr.push(dataUrl)

        if (this.config.autoSend || manually) {
          this._uploader(formData, index)
        }
      }
    })

    this.config.getDataUrls(this.dataUrlArr)

    return this
  }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code>  _transformer (files, manually = <span class="hljs-literal">false</span>) {
    files.forEach(async (file, index) =&gt; {
      <span class="hljs-keyword">if</span> (isObject(file)) {
        <span class="hljs-keyword">if</span> (!/\/(?:jpeg|png|gif)/i.test(file.type)) {
          <span class="hljs-keyword">return</span>
        }

        const dataUrl = await fileToBase64(file)
        const formData = await base64ToBlob(dataUrl)

        <span class="hljs-keyword">this</span>.dataUrlArr.push(dataUrl)

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.config.autoSend || manually) {
          <span class="hljs-keyword">this</span>._uploader(formData, index)
        }
      }
    })

    <span class="hljs-keyword">this</span>.config.getDataUrls(<span class="hljs-keyword">this</span>.dataUrlArr)

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }</code></pre>
<p>看起来没有问题，但是在实际的测试中，传入<code>this.config.getDataUrls</code>中的<code>dataUrlArr</code>首先会是一个空数组，过一会儿才会有数据。为了验证这个结论，我们在<code>/src</code>名录下新建一个文件<code>main.js</code>，写入如下内容：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="import Dolu from './dolu'

const dolu = new Dolu({
  picker: '#picker',
  getDataUrls (arr) {
    console.info(arr)
    arr.forEach((dataUrl) => {
      console.log(dataUrl)
    })
  }
})
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs coffeescript"><code><span class="hljs-keyword">import</span> Dolu <span class="hljs-keyword">from</span> <span class="hljs-string">'./dolu'</span>

const dolu = <span class="hljs-keyword">new</span> Dolu({
  picker: <span class="hljs-string">'#picker'</span>,
  getDataUrls (arr) {
    <span class="hljs-built_in">console</span>.info(arr)
    arr.forEach(<span class="hljs-function"><span class="hljs-params">(dataUrl)</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(dataUrl)
    })
  }
})
</code></pre>
<p>运行一下，发现输出结果如下：</p>
<p><span class="img-wrap"><img data-src="/img/bVMl7O?w=570&amp;h=106" src="https://static.alili.tech/img/bVMl7O?w=570&amp;h=106" alt="clipboard.png" title="clipboard.png" style="cursor: pointer; display: inline;"></span></p>
<p>只有一个空数组，而且<code>forEach()</code>循环并没有打印出任何东西。这个例子不直观，我们现在把开发者工具关掉，然后重新打开，看看会发生什么：</p>
<p><span class="img-wrap"><img data-src="/img/bVMl8p?w=442&amp;h=126" src="https://static.alili.tech/img/bVMl8p?w=442&amp;h=126" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>仅仅是重新打开开发者工具，就发现刚才的空数组变成了一个有内容的数组，特别奇怪。</p>
<p>其实原因也很简单，因为<code>_transformer()</code>内部的<code>forEach()</code>循环，并不能保证图片已经转码完毕，这涉及到浏览器任务队列的知识（此处理解可能有误，欢迎指出），在这里就不展开讨论了。</p>
<p>那么我们只能<strong>等待</strong>图片转码完毕，才调用<code>this.config.getDataUrls()</code>方法。要实现这个目的，我们有许多种方法，最简单粗暴的就是利用<code>setInterval()</code>进行轮询，当<code>dataUrlArr.length === files.length</code>，则立即调用，但是这种做法一点儿也不优雅。我们能不能让函数发送一个<strong>通知</strong>，当<code>.push()</code>方法执行并成功的时候就判断<code>dataUrlArr.length =?= files.length</code>，若条件符合则进行相应的处理。</p>
<p>这时候我们可以考虑使用es6新增语法<code>Proxy</code>来解决。关于<code>Proxy</code>的使用可以查阅我的另外一篇文章<br><a href="https://segmentfault.com/a/1190000007443611">《使用ES6的新特性Proxy来实现一个数据绑定实例》</a>，然后我们一起来步入正题吧！</p>
<h1 id="articleHeader4">五、使用<code>Proxy</code>实现数据绑定</h1>
<p>在<code>/src</code>目录下的<code>utils.js</code>里，我们加入一个新的工具方法：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function proxier (props, callback) {
  const waitProxy = new Proxy(props, {
    set (target, property, value) {
      target[property] = value
      callback(target, property, value)
      return true
    }
  })
  return waitProxy
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs qml"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxier</span> (<span class="hljs-params">props, callback</span>) </span>{
  <span class="hljs-keyword">const</span> waitProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(props, {
    set (target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, value) {
      target[<span class="hljs-keyword">property</span><span class="hljs-string">] </span>= value
      callback(target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, value)
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
  })
  <span class="hljs-keyword">return</span> waitProxy
}</code></pre>
<p>回到<code>dolu.js</code>文件，改写一下<code>_transformer()</code>方法：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  _transformer (files, manually = false) {
    const dataUrlArrProxy = proxier(this.dataUrlArr, (target, property, value) => {
      if (property === 'length') {
        if (target.length === files.length) {
          this.config.getDataUrls(this.dataUrlArr)
        }
      }
    })

    files.forEach(async (file, index) => {
      if (isObject(file)) {
        if (!/\/(?:jpeg|png|gif)/i.test(file.type)) {
          return
        }

        const dataUrl = await fileToBase64(file)
        const formData = await base64ToBlob(dataUrl)

        dataUrlArrProxy.push(dataUrl)

        if (this.config.autoSend || manually) {
          this._uploader(formData, index)
        }
      }
    })

    return this
  }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs qml"><code>  _transformer (files, manually = <span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">const</span> dataUrlArrProxy = proxier(<span class="hljs-keyword">this</span>.dataUrlArr, (target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, value) =&gt; {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">property</span><span class="hljs-string"> </span>=== <span class="hljs-string">'length'</span>) {
        <span class="hljs-keyword">if</span> (target.length === files.length) {
          <span class="hljs-keyword">this</span>.config.getDataUrls(<span class="hljs-keyword">this</span>.dataUrlArr)
        }
      }
    })

    files.forEach(<span class="hljs-keyword">async</span> (file, index) =&gt; {
      <span class="hljs-keyword">if</span> (isObject(file)) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/\/(?:jpeg|png|gif)/i</span>.test(file.type)) {
          <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">const</span> dataUrl = <span class="hljs-keyword">await</span> fileToBase64(file)
        <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">await</span> base64ToBlob(dataUrl)

        dataUrlArrProxy.push(dataUrl)

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.config.autoSend || manually) {
          <span class="hljs-keyword">this</span>._uploader(formData, index)
        }
      }
    })

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }</code></pre>
<p>这样，我们每一次转码过后，都会调用<strong>代理数组</strong><code>dataUrlArrProxy</code>中的<code>.push()</code>方法，这时候代理数组就会自动判断<code>target.length =?= files.length</code>然后调用相应的方法。</p>
<p>尝试运行一下，发现结果符合预期。同样的方式，我们可以为<code>formDataArr</code>也设置一个代理数组，以实现向外抛出<code>formdata</code>数组的目的。</p>
<h1 id="articleHeader5">六、服务器搭建</h1>
<p>把前端这边的图片选取、图片转码都已经做完了，那么我们是时候搭建一个后台服务器，去测试以<code>formdata</code>格式上传图片是否有效了。</p>
<p>进入根目录下的<code>/server</code>文件夹，我们新建一个<code>/imgs</code>目录以及一个<code>index.js</code>文件，内容如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const express = require('express')
const multer = require('multer')
const cors = require('cors')

const app = express()
app.use(express.static('./public'))
app.use(cors())

app.listen(process.env.PORT || 8888)
console.log('Node.js Ajax Upload File running at: http://0.0.0.0:8888')

app.post('/upload', (req, res) => {
  const store = multer.diskStorage({
    destination: './server/imgs'
  })
  const upload = multer({
    storage: store
  }).any()

  upload(req, res, function (err) {
    if (err) {
      console.log(err)
      return res.end('Error')
    } else {
      console.log(req.body)
      req.files.forEach(function (item) {
        console.log(item)
      })
      res.end('File uploaded')
    }
  })
})
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs php"><code><span class="hljs-keyword">const</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">'express'</span>)
<span class="hljs-keyword">const</span> multer = <span class="hljs-keyword">require</span>(<span class="hljs-string">'multer'</span>)
<span class="hljs-keyword">const</span> cors = <span class="hljs-keyword">require</span>(<span class="hljs-string">'cors'</span>)

<span class="hljs-keyword">const</span> app = express()
app.<span class="hljs-keyword">use</span>(express.<span class="hljs-keyword">static</span>(<span class="hljs-string">'./public'</span>))
app.<span class="hljs-keyword">use</span>(cors())

app.listen(process.env.PORT || <span class="hljs-number">8888</span>)
console.log(<span class="hljs-string">'Node.js Ajax Upload File running at: http://0.0.0.0:8888'</span>)

app.post(<span class="hljs-string">'/upload'</span>, (req, res) =&gt; {
  <span class="hljs-keyword">const</span> store = multer.diskStorage({
    destination: <span class="hljs-string">'./server/imgs'</span>
  })
  <span class="hljs-keyword">const</span> upload = multer({
    storage: store
  }).any()

  upload(req, res, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-keyword">if</span> (err) {
      console.log(err)
      <span class="hljs-keyword">return</span> res.end(<span class="hljs-string">'Error'</span>)
    } <span class="hljs-keyword">else</span> {
      console.log(req.body)
      req.files.<span class="hljs-keyword">forEach</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(item)</span> </span>{
        console.log(item)
      })
      res.end(<span class="hljs-string">'File uploaded'</span>)
    }
  })
})
</code></pre>
<p>该服务器将会运行于本地<code>8888</code>端口，通过<code>post</code>方法发送到<code>localhost:8888/upload</code>，然后图片会保存到<code>server/imgs</code>目录下。</p>
<p>回到<code>dolu.js</code>，我们写一个<code>_uploader()</code>方法，该方法会调用<code>config</code>里面的自定义设置，调用设置中具体的上传方法：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  _uploader (formData, index) {
    this.config.uploader(formData, index)
  }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs axapta"><code>  _uploader (formData, <span class="hljs-keyword">index</span>) {
    <span class="hljs-keyword">this</span>.config.uploader(formData, <span class="hljs-keyword">index</span>)
  }</code></pre>
<p>在<code>main.js</code>中，我们使用<code>axios</code>作为上传的工具：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const dolu = new Dolu({
  picker: '#picker',
  autoSend: true,
  uploader (data, index) {
    axios({
      method: 'post',
      url: 'http://0.0.0.0:8888/upload',
      data: data,
      onUploadProgress: (e) => {
        const percent = Math.round((e.loaded * 100) / e.total)
        console.log(percent, index)
      }
    }).then((res) => {
      console.log(res)
    }).catch((err) => {
      console.log(err)
    })
  }
})" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs coffeescript"><code>const dolu = <span class="hljs-keyword">new</span> Dolu({
  picker: <span class="hljs-string">'#picker'</span>,
  autoSend: <span class="hljs-literal">true</span>,
  uploader (data, index) {
    axios({
      method: <span class="hljs-string">'post'</span>,
      url: <span class="hljs-string">'http://0.0.0.0:8888/upload'</span>,
      data: data,
      onUploadProgress: <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> {
        const percent = Math.round((e.loaded * <span class="hljs-number">100</span>) / e.total)
        <span class="hljs-built_in">console</span>.log(percent, index)
      }
    }).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(res)
    }).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(err)
    })
  }
})</code></pre>
<p>激动人心的时刻来了，我们来测试一下吧！</p>
<h1 id="articleHeader6">七、实际运行测试</h1>
<p>打开开发者工具当中的<code>Network</code>，随便选几张图片进行上传，看看效果如何：</p>
<p><span class="img-wrap"><img data-src="/img/bVMmml?w=411&amp;h=246" src="https://static.alili.tech/img/bVMmml?w=411&amp;h=246" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p><span class="img-wrap"><img data-src="/img/bVMmmA?w=597&amp;h=71" src="https://static.alili.tech/img/bVMmmA?w=597&amp;h=71" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>点击去看看发送的是什么东西：</p>
<p><span class="img-wrap"><img data-src="/img/bVMmmO?w=476&amp;h=126" src="https://static.alili.tech/img/bVMmmO?w=476&amp;h=126" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>如上图所示，是一个formdata数据。打开<code>./server/imgs</code>目录，我们应该就能看到三个文件了：</p>
<p><span class="img-wrap"><img data-src="/img/bVMmnC?w=1684&amp;h=726" src="https://static.alili.tech/img/bVMmnC?w=1684&amp;h=726" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p><span class="img-wrap"><img data-src="/img/bVMmn8?w=1146&amp;h=164" src="https://static.alili.tech/img/bVMmn8?w=1146&amp;h=164" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>上传成功！而且符合我们以“formdata上传的二进制格式”的需求。</p>
<h1 id="articleHeader7">八、后续工作</h1>
<p>至此已经基本完成了我们整个图片上传组件，还有几个细节需要注意，比如所发送图片的命名、对图片通过canvas进行压缩等等，这些坑以后有空再填。比较完善的代码可以直接查看<a href="https://github.com/jrainlau/dolu" rel="nofollow noreferrer" target="_blank">我的仓库</a>。</p>
<p>感谢您的阅读，欢迎对文章内容提出批评指导建议！</p>
<hr>
<p>参考资料：</p>
<ol>
<li><p><a href="http://www.cnblogs.com/axes/p/4603984.html" rel="nofollow noreferrer" target="_blank">移动前端—图片压缩上传实践</a></p></li>
<li><p><a href="http://www.tych.io/tech/2013/08/21/html5-upload-file.html" rel="nofollow noreferrer" target="_blank">HTML5实现图片上传</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/4109276/how-to-detect-input-type-file-change-for-the-same-file" rel="nofollow noreferrer" target="_blank">How to detect input type=file “change” for the same file?</a></p></li>
</ol>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
用现代化的方式开发一个图片上传工具

## 原文链接
[https://segmentfault.com/a/1190000009103723](https://segmentfault.com/a/1190000009103723)

