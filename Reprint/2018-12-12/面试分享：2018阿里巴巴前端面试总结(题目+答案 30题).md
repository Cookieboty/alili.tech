---
title: '面试分享：2018阿里巴巴前端面试总结(题目+答案 30题)' 
date: 2018-12-12 2:30:10
hidden: true
slug: b0ar37d5rc9
categories: [reprint]
---

{{< raw >}}

                    
<p><strong>1、使用css实现一个持续的动画效果</strong><br>————————————————————————————————————————————————————————</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="animation:mymove 5s infinite;

@keyframes mymove {

    from {top:0px;}
    
    to {top:200px;}

}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-tag">animation</span><span class="hljs-selector-pseudo">:mymove</span> 5<span class="hljs-selector-tag">s</span> <span class="hljs-selector-tag">infinite</span>;

@<span class="hljs-keyword">keyframes</span> mymove {

    <span class="hljs-selector-tag">from</span> {<span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;}
    
    <span class="hljs-selector-tag">to</span> {<span class="hljs-attribute">top</span>:<span class="hljs-number">200px</span>;}

}
</code></pre>
<p>主要考： animation 用法</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="值    描述
animation-name    规定需要绑定到选择器的 keyframe 名称。
animation-duration    规定完成动画所花费的时间，以秒或毫秒计。
animation-timing-function    规定动画的速度曲线。
animation-delay    规定在动画开始之前的延迟。
animation-iteration-count    规定动画应该播放的次数。
animation-direction    规定是否应该轮流反向播放动画。    " title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs maxima"><code>值    描述
<span class="hljs-built_in">animation</span>-name    规定需要绑定到选择器的 keyframe 名称。
<span class="hljs-built_in">animation</span>-duration    规定完成动画所花费的时间，以秒或毫秒计。
<span class="hljs-built_in">animation</span>-timing-function    规定动画的速度曲线。
<span class="hljs-built_in">animation</span>-<span class="hljs-built_in">delay</span>    规定在动画开始之前的延迟。
<span class="hljs-built_in">animation</span>-iteration-count    规定动画应该播放的次数。
<span class="hljs-built_in">animation</span>-direction    规定是否应该轮流反向播放动画。    </code></pre>
<p>————————————————————————————————————————————————————————<br><strong>2、使用js实现一个持续的动画效果</strong><br>最开始的思路是用定时器实现，最后没有想的太完整，面试官给出的答案是用 requestAnimationFrame。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="    var e = document.getElementById('e')
    
    var falg = true;
    
    var left = 0;
    
    setInterval(() => {
    
        left == 0 ? falg = true : left == 100 ? falg = false : ''
    
        falg ? e.style.left = ` ${left++}px` : e.style.left = ` ${left--}px`
    
    }, 1000 / 60)
    
requestAnimationFrame 由于之前没有用过这个 API 所以是现学的。
//兼容性处理

window.requestAnimFrame = (function(){

  return  window.requestAnimationFrame       ||

          window.webkitRequestAnimationFrame ||

          window.mozRequestAnimationFrame    ||

          function(callback){

            window.setTimeout(callback, 1000 / 60);

          };

})();


var e = document.getElementById(&quot;e&quot;);

var flag = true;

var left = 0;


function render() {

    left == 0 ? flag = true : left == 100 ? flag = false : '';

    flag ? e.style.left = ` ${left++}px` :

        e.style.left = ` ${left--}px`;

}


(function animloop() {

    render();

    requestAnimFrame(animloop);

})();
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code>    <span class="hljs-keyword">var</span> e = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'e'</span>)
    
    <span class="hljs-keyword">var</span> falg = <span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">var</span> left = <span class="hljs-number">0</span>;
    
    setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    
        left == <span class="hljs-number">0</span> ? falg = <span class="hljs-literal">true</span> : left == <span class="hljs-number">100</span> ? falg = <span class="hljs-literal">false</span> : <span class="hljs-string">''</span>
    
        falg ? e.style.left = <span class="hljs-string">` <span class="hljs-subst">${left++}</span>px`</span> : e.style.left = <span class="hljs-string">` <span class="hljs-subst">${left--}</span>px`</span>
    
    }, <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)
    
requestAnimationFrame 由于之前没有用过这个 API 所以是现学的。
<span class="hljs-comment">//兼容性处理</span>

<span class="hljs-built_in">window</span>.requestAnimFrame = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{

  <span class="hljs-keyword">return</span>  <span class="hljs-built_in">window</span>.requestAnimationFrame       ||

          <span class="hljs-built_in">window</span>.webkitRequestAnimationFrame ||

          <span class="hljs-built_in">window</span>.mozRequestAnimationFrame    ||

          <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)</span>{

            <span class="hljs-built_in">window</span>.setTimeout(callback, <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>);

          };

})();


<span class="hljs-keyword">var</span> e = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"e"</span>);

<span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;

<span class="hljs-keyword">var</span> left = <span class="hljs-number">0</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{

    left == <span class="hljs-number">0</span> ? flag = <span class="hljs-literal">true</span> : left == <span class="hljs-number">100</span> ? flag = <span class="hljs-literal">false</span> : <span class="hljs-string">''</span>;

    flag ? e.style.left = <span class="hljs-string">` <span class="hljs-subst">${left++}</span>px`</span> :

        e.style.left = <span class="hljs-string">` <span class="hljs-subst">${left--}</span>px`</span>;

}


(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animloop</span>(<span class="hljs-params"></span>) </span>{

    render();

    requestAnimFrame(animloop);

})();
</code></pre>
<p>不足之处请指正（毕竟是现学的）顺便查了一下优势：</p>
<p>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果</p>
<p>解决毫秒的不精确性</p>
<p>避免过度渲染（渲染频率太高、 tab 不可见暂停等等） 注： requestAnimFrame 和 定时器一样也头一个类似的清除方法cancelAnimationFrame。    <br>————————————————————————————————————————————————————————<br><strong>3、右边宽度固定，左边自适应</strong></p>
<p>第一种：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<style>

body{

    display: flex;

}

.left{

    background-color: rebeccapurple;

    height: 200px;

    flex: 1;

}

.right{

    background-color: red;

    height: 200px;

    width: 100px;

}

</style>

<body>

    <div class=&quot;left&quot;></div>

    <div class=&quot;right&quot;></div>

</body>
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">

<span class="hljs-selector-tag">body</span>{

    <span class="hljs-attribute">display</span>: flex;

}

<span class="hljs-selector-class">.left</span>{

    <span class="hljs-attribute">background-color</span>: rebeccapurple;

    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;

    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;

}

<span class="hljs-selector-class">.right</span>{

    <span class="hljs-attribute">background-color</span>: red;

    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;

    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;

}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>第二种</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<style>

    div {

        height: 200px;

    }

    .left {

        float: right;

        width: 200px;

        background-color: rebeccapurple;

    }

    .right {

        margin-right: 200px;

        background-color: red;

    }

</style>

<body>

    <div class=&quot;left&quot;></div>

    <div class=&quot;right&quot;></div>

</body>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">

    <span class="hljs-selector-tag">div</span> {

        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;

    }

    <span class="hljs-selector-class">.left</span> {

        <span class="hljs-attribute">float</span>: right;

        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;

        <span class="hljs-attribute">background-color</span>: rebeccapurple;

    }

    <span class="hljs-selector-class">.right</span> {

        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;

        <span class="hljs-attribute">background-color</span>: red;

    }

</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>————————————————————————————————————————————————————————<br><strong>4、水平垂直居中</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#container{

    position:relative;

}

#center{

    width:100px;

    height:100px;

    position:absolute;

    top:50%;

    left:50%;

    transform: translate(-50%,-50%);

}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-id">#container</span>{

    <span class="hljs-attribute">position</span>:relative;

}

<span class="hljs-selector-id">#center</span>{

    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;

    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;

    <span class="hljs-attribute">position</span>:absolute;

    <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;

    <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;

    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-50%,-50%);

}
</code></pre>
<p>第二种</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#container{

    position:relative;

}

#center{

    width:100px;

    height:100px;

    position:absolute;

    top:50%;

    left:50%;

    margin:-50px 0 0 -50px;

}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-id">#container</span>{

    <span class="hljs-attribute">position</span>:relative;

}

<span class="hljs-selector-id">#center</span>{

    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;

    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;

    <span class="hljs-attribute">position</span>:absolute;

    <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;

    <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;

    <span class="hljs-attribute">margin</span>:-<span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -<span class="hljs-number">50px</span>;

}
</code></pre>
<p>第三种</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#container{

    position:relative;

}


#center{

    position:absolute;

    margin:auto;

    top:0;

    bottom:0;

    left:0;

    right:0;

}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-id">#container</span>{

    <span class="hljs-attribute">position</span>:relative;

}


<span class="hljs-selector-id">#center</span>{

    <span class="hljs-attribute">position</span>:absolute;

    <span class="hljs-attribute">margin</span>:auto;

    <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;

    <span class="hljs-attribute">bottom</span>:<span class="hljs-number">0</span>;

    <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;

    <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;

}
</code></pre>
<p>第四种 flex</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#container{

    display:flex;

    justify-content:center;

    align-items: center;

}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-id">#container</span>{

    <span class="hljs-attribute">display</span>:flex;

    <span class="hljs-attribute">justify-content</span>:center;

    <span class="hljs-attribute">align-items</span>: center;

}</code></pre>
<p>————————————————————————————————————————————————————————    <br><strong>5、四种定位的区别</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="static 是默认值

relative 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中

absolute 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指 position不是 static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以 body元素为偏移参照基准, 完全脱离了标准文档流。

fixed 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs scss"><code>static 是默认值

relative 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中

absolute 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指 <span class="hljs-attribute">position</span>不是 static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以 <span class="hljs-selector-tag">body</span>元素为偏移参照基准, 完全脱离了标准文档流。

fixed 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。
</code></pre>
<p>————————————————————————————————————————————————————————   <br><strong>6、Flex布局用的多吗？</strong><br>因为项目考虑兼容 IE9 所以直接说用的不多</p>
<p>————————————————————————————————————————————————————————  <br><strong>7、移动端适配怎么做的？</strong><br>使用媒体查询做的响应式布局，根据不同屏幕宽度加载不同 css.<br>————————————————————————————————————————————————————————  <br><strong>8、let与var的区别？</strong></p>
<p>let 为 ES6 新添加申明变量的命令，它类似于 var，但是有以下不同：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象

let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升

let 不允许重复声明." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs cs"><code><span class="hljs-keyword">var</span> 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象

<span class="hljs-keyword">let</span> 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升

<span class="hljs-keyword">let</span> 不允许重复声明.</code></pre>
<p>————————————————————————————————————————————————————————  <br><strong>9、为什么 var 可以重复声明？（这个就不知道了）</strong></p>
<p>当我们执行代码时，我们可以简单的理解为新变量分配一块儿内存，命名为 a，并赋值为 2，但在运行的时候编译器与引擎还会进行两项额外的操作：判断变量是否已经声明：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="首先编译器对代码进行分析拆解，从左至右遇见 var a，则编译器会询问作用域是否已经存在叫 a 的变量了，如果不存在，则招呼作用域声明一个新的变量 a，若已经存在，则忽略 var 继续向下编译，这时 a = 2被编译成可执行的代码供引擎使用。

引擎遇见 a=2时同样会询问在当前的作用域下是否有变量 a，若存在，则将 a赋值为 2（由于第一步编译器忽略了重复声明的var，且作用域中已经有 a，所以重复声明会发生值得覆盖而并不会报错）。若不存在，则顺着作用域链向上查找，若最终找到了变量 a则将其赋值 2，若没有找到，则招呼作用域声明一个变量 a并赋值为 2。 参考链接
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs livecodeserver"><code>首先编译器对代码进行分析拆解，从左至右遇见 var <span class="hljs-keyword">a</span>，则编译器会询问作用域是否已经存在叫 <span class="hljs-keyword">a</span> 的变量了，如果不存在，则招呼作用域声明一个新的变量 <span class="hljs-keyword">a</span>，若已经存在，则忽略 var 继续向下编译，这时 <span class="hljs-keyword">a</span> = <span class="hljs-number">2</span>被编译成可执行的代码供引擎使用。

引擎遇见 <span class="hljs-keyword">a</span>=<span class="hljs-number">2</span>时同样会询问在当前的作用域下是否有变量 <span class="hljs-keyword">a</span>，若存在，则将 <span class="hljs-keyword">a</span>赋值为 <span class="hljs-number">2</span>（由于第一步编译器忽略了重复声明的var，且作用域中已经有 <span class="hljs-keyword">a</span>，所以重复声明会发生值得覆盖而并不会报错）。若不存在，则顺着作用域链向上查找，若最终找到了变量 <span class="hljs-keyword">a</span>则将其赋值 <span class="hljs-number">2</span>，若没有找到，则招呼作用域声明一个变量 <span class="hljs-keyword">a</span>并赋值为 <span class="hljs-number">2</span>。 参考链接
</code></pre>
<p>————————————————————————————————————————————————————————   <br><strong>10、封装一个函数，参数是定时器的时间，.then执行回调函数。</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function sleep (time) {

  return new Promise((resolve) => setTimeout(resolve, time));

}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span> (<span class="hljs-params">time</span>) </span>{

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> setTimeout(resolve, time));

}</code></pre>
<p>————————————————————————————————————————————————————————   <br><strong>11、一个关于 this 指向的问题</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="obj = {

    name: 'a',

    getName : function () {

        console.log(this.name);

    }

}


var fn = obj.getName

obj.getName()

var fn2 = obj.getName()

fn()

fn2()" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code>obj = {

    <span class="hljs-attr">name</span>: <span class="hljs-string">'a'</span>,

    <span class="hljs-attr">getName</span> : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);

    }

}


<span class="hljs-keyword">var</span> fn = obj.getName

obj.getName()

<span class="hljs-keyword">var</span> fn2 = obj.getName()

fn()

fn2()</code></pre>
<p>————————————————————————————————————————————————————————   <br><strong>13 CommonJS 中的 require/exports 和 ES6 中的 import/export 区别？</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。

ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。

import/export 最终都是编译为 require/exports 来执行的。

CommonJS 规范规定，每个模块内部， module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。

export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs coffeescript"><code>CommonJS 模块的重要特性是加载时执行，即脚本代码在 <span class="hljs-built_in">require</span> 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。

ES6 模块是动态引用，如果使用 <span class="hljs-keyword">import</span> 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。

<span class="hljs-keyword">import</span>/<span class="hljs-keyword">export</span> 最终都是编译为 <span class="hljs-built_in">require</span>/exports 来执行的。

CommonJS 规范规定，每个模块内部， <span class="hljs-built_in">module</span> 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即<span class="hljs-built_in">module</span>.exports ）是对外的接口。加载某个模块，其实是加载该模块的 <span class="hljs-built_in">module</span>.exports 属性。

<span class="hljs-keyword">export</span> 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</code></pre>
<p>————————————————————————————————————————————————————————   <br><strong>14、 一行代码实现数组去重？</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="[...new Set([1,2,3,1,'a',1,'a'])]" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs json"><code style="word-break: break-word; white-space: initial;">[...new Set([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,'a',<span class="hljs-number">1</span>,'a'])]</code></pre>
<p>————————————————————————————————————————————————————————   <br><strong>15、使用addEventListener点击li弹出内容，并且动态添加li之后有效</strong>（这个题没答出来??）</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<ul>

    <li>1</li>

    <li>2</li>

    <li>3</li>

    <li>4</li>

</ul>


var ulNode = document.getElementById(&quot;ul&quot;);

    ulNode.addEventListener('click', function (e) {

        if (e.target &amp;&amp; e.target.nodeName.toUpperCase() == &quot;LI&quot;) {

            alert(e.target.innerHTML);

        }

    }, false);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs maxima"><code>&lt;ul&gt;

    &lt;<span class="hljs-built_in">li</span>&gt;<span class="hljs-number">1</span>&lt;/<span class="hljs-built_in">li</span>&gt;

    &lt;<span class="hljs-built_in">li</span>&gt;<span class="hljs-number">2</span>&lt;/<span class="hljs-built_in">li</span>&gt;

    &lt;<span class="hljs-built_in">li</span>&gt;<span class="hljs-number">3</span>&lt;/<span class="hljs-built_in">li</span>&gt;

    &lt;<span class="hljs-built_in">li</span>&gt;<span class="hljs-number">4</span>&lt;/<span class="hljs-built_in">li</span>&gt;

&lt;/ul&gt;


<span class="hljs-built_in">var</span> ulNode = document.getElementById(<span class="hljs-string">"ul"</span>);

    ulNode.addEventListener('click', function (e) {

        <span class="hljs-keyword">if</span> (e.target &amp;&amp; e.target.nodeName.toUpperCase() == <span class="hljs-string">"LI"</span>) {

            alert(e.target.innerHTML);

        }

    }, <span class="hljs-literal">false</span>);</code></pre>
<p>————————————————————————————————————————————————————————   <br><strong>16、怎么判断两个对象相等？</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="    obj={

    a:1,

    b:2

}

obj2={

    a:1,

    b:2

}

obj3={

    a:1,

    b:2

}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code>    obj={

    <span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>,

    <span class="hljs-selector-tag">b</span>:<span class="hljs-number">2</span>

}

obj2={

    <span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>,

    <span class="hljs-selector-tag">b</span>:<span class="hljs-number">2</span>

}

obj3={

    <span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>,

    <span class="hljs-selector-tag">b</span>:<span class="hljs-number">2</span>

}
</code></pre>
<p>最开始的思路是遍历来判断，但是最后好像没有说清楚，查了下，好像可以转换为字符串来判断。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="JSON.stringify(obj)==JSON.stringify(obj2);//true

JSON.stringify(obj)==JSON.stringify(obj3);//false
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-built_in">JSON</span>.stringify(obj)==<span class="hljs-built_in">JSON</span>.stringify(obj2);<span class="hljs-comment">//true</span>

<span class="hljs-built_in">JSON</span>.stringify(obj)==<span class="hljs-built_in">JSON</span>.stringify(obj3);<span class="hljs-comment">//false</span>
</code></pre>
<p>————————————————————————————————————————————————————————   <br><strong>17、项目做过哪些性能优化？</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="减少 HTTP 请求数

减少 DNS 查询

使用 CDN

避免重定向

图片懒加载

减少 DOM 元素数量

减少 DOM 操作

使用外部 JavaScript 和 CSS

压缩 JavaScript 、 CSS 、字体、图片等

优化 CSS Sprite

使用 iconfont

字体裁剪

多域名分发划分内容到不同域名

尽量减少 iframe 使用

避免图片 src 为空

把样式表放在 中

把脚本放在页面底部 欢迎补充。。。" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs mipsasm"><code>减少 HTTP 请求数

减少 DNS 查询

使用 CDN

避免重定向

图片懒加载

减少 DOM 元素数量

减少 DOM 操作

使用外部 <span class="hljs-keyword">JavaScript </span>和 CSS

压缩 <span class="hljs-keyword">JavaScript </span>、 CSS 、字体、图片等

优化 CSS Sprite

使用 iconfont

字体裁剪

多域名分发划分内容到不同域名

尽量减少 iframe 使用

避免图片 src 为空

把样式表放在 中

把脚本放在页面底部 欢迎补充。。。</code></pre>
<p>————————————————————————————————————————————————————————   <br><strong>18、模块化开发是怎么做的？</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="使用命名空间。" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs"><code style="word-break: break-word; white-space: initial;">使用命名空间。</code></pre>
<p>————————————————————————————————————————————————————————  <br><strong>19、有没有使用过webpack？</strong><br>我说Vue项目中使用了，然后就没问了。<br>————————————————————————————————————————————————————————  <br><strong>20、gulp自己写过任务吗？还是都用的模块？</strong><br>不知道怎么怎么回答，不都是使用模块来写的么，然后就说是使用模块。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="
router.go(1)

router.push('/')" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs less"><code>
<span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.go</span>(<span class="hljs-number">1</span>)

<span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.push</span>(<span class="hljs-string">'/'</span>)</code></pre>
<p>————————————————————————————————————————————————————————  <br><strong>21、Vue router 跳转和 location.href 有什么区别？</strong><br>router 是 hash 改变 location.href 是页面跳转，刷新页面<br>————————————————————————————————————————————————————————  <br><strong>22、Vue 双向绑定实现原理？</strong><br>通过 Object.defineProperty 实现的<br>————————————————————————————————————————————————————————  <br><strong>23、你能实现一下双向绑定吗？</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<body>

    <div id=&quot;app&quot;>

        <input type=&quot;text&quot; id=&quot;txt&quot;>

        <p id=&quot;show-txt&quot;></p>

    </div>

    <script>

        var obj = {}

        Object.defineProperty(obj, 'txt', {

            get: function () {

                return obj

            },

            set: function (newValue) {

                document.getElementById('txt').value = newValue

                document.getElementById('show-txt').innerHTML = newValue

            }

        })

        document.addEventListener('keyup', function (e) {

            obj.txt = e.target.value

        })

    </script>

</body>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txt"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"show-txt"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">

        <span class="hljs-keyword">var</span> obj = {}

        <span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">'txt'</span>, {

            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

                <span class="hljs-keyword">return</span> obj

            },

            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) </span>{

                <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'txt'</span>).value = newValue

                <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'show-txt'</span>).innerHTML = newValue

            }

        })

        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{

            obj.txt = e.target.value

        })

    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>————————————————————————————————————————————————————————  <br><strong>24、 React 和 Vue 有什么区别？</strong></p>
<p>————————————————————————————————————————————————————————  <br><strong>25、 Set 和 Map 数据结构</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="ES6 提供了新的数据结构 Set 它类似于数组，但是成员的值都是唯一的，没有重复的值。

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说， Object 结构提供了“字符串—值”的对应， Map 结构提供了“值—值”的对应，是一种更完善的 Hash结构实现。" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs sql"><code>ES6 提供了新的数据结构 <span class="hljs-keyword">Set</span> 它类似于数组，但是成员的值都是唯一的，没有重复的值。

ES6 提供了 <span class="hljs-keyword">Map</span> 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说， <span class="hljs-keyword">Object</span> 结构提供了“字符串—值”的对应， <span class="hljs-keyword">Map</span> 结构提供了“值—值”的对应，是一种更完善的 <span class="hljs-keyword">Hash</span>结构实现。</code></pre>
<p>————————————————————————————————————————————————————————  <br><strong>26、WeakMap 和 Map 的区别?</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="WeakMap 结构与 Map 结构基本类似，唯一的区别是它只接受对象作为键名（ null 除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。

WeakMap 最大的好处是可以避免内存泄漏。一个仅被 WeakMap 作为 key 而引用的对象，会被垃圾回收器回收掉。

WeakMap 拥有和 Map 类似的 set(key, value) 、 get(key)、has(key)、 delete(key) 和 clear() 方法, 没有任何与迭代有关的属性和方法。" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs q"><code>WeakMap 结构与 Map 结构基本类似，唯一的区别是它只接受对象作为键名（ <span class="hljs-built_in">null</span> 除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。

WeakMap 最大的好处是可以避免内存泄漏。一个仅被 WeakMap 作为 <span class="hljs-built_in">key</span> 而引用的对象，会被垃圾回收器回收掉。

WeakMap 拥有和 Map 类似的 <span class="hljs-built_in">set</span>(<span class="hljs-built_in">key</span>, <span class="hljs-built_in">value</span>) 、 <span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>)、has(<span class="hljs-built_in">key</span>)、 <span class="hljs-keyword">delete</span>(<span class="hljs-built_in">key</span>) 和 clear() 方法, 没有任何与迭代有关的属性和方法。</code></pre>
<p>————————————————————————————————————————————————————————  <br><strong>27、重排和重绘</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算。这被称为重排。注意这里至少会有一次重排-初始化页面布局。

由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新被称为重绘。" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs"><code>部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算。这被称为重排。注意这里至少会有一次重排-初始化页面布局。

由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新被称为重绘。</code></pre>
<p>————————————————————————————————————————————————————————  <br><strong>28、什么情况会触发重排和重绘？</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="添加、删除、更新 DOM 节点

通过 display: none 隐藏一个 DOM 节点-触发重排和重绘

通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化

移动或者给页面中的 DOM 节点添加动画

添加一个样式表，调整样式属性

用户行为，例如调整窗口大小，改变字号，或者滚动。" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs groovy"><code>添加、删除、更新 DOM 节点

通过 <span class="hljs-string">display:</span> none 隐藏一个 DOM 节点-触发重排和重绘

通过 <span class="hljs-string">visibility:</span> hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化

移动或者给页面中的 DOM 节点添加动画

添加一个样式表，调整样式属性

用户行为，例如调整窗口大小，改变字号，或者滚动。</code></pre>
<p>————————————————————————————————————————————————————————  <br><strong>29、浏览器缓存</strong><br>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；

当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 request header验证这个资源是否命中协商缓存，称为 http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；

强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；

区别是，强缓存不对发送请求到服务器，但协商缓存会。

当协商缓存也没命中时，服务器就会将资源发送回客户端。

当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；

当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs armasm"><code>先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；

当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 request header验证这个资源是否命中协商缓存，称为 http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；

强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；

区别是，强缓存不对发送请求到服务器，但协商缓存会。

当协商缓存也没命中时，服务器就会将资源发送回客户端。

当 ctrl+<span class="hljs-built_in">f5</span> 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；

当 <span class="hljs-built_in">f5</span> 刷新网页时，跳过强缓存，但是会检查协商缓存；
</code></pre>
<p>强缓存</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）

Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-tag">Expires</span>（该字段是 <span class="hljs-selector-tag">http1</span><span class="hljs-selector-class">.0</span> 时的规范，值为一个绝对时间的 <span class="hljs-selector-tag">GMT</span> 格式的时间字符串，代表缓存资源的过期时间）

<span class="hljs-selector-tag">Cache-Control</span><span class="hljs-selector-pseudo">:max-age</span>（该字段是 <span class="hljs-selector-tag">http1</span><span class="hljs-selector-class">.1</span> 的规范，强缓存利用其 <span class="hljs-selector-tag">max-age</span> 值来判断缓存资源的最大生命周期，它的值单位为秒）
</code></pre>
<p>协商缓存</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Last-Modified（值为资源最后更新时间，随服务器response返回）

If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）

ETag（表示资源内容的唯一标识，随服务器response返回）

If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs mathematica"><code><span class="hljs-keyword">Last</span>-Modified（值为资源最后更新时间，随服务器response返回）

<span class="hljs-keyword">If</span>-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）

ETag（表示资源内容的唯一标识，随服务器response返回）

<span class="hljs-keyword">If</span>-<span class="hljs-keyword">None</span>-Match（服务器通过比较请求头部的<span class="hljs-keyword">If</span>-<span class="hljs-keyword">None</span>-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）
</code></pre>
<p>————————————————————————————————————————————————————————  <br><strong>如果喜欢请给个赞吧，您的赞会是我们继续分享的动力！</strong></p>
<p>原文转自：<a href="https://blog.ihoey.com/posts/Interview/2018-02-28-alibaba-interview.html" rel="nofollow noreferrer" target="_blank">https://blog.ihoey.com/posts/...</a></p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
面试分享：2018阿里巴巴前端面试总结(题目+答案 30题)

## 原文链接
[https://segmentfault.com/a/1190000013508719](https://segmentfault.com/a/1190000013508719)

