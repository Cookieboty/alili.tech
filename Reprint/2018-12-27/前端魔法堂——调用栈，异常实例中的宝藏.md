---
title: '前端魔法堂——调用栈，异常实例中的宝藏' 
date: 2018-12-27 2:30:13
hidden: true
slug: 6z895b4c92n
categories: [reprint]
---

{{< raw >}}

                    
<h2 id="articleHeader0">前言</h2>
<p> 在上一篇<a href="http://www.cnblogs.com/fsjohnhuang/p/7685144.html" rel="nofollow noreferrer" target="_blank">《前端魔法堂——异常不仅仅是try/catch》</a>中我们描述出一副异常及如何捕获异常的画像，但仅仅如此而已。试想一下，我们穷尽一切捕获异常实例，然后仅仅为告诉用户,运维和开发人员页面报了一个哪个哪个类型的错误吗？答案是否定的。我们的目的是收集<strong>刚刚足够</strong>的现场证据，好让我们能马上重现问题，快速修复，提供更优质的用户体验。那么问题就落在<strong>“收集足够的现场证据”</strong>，那么我们又需要哪些现场证据呢？那就是<strong>异常信息</strong>，<strong>调用栈</strong>和<strong>栈帧局部状态</strong>。（<strong>异常信息</strong>我们已经获取了）<br> 本文将围绕上<strong>调用栈</strong>和<strong>栈帧局部状态</strong>叙述，准开开车^_^</p>
<h2 id="articleHeader1">概要</h2>
<p> 本篇将叙述如下内容：</p>
<ol>
<li><a href="#">什么是调用栈？</a></li>
<li><a href="#">如何获取调用栈？</a></li>
<li><a href="#">什么是栈帧局部状态？又如何获取呢？</a></li>
</ol>
<h2 id="articleHeader2">一.什么是调用栈？</h2>
<p> 既然我们要获取调用栈信息，那么起码要弄清楚什么是调用栈吧！下面我们分别从两个层次来理解～</p>
<h3 id="articleHeader3">印象派</h3>
<p> 倘若主要工作内容为应用开发，那么我们对调用栈的印象如下就差不多了：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function funcA (a, b){
  return a + b
}

function funcB (a){
  let b = 3
  return funcA(a, b)
}

function main(){
  let a = 5
  funcB(a)
}

main()" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code>function funcA (<span class="hljs-selector-tag">a</span>, b){
  return <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>
}

function funcB (a){
  let <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span>
  return funcA(<span class="hljs-selector-tag">a</span>, b)
}

function main(){
  let <span class="hljs-selector-tag">a</span> = <span class="hljs-number">5</span>
  funcB(a)
}

<span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">()</span></span></code></pre>
<p> 那么每次调用函数时就会生成一个栈帧，并压入调用栈，栈帧中存储对应函数的局部变量；当该函数执行完成后，其对应的栈帧就会弹出调用栈。<br> 因此调用<code>main()</code>时，调用栈如下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="----------------<--栈顶
|function: main|
|let a = 5     |
|return void(0)|
----------------<--栈底" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs livecodeserver"><code><span class="hljs-comment">----------------&lt;--栈顶</span>
|<span class="hljs-function"><span class="hljs-keyword">function</span>: <span class="hljs-title">main</span>|</span>
|let <span class="hljs-keyword">a</span> = <span class="hljs-number">5</span>     |
|<span class="hljs-literal">return</span> void(<span class="hljs-number">0</span>)|
<span class="hljs-comment">----------------&lt;--栈底</span></code></pre>
<p> 调用<code>funcB()</code>时，调用栈如下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="----------------<--栈顶
|function:funcB|
|let b = 3     |
|return funcA()|
----------------
|function: main|
|let a = 5     |
|return void(0)|
----------------<--栈底" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs asciidoc"><code>----------------&lt;--栈顶
|function:funcB|
|let b = 3     |
<span class="hljs-section">|return funcA()|
----------------</span>
|function: main|
|let a = 5     |
|return void(0)|
----------------&lt;--栈底</code></pre>
<p> 调用<code>funcA()</code>时，调用栈如下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="----------------<--栈顶
|function:funcA|
|return a + b  |
----------------
|function:funcB|
|let b = 3     |
|return funcA()|
----------------
|function: main|
|let a = 5     |
|return void(0)|
----------------<--栈底" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs asciidoc"><code>----------------&lt;--栈顶
|function:funcA|
<span class="hljs-section">|return a + b  |
----------------</span>
|function:funcB|
|let b = 3     |
<span class="hljs-section">|return funcA()|
----------------</span>
|function: main|
|let a = 5     |
|return void(0)|
----------------&lt;--栈底</code></pre>
<p> <code>funcA()</code>执行完成后，调用栈如下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="----------------<--栈顶
|function:funcB|
|let b = 3     |
|return funcA()|
----------------
|function: main|
|let a = 5     |
|return void(0)|
----------------<--栈底" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs asciidoc"><code>----------------&lt;--栈顶
|function:funcB|
|let b = 3     |
<span class="hljs-section">|return funcA()|
----------------</span>
|function: main|
|let a = 5     |
|return void(0)|
----------------&lt;--栈底</code></pre>
<p> <code>funcB()</code>执行完成后，调用栈如下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="----------------<--栈顶
|function: main|
|let a = 5     |
|return void(0)|
----------------<--栈底" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs livecodeserver"><code><span class="hljs-comment">----------------&lt;--栈顶</span>
|<span class="hljs-function"><span class="hljs-keyword">function</span>: <span class="hljs-title">main</span>|</span>
|let <span class="hljs-keyword">a</span> = <span class="hljs-number">5</span>     |
|<span class="hljs-literal">return</span> void(<span class="hljs-number">0</span>)|
<span class="hljs-comment">----------------&lt;--栈底</span></code></pre>
<p> <code>main()</code>执行完成后，调用栈如下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="----------------<--栈顶
----------------<--栈底" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs brainfuck"><code><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&lt;<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">栈顶</span>
<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&lt;<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">栈底</span></code></pre>
<p> 现在我们对调用栈有了大概的印象了，但大家有没有留意上面记录"栈帧中存储对应函数的局部变量"，栈帧中仅仅存储对应函数的局部变量，那么入参呢？难道会作为局部变量吗？这个我们要从理论的层面才能得到解答呢。</p>
<h3 id="articleHeader4">理论派</h3>
<p> 这里我们要引入一个简单的C程序，透过其对应的汇编指令来讲解了。我会尽我所能用通俗易懂的语言描述这一切的，若有错误请各位指正！！</p>
<h4>前提知识</h4>
<ol>
<li>Intel X86架构中调用栈的栈底位于高位地址，而栈顶位于低位地址。(和印象派中示意图的方向刚好相反)</li>
<li>调用栈涉及的寄存器有</li>
</ol>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="ESP/RSP, 暂存栈顶地址
EBP/RBP, 暂存栈帧起始地址
EIP, 暂存下一个CPU指令的内存地址，当CPU执行完当前指令后，从EIP读取下一条指令的内存地址，然后继续执行" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs x86asm"><code><span class="hljs-built_in">ESP</span>/<span class="hljs-built_in">RSP</span>, 暂存栈顶地址
<span class="hljs-built_in">EBP</span>/<span class="hljs-built_in">RBP</span>, 暂存栈帧起始地址
<span class="hljs-built_in">EIP</span>, 暂存下一个<span class="hljs-meta">CPU</span>指令的内存地址，当<span class="hljs-meta">CPU</span>执行完当前指令后，从<span class="hljs-built_in">EIP</span>读取下一条指令的内存地址，然后继续执行</code></pre>
<ol><li>操作指令</li></ol>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="PUSH <OPRD>，将ESP向低位地址移动操作数所需的空间，然后将操作数压入调用栈中
POP <OPRD>，从调用栈中读取数据暂存到操作数指定的寄存器或内存空间中，然后向高位地址移动操作数对应的空间字节数
MOV <SRC>,<DST>，数据传送指令。用于将一个数据从源地址传送到目标地址，且不破坏源地址的内容
ADD <OPRD1>,<OPRD2>，两数相加不带进位，然后将结果保存到目标地址上
RET，相当于POP EIP。就是从堆栈中出栈，然后将值保存到EIP寄存器中
LEAVE，相当于MOV EBP ESP，然后再POP EBP。就是将栈顶指向当前栈帧地址，然后将调用者的栈帧地址暂存到EBP中" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs x86asm"><code><span class="hljs-keyword">PUSH</span> &lt;OPRD&gt;，将<span class="hljs-built_in">ESP</span>向低位地址移动操作数所需的空间，然后将操作数压入调用栈中
<span class="hljs-keyword">POP</span> &lt;OPRD&gt;，从调用栈中读取数据暂存到操作数指定的寄存器或内存空间中，然后向高位地址移动操作数对应的空间字节数
<span class="hljs-keyword">MOV</span> &lt;SRC&gt;,&lt;DST&gt;，数据传送指令。用于将一个数据从源地址传送到目标地址，且不破坏源地址的内容
<span class="hljs-keyword">ADD</span> &lt;OPRD1&gt;,&lt;OPRD2&gt;，两数相加不带进位，然后将结果保存到目标地址上
<span class="hljs-keyword">RET</span>，相当于<span class="hljs-keyword">POP</span> <span class="hljs-built_in">EIP</span>。就是从堆栈中出栈，然后将值保存到<span class="hljs-built_in">EIP</span>寄存器中
<span class="hljs-keyword">LEAVE</span>，相当于<span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EBP</span> <span class="hljs-built_in">ESP</span>，然后再<span class="hljs-keyword">POP</span> <span class="hljs-built_in">EBP</span>。就是将栈顶指向当前栈帧地址，然后将调用者的栈帧地址暂存到<span class="hljs-built_in">EBP</span>中</code></pre>
<ol><li>每个函数调用前汇编器都会加入以下前言(Prolog)，用于保存栈帧和返回地址</li></ol>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="push   %rbp      ;将调用者的栈帧指针压入调用栈
mov    %rsp,%rbp ;现在栈顶指向刚入栈的RBP内容，要将其设置为栈帧的起始位置" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs perl"><code><span class="hljs-keyword">push</span>   %rbp      ;将调用者的栈帧指针压入调用栈
mov    %rsp,%rbp ;现在栈顶指向刚入栈的RBP内容，要将其设置为栈帧的起始位置</code></pre>
<p> 现在们结合实例来理解吧！<br>C语言</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#include <stdio.h>

int add(int a, int b){
  return a + b;
}
int add2(int a){
  int sum = add(0, a);
  return sum + 2;
}

void main(){
  add2(2);
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs cpp"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{
  <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>{
  <span class="hljs-keyword">int</span> sum = add(<span class="hljs-number">0</span>, a);
  <span class="hljs-keyword">return</span> sum + <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
  add2(<span class="hljs-number">2</span>);
}</code></pre>
<p>然后执行以下命令编译带调试信息的可执行文件，和dump文件</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="$ gcc -g -o main main.c
$ objdump -d main > main.dump" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs elixir"><code><span class="hljs-variable">$ </span>gcc -g -o main main.c
<span class="hljs-variable">$ </span>objdump -d main &gt; main.dump</code></pre>
<p>下面我们截取main、add2和add对应的汇编指令来讲解</p>
<p><strong>main函数对应的汇编指令</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="0x40050f <main>                 push   %rbp
0x400510 <main+1>               mov    %rsp,%rbp
;将2暂存到寄存器EDI中
0x400513 <main+4>               mov    $0x2,%edi
;执行call指令前，EIP寄存器已经存储下一条指令的地址0x40051d了
;首先将EIP寄存器的值入栈，当函数返回时用于恢复之前的执行序列
;然后才是执行JUMP指令跳转到add2函数中开始执行其第一条指令
0x400518 <main+9>               callq  0x4004ea <add2>
;什么都不做
0x40051d <main+14>              nop
;设置RBP为指向main函数调用方的栈帧地址
0x40051e <main+15>              pop    %rbp
;设置EIP指向main函数返回后将要执行的指令的地址
0x40051f <main+16>              retq" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lsl"><code><span class="hljs-number">0x40050f</span> &lt;main&gt;                 push   %rbp
<span class="hljs-number">0x400510</span> &lt;main+<span class="hljs-number">1</span>&gt;               mov    %rsp,%rbp
;将<span class="hljs-number">2</span>暂存到寄存器EDI中
<span class="hljs-number">0x400513</span> &lt;main+<span class="hljs-number">4</span>&gt;               mov    $<span class="hljs-number">0x2</span>,%edi
;执行call指令前，EIP寄存器已经存储下一条指令的地址<span class="hljs-number">0x40051d</span>了
;首先将EIP寄存器的值入栈，当函数返回时用于恢复之前的执行序列
;然后才是执行JUMP指令跳转到add2函数中开始执行其第一条指令
<span class="hljs-number">0x400518</span> &lt;main+<span class="hljs-number">9</span>&gt;               callq  <span class="hljs-number">0x4004ea</span> &lt;add2&gt;
;什么都不做
<span class="hljs-number">0x40051d</span> &lt;main+<span class="hljs-number">14</span>&gt;              nop
;设置RBP为指向main函数调用方的栈帧地址
<span class="hljs-number">0x40051e</span> &lt;main+<span class="hljs-number">15</span>&gt;              pop    %rbp
;设置EIP指向main函数返回后将要执行的指令的地址
<span class="hljs-number">0x40051f</span> &lt;main+<span class="hljs-number">16</span>&gt;              retq</code></pre>
<p>下面是执行add2函数第一条指令前的调用栈快照</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="+++++++++++++++++ 高位地址
99 |   110    | -- 存放main函数调用方的栈帧地址 <-- EBP
+++++++++++++++++
98 | 0x40051d | -- EIP的值，存放add2返回后将执行的指令的地址 <-- ESP
+++++++++++++++++ 低位地址" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs asciidoc"><code><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++ 高位地址
<span class="hljs-section">99 |   110    | -- 存放main函数调用方的栈帧地址 &lt;-- EBP
+++++++++++++++++</span>
98 | 0x40051d | -- EIP的值，存放add2返回后将执行的指令的地址 &lt;-- ESP
<span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++ 低位地址</code></pre>
<p><strong>add2函数对应的汇编指令</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="0x4004ea <add2>                 push   %rbp
0x4004eb <add2+1>               mov    %rsp,%rbp
0x4004ee <add2+4>               sub    $0x18,%rsp      ;栈顶向低位移动24个字节，为后续操作预留堆栈空间
0x4004f2 <add2+8>               mov    %edi,-0x14(%rbp);从EDI寄存器中读取参数，并存放到堆栈空间中
0x4004f5 <add2+11>              mov    -0x14(%rbp),%eax;从堆栈空间中读取参数，放进EAX寄存器中
0x4004f8 <add2+14>              mov    %eax,%esi       ;从EAX寄存器中读取参数，存放到ESI寄存器中
0x4004fa <add2+16>              mov    $0x0,%edi       ;将0存放到EDI寄存器中
;执行call指令前，EIP寄存器已经存储下一条指令的地址0x400504了
;首先将EIP寄存器的值入栈，当函数返回时用于恢复之前的执行序列
;然后才是执行JUMP指令跳转到add函数中开始执行其第一条指令
0x4004ff <add2+21>              callq  0x4004d6 <add>
0x400504 <add2+26>              mov    %eax,-0x4(%rbp) ;读取add的返回值(存储在EAX寄存器中)，存放到堆栈空间中
0x400507 <add2+29>              mov    -0x4(%rbp),%eax ;又将add的返回值存放到EAX寄存器中(这是有多无聊啊～～)
0x40050a <add2+32>              add    $0x2,%eax       ;读取EAX寄存器的值与2相加，结果存放到EAX寄存器中
0x40050d <add2+35>              leaveq                 ;让栈顶指针指向main函数的栈帧地址，然后让EBP指向main函数的栈帧地址
0x40050e <add2+36>              retq                   ;让EIP指向add2返回后将执行的指令的地址" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lsl"><code><span class="hljs-number">0x4004ea</span> &lt;add2&gt;                 push   %rbp
<span class="hljs-number">0x4004eb</span> &lt;add2+<span class="hljs-number">1</span>&gt;               mov    %rsp,%rbp
<span class="hljs-number">0x4004ee</span> &lt;add2+<span class="hljs-number">4</span>&gt;               sub    $<span class="hljs-number">0x18</span>,%rsp      ;栈顶向低位移动<span class="hljs-number">24</span>个字节，为后续操作预留堆栈空间
<span class="hljs-number">0x4004f2</span> &lt;add2+<span class="hljs-number">8</span>&gt;               mov    %edi,<span class="hljs-number">-0x14</span>(%rbp);从EDI寄存器中读取参数，并存放到堆栈空间中
<span class="hljs-number">0x4004f5</span> &lt;add2+<span class="hljs-number">11</span>&gt;              mov    <span class="hljs-number">-0x14</span>(%rbp),%eax;从堆栈空间中读取参数，放进EAX寄存器中
<span class="hljs-number">0x4004f8</span> &lt;add2+<span class="hljs-number">14</span>&gt;              mov    %eax,%esi       ;从EAX寄存器中读取参数，存放到ESI寄存器中
<span class="hljs-number">0x4004fa</span> &lt;add2+<span class="hljs-number">16</span>&gt;              mov    $<span class="hljs-number">0x0</span>,%edi       ;将<span class="hljs-number">0</span>存放到EDI寄存器中
;执行call指令前，EIP寄存器已经存储下一条指令的地址<span class="hljs-number">0x400504</span>了
;首先将EIP寄存器的值入栈，当函数返回时用于恢复之前的执行序列
;然后才是执行JUMP指令跳转到add函数中开始执行其第一条指令
<span class="hljs-number">0x4004ff</span> &lt;add2+<span class="hljs-number">21</span>&gt;              callq  <span class="hljs-number">0x4004d6</span> &lt;add&gt;
<span class="hljs-number">0x400504</span> &lt;add2+<span class="hljs-number">26</span>&gt;              mov    %eax,<span class="hljs-number">-0x4</span>(%rbp) ;读取add的返回值(存储在EAX寄存器中)，存放到堆栈空间中
<span class="hljs-number">0x400507</span> &lt;add2+<span class="hljs-number">29</span>&gt;              mov    <span class="hljs-number">-0x4</span>(%rbp),%eax ;又将add的返回值存放到EAX寄存器中(这是有多无聊啊～～)
<span class="hljs-number">0x40050a</span> &lt;add2+<span class="hljs-number">32</span>&gt;              add    $<span class="hljs-number">0x2</span>,%eax       ;读取EAX寄存器的值与<span class="hljs-number">2</span>相加，结果存放到EAX寄存器中
<span class="hljs-number">0x40050d</span> &lt;add2+<span class="hljs-number">35</span>&gt;              leaveq                 ;让栈顶指针指向main函数的栈帧地址，然后让EBP指向main函数的栈帧地址
<span class="hljs-number">0x40050e</span> &lt;add2+<span class="hljs-number">36</span>&gt;              retq                   ;让EIP指向add2返回后将执行的指令的地址</code></pre>
<p>下面是执行完add2函数中<code>mov %rsp,%rbp</code>的调用栈快照</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="+++++++++++++++++ 高位地址
99 |    110   | -- 存放main函数调用方的栈帧地址
+++++++++++++++++
98 | 0x40051d | -- 存放EIP的值，add2返回后将执行的指令的地址
+++++++++++++++++
97 |    99    | -- 存放add2函数调用方(即main函数)的栈帧地址<-- ESP,EBP
+++++++++++++++++ 低位地址" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs asciidoc"><code><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++ 高位地址
<span class="hljs-section">99 |    110   | -- 存放main函数调用方的栈帧地址
+++++++++++++++++</span>
<span class="hljs-section">98 | 0x40051d | -- 存放EIP的值，add2返回后将执行的指令的地址
+++++++++++++++++</span>
97 |    99    | -- 存放add2函数调用方(即main函数)的栈帧地址&lt;-- ESP,EBP
<span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++ 低位地址</code></pre>
<p>下面是执行add函数第一条指令前的调用栈快照</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="+++++++++++++++++ 高位地址
99 |    110   | -- 存放main函数调用方的栈帧地址
+++++++++++++++++
98 | 0x40051d | -- 存放EIP的值，add2返回后将执行的指令的地址
+++++++++++++++++
97 |    99    | -- 存放add2函数调用方(即main函数)的栈帧地址<-- EBP
+++++++++++++++++
96 |   0xXX   |
+++++++++++++++++
.................
76 |   0x02   | -- 这是`mov %edi,-0x14(%rbp)`的执行结果
+++++++++++++++++
.................
+++++++++++++++++
73 |   0xXX   |
+++++++++++++++++
72 | 0x400504 | -- EIP的值，存放add返回后将执行的指令的地址 <-- ESP
+++++++++++++++++ 低位地址" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs asciidoc"><code><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++ 高位地址
<span class="hljs-section">99 |    110   | -- 存放main函数调用方的栈帧地址
+++++++++++++++++</span>
<span class="hljs-section">98 | 0x40051d | -- 存放EIP的值，add2返回后将执行的指令的地址
+++++++++++++++++</span>
<span class="hljs-section">97 |    99    | -- 存放add2函数调用方(即main函数)的栈帧地址&lt;-- EBP
+++++++++++++++++</span>
<span class="hljs-section">96 |   0xXX   |
+++++++++++++++++</span>
<span class="hljs-code">.................
76 |   0x02   | -- 这是`mov %edi,-0x14(%rbp)`的执行结果
+++++++++++++++++
.................</span>
+++++++++++++++++
73 |   0xXX   |
+++++++++++++++++
72 | 0x400504 | -- EIP的值，存放add返回后将执行的指令的地址 &lt;-- ESP
<span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++ 低位地址</code></pre>
<p>add函数对应的汇编指令</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="0x4004d6 <add>                  push   %rbp
0x4004d7 <add+1>                mov    %rsp,%rbp
0x4004da <add+4>                mov    %edi,-0x4(%rbp)
0x4004dd <add+7>                mov    %esi,-0x8(%rbp)
0x4004e0 <add+10>               mov    -0x4(%rbp),%edx
0x4004e3 <add+13>               mov    -0x8(%rbp),%eax
0x4004e6 <add+16>               add    %edx,%eax
0x4004e8 <add+18>               pop    %rbp
0x4004e9 <add+19>               retq" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs llvm"><code><span class="hljs-number">0x4004d6</span> &lt;<span class="hljs-keyword">add</span>&gt;                  push   <span class="hljs-symbol">%rbp</span>
<span class="hljs-number">0x4004d7</span> &lt;<span class="hljs-keyword">add</span>+<span class="hljs-number">1</span>&gt;                mov    <span class="hljs-symbol">%rsp</span>,<span class="hljs-symbol">%rbp</span>
<span class="hljs-number">0x4004da</span> &lt;<span class="hljs-keyword">add</span>+<span class="hljs-number">4</span>&gt;                mov    <span class="hljs-symbol">%edi</span>,<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">4</span>(<span class="hljs-symbol">%rbp</span>)
<span class="hljs-number">0x4004dd</span> &lt;<span class="hljs-keyword">add</span>+<span class="hljs-number">7</span>&gt;                mov    <span class="hljs-symbol">%esi</span>,<span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">8</span>(<span class="hljs-symbol">%rbp</span>)
<span class="hljs-number">0x4004e0</span> &lt;<span class="hljs-keyword">add</span>+<span class="hljs-number">10</span>&gt;               mov    <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">4</span>(<span class="hljs-symbol">%rbp</span>),<span class="hljs-symbol">%edx</span>
<span class="hljs-number">0x4004e3</span> &lt;<span class="hljs-keyword">add</span>+<span class="hljs-number">13</span>&gt;               mov    <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">8</span>(<span class="hljs-symbol">%rbp</span>),<span class="hljs-symbol">%eax</span>
<span class="hljs-number">0x4004e6</span> &lt;<span class="hljs-keyword">add</span>+<span class="hljs-number">16</span>&gt;               <span class="hljs-keyword">add</span>    <span class="hljs-symbol">%edx</span>,<span class="hljs-symbol">%eax</span>
<span class="hljs-number">0x4004e8</span> &lt;<span class="hljs-keyword">add</span>+<span class="hljs-number">18</span>&gt;               pop    <span class="hljs-symbol">%rbp</span>
<span class="hljs-number">0x4004e9</span> &lt;<span class="hljs-keyword">add</span>+<span class="hljs-number">19</span>&gt;               retq</code></pre>
<p>下面是add函数执行完<code>mov %rsp,%rbp</code>的调用栈快照</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="+++++++++++++++++ 高位地址
99 |    110   | -- 存放main函数调用方的栈帧地址
+++++++++++++++++
98 | 0x40051d | -- 存放EIP的值，add2返回后将执行的指令的地址
+++++++++++++++++
97 |    99    | -- 存放add2函数调用方(即main函数)的栈帧地址
+++++++++++++++++
96 |   0xXX   |
+++++++++++++++++
.................
76 |   0x02   | -- 这是`mov %edi,-0x14(%rbp)`的执行结果
+++++++++++++++++
.................
+++++++++++++++++
73 |   0xXX   |
+++++++++++++++++
72 | 0x400504 | -- EIP的值，存放add返回后将执行的指令的地址
+++++++++++++++++
71 |    97    | -- 存放add函数调用方(即add函数)的栈帧地址<-- EBP,ESP
+++++++++++++++++ 低位地址" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs asciidoc"><code><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++ 高位地址
<span class="hljs-section">99 |    110   | -- 存放main函数调用方的栈帧地址
+++++++++++++++++</span>
<span class="hljs-section">98 | 0x40051d | -- 存放EIP的值，add2返回后将执行的指令的地址
+++++++++++++++++</span>
<span class="hljs-section">97 |    99    | -- 存放add2函数调用方(即main函数)的栈帧地址
+++++++++++++++++</span>
<span class="hljs-section">96 |   0xXX   |
+++++++++++++++++</span>
<span class="hljs-code">.................
76 |   0x02   | -- 这是`mov %edi,-0x14(%rbp)`的执行结果
+++++++++++++++++
.................</span>
+++++++++++++++++
73 |   0xXX   |
+++++++++++++++++
<span class="hljs-section">72 | 0x400504 | -- EIP的值，存放add返回后将执行的指令的地址
+++++++++++++++++</span>
71 |    97    | -- 存放add函数调用方(即add函数)的栈帧地址&lt;-- EBP,ESP
<span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++ 低位地址</code></pre>
<p>下面就是一系列弹出栈帧的过程了<br>当add函数执行完<code>retq</code>的调用栈快照</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="+++++++++++++++++ 高位地址
99 |    110   | -- 存放main函数调用方的栈帧地址
+++++++++++++++++
98 | 0x40051d | -- 存放EIP的值，add2返回后将执行的指令的地址
+++++++++++++++++
97 |    99    | -- 存放add2函数调用方(即main函数)的栈帧地址 <-- EBP
+++++++++++++++++
96 |   0xXX   |
+++++++++++++++++
.................
76 |   0x02   | -- 这是`mov %edi,-0x14(%rbp)`的执行结果
+++++++++++++++++
.................
+++++++++++++++++
73 |   0xXX   | <-- ESP
+++++++++++++++++ 低位地址" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs asciidoc"><code><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++ 高位地址
<span class="hljs-section">99 |    110   | -- 存放main函数调用方的栈帧地址
+++++++++++++++++</span>
<span class="hljs-section">98 | 0x40051d | -- 存放EIP的值，add2返回后将执行的指令的地址
+++++++++++++++++</span>
<span class="hljs-section">97 |    99    | -- 存放add2函数调用方(即main函数)的栈帧地址 &lt;-- EBP
+++++++++++++++++</span>
<span class="hljs-section">96 |   0xXX   |
+++++++++++++++++</span>
<span class="hljs-code">.................
76 |   0x02   | -- 这是`mov %edi,-0x14(%rbp)`的执行结果
+++++++++++++++++
.................</span>
+++++++++++++++++
73 |   0xXX   | <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">--</span> <span class="hljs-attr">ESP</span>
+++++++++++++++++ 低位地址</span></span></code></pre>
<p>然后就不断弹出栈帧了～～～<br> 从上面看到函数入参是先存储到寄存器中，然后在函数体内读取到栈帧所在空间中（局部变量、临时变量）。那么从调用栈中我们能获取函数的调用流和入参信息，从而恢复案发现场^_^</p>
<h3 id="articleHeader5">插播:函数的调用方式</h3>
<p> 其实函数入参的传递方式不止上述这种，还有以下3种</p>
<ol>
<li>cdecl调用约定<br> 调用方从右到左的顺序将参数压入栈中，在被调用方执行完成后，由调用方负责清理栈中的参数（也称为栈平衡）。</li>
<li>stdcall调用约定<br> 巨硬自称的一种调用约定，并不是实际上的标准调用约定。调用方从右到左的顺序将参数压入栈中，在被调用方执行完成后，由被调用方负责清理栈中的参数（也称为栈平衡）。</li>
<li>fastcall调用约定<br> 是stdcall的变体，调用方从右到左的顺序将参数压入栈中，最右边的两个参数则不压入栈中，而是分别存储在ECX和EDX寄存器中，在被调用方执行完成后，由被调用方负责清理栈中的参数（也称为栈平衡）。</li>
</ol>
<p> 但不管哪种，最终还是会在函数体内读取到当前栈帧空间中。</p>
<h2 id="articleHeader6">二. 如何获取调用栈？</h2>
<p> 上面写的这么多，可是我们现在写的是JavaScript哦，那到底怎么才能读取调用栈的信息呢？</p>
<h3 id="articleHeader7">抛个异常看看</h3>
<p> IE10+的Error实例中包含一个<code>stack</code>属性<br>示例</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function add(a, b){
  let sum = a + b
  throw Error(&quot;Capture Call Stack!&quot;)
  return sum
}

function add2(a){
  return 2 + add(0, a)
}

function main(){
  add2(2)
}

try{
  main()
} catch (e){
  console.log(e.stack)
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
  <span class="hljs-keyword">let</span> sum = a + b
  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Capture Call Stack!"</span>)
  <span class="hljs-keyword">return</span> sum
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + add(<span class="hljs-number">0</span>, a)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
  add2(<span class="hljs-number">2</span>)
}

<span class="hljs-keyword">try</span>{
  main()
} <span class="hljs-keyword">catch</span> (e){
  <span class="hljs-built_in">console</span>.log(e.stack)
}</code></pre>
<p>Chrome回显</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Error: Capture Call Stack!
    at add (index.html:16)
    at add2 (index.html:21)
    at main (index.html:25)
    at index.html:29" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs subunit"><code><span class="hljs-keyword">Error: </span>Capture Call Stack!
    at add (index.html:16)
    at add2 (index.html:21)
    at main (index.html:25)
    at index.html:29</code></pre>
<p>FireFox回显</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="add@file:///home/john/index.html:16:9
add2@file:///home/john/index.html:21:14
main@file:///home/john/index.html:25:3
@file:///home/john/index.html:29:3" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs elixir"><code>add<span class="hljs-variable">@file</span><span class="hljs-symbol">:///home/john/index</span>.<span class="hljs-symbol">html:</span><span class="hljs-number">16</span><span class="hljs-symbol">:</span><span class="hljs-number">9</span>
add2<span class="hljs-variable">@file</span><span class="hljs-symbol">:///home/john/index</span>.<span class="hljs-symbol">html:</span><span class="hljs-number">21</span><span class="hljs-symbol">:</span><span class="hljs-number">14</span>
main<span class="hljs-variable">@file</span><span class="hljs-symbol">:///home/john/index</span>.<span class="hljs-symbol">html:</span><span class="hljs-number">25</span><span class="hljs-symbol">:</span><span class="hljs-number">3</span>
<span class="hljs-variable">@file</span><span class="hljs-symbol">:///home/john/index</span>.<span class="hljs-symbol">html:</span><span class="hljs-number">29</span><span class="hljs-symbol">:</span><span class="hljs-number">3</span></code></pre>
<h3 id="articleHeader8">V8的<code>Error.captureStackTrace</code>函数</h3>
<p> V8引擎向JavaScript提供了其Stack Trace API中的<code>captureStackTrace</code>函数，用于获取调用<code>Error.captureStackTrace</code>时的调用栈快照。函数签名如下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="@static
@method captureStackTrace(targetObject, constructorOpt)
@param {Object} targetObject - 为targetObject添加.stack属性，该属性保存调用Error.captureStackTrace时的调用栈快照
@param {Function} constructorOpt= - 调用栈快照不断作出栈操作，直到constructorOpt所指向的函数刚好出栈为止，然后保存到targetObject的stack属性中
@return {undefined}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs oxygene"><code>@<span class="hljs-keyword">static</span>
@<span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">captureStackTrace</span><span class="hljs-params">(targetObject, constructorOpt)</span>
@<span class="hljs-title">param</span> <span class="hljs-comment">{Object}</span> <span class="hljs-title">targetObject</span> - 为<span class="hljs-title">targetObject</span>添加.<span class="hljs-title">stack</span>属性，该属性保存调用<span class="hljs-title">Error</span>.<span class="hljs-title">captureStackTrace</span>时的调用栈快照
@<span class="hljs-title">param</span> <span class="hljs-comment">{Function}</span> <span class="hljs-title">constructorOpt</span>= - 调用栈快照不断作出栈操作，直到<span class="hljs-title">constructorOpt</span>所指向的函数刚好出栈为止，然后保存到<span class="hljs-title">targetObject</span>的<span class="hljs-title">stack</span>属性中
@<span class="hljs-title">return</span> <span class="hljs-comment">{undefined}</span></span></code></pre>
<p>示例</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function add(a, b){
  let sum = a + b
  let targetObj = {}

  Error.captureStackTrace(targetObj)
  console.log(targetObj.stack)

  Error.captureStackTrace(targetObj, add)
  console.log(targetObj.stack)

  return sum
}

function add2(a){
  return 2 + add(0, a)
}

function main(){
  add2(2)
}

main()" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
  <span class="hljs-keyword">let</span> sum = a + b
  <span class="hljs-keyword">let</span> targetObj = {}

  <span class="hljs-built_in">Error</span>.captureStackTrace(targetObj)
  <span class="hljs-built_in">console</span>.log(targetObj.stack)

  <span class="hljs-built_in">Error</span>.captureStackTrace(targetObj, add)
  <span class="hljs-built_in">console</span>.log(targetObj.stack)

  <span class="hljs-keyword">return</span> sum
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + add(<span class="hljs-number">0</span>, a)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
  add2(<span class="hljs-number">2</span>)
}

main()</code></pre>
<p>Chrome回显</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Error
    at add (index.html:18)
    at add2 (index.html:28)
    at main (index.html:32)
    at index.html:35
Error
    at add2 (index.html:28)
    at main (index.html:32)
    at index.html:35" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs subunit"><code><span class="hljs-keyword">Error
    </span>at add (index.html:18)
    at add2 (index.html:28)
    at main (index.html:32)
    at index.html:35
<span class="hljs-keyword">Error
    </span>at add2 (index.html:28)
    at main (index.html:32)
    at index.html:35</code></pre>
<h3 id="articleHeader9">控制台的<code>console.trace</code>函数</h3>
<p> 还有最后一招<code>console.trace</code>，不过实际用处不大<br>示例</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function add(a, b){
  let sum = a + b
  console.trace()

  return sum
}

function add2(a){
  return 2 + add(0, a)
}

function main(){
  add2(2)
}

main()" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
  <span class="hljs-keyword">let</span> sum = a + b
  <span class="hljs-built_in">console</span>.trace()

  <span class="hljs-keyword">return</span> sum
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + add(<span class="hljs-number">0</span>, a)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
  add2(<span class="hljs-number">2</span>)
}

main()</code></pre>
<p>Chrome回显</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="add    @    index.html:16
add2    @    index.html:22
main    @    index.html:26
(anonymous)    @    index.html:29" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs vim"><code><span class="hljs-built_in">add</span>    @    <span class="hljs-built_in">index</span>.htm<span class="hljs-variable">l:16</span>
add2    @    <span class="hljs-built_in">index</span>.htm<span class="hljs-variable">l:22</span>
main    @    <span class="hljs-built_in">index</span>.htm<span class="hljs-variable">l:26</span>
(anonymous)    @    <span class="hljs-built_in">index</span>.htm<span class="hljs-variable">l:29</span></code></pre>
<p> 上述三种方式（实际就两种可用啦）都只能获取函数调用流，函数入参、局部变量等信息全都灰飞烟灭了？上面不是说好这些信息调用栈都有嘛，干嘛不给我呢？其实想想都知道调用栈中有这么多信息，其实我们只需一小部分，全盘托出并不是什么好设计。其实我们只要再获取<strong>栈帧局部状态</strong>就好了。</p>
<h2 id="articleHeader10">三. 什么是栈帧局部状态？又如何获取呢？</h2>
<p> 所谓栈帧局部状态其实就是函数入参和局部变量，试想如果我们得到<code>add</code>函数调用时的入参是<code>a=0</code>、<code>b=2</code>和<code>sum=2</code>，那么不就得到完整案发现场了吗？那问题就是如何获得了。要不我们做个Monkey Patch</p>
<ol><li>自定义一个异常类来承载栈帧局部状态</li></ol>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function StackTraceError(e, env){
  if (this instanceof StackTraceError);else return new StackTraceError(e, env)
  this.e = e
  this.env = env
}
let proto = StackTraceError.prototype = Object.create(Error.prototype)
proto.name = &quot;StackTraceError&quot;
proto.message = &quot;Internal error.&quot;
proto.constructor = StackTraceError
proto.valueOf = proto.toString = function(){
  let curr = this, q = [], files = []
  do {
    if (curr.stack){
      let stack = String(curr.stack)
      let segs = stack.split('\n').map(seg => seg.trim())
      files = segs.filter(seg => seg != &quot;Error&quot;)
    }
    else{
      q.unshift({name: curr.name,
                 msg: curr.message,
                 env: curr.env})
    }
  } while (curr = curr.e)

  let frames = []
  let c = files.length, i = 0
  while (i < c){
    let file = files[i]
    let e = q[i]
    let frame = {
      name: e &amp;&amp; e.name,
      msg: e &amp;&amp; e.msg,
      env: e &amp;&amp; e.env,
      file: file
    }
    frames.push(JSON.stringify(frame))
    i += 1
  }
  return frames.join(&quot;\n&quot;)
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StackTraceError</span>(<span class="hljs-params">e, env</span>)</span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> StackTraceError);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StackTraceError(e, env)
  <span class="hljs-keyword">this</span>.e = e
  <span class="hljs-keyword">this</span>.env = env
}
<span class="hljs-keyword">let</span> proto = StackTraceError.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Error</span>.prototype)
proto.name = <span class="hljs-string">"StackTraceError"</span>
proto.message = <span class="hljs-string">"Internal error."</span>
proto.constructor = StackTraceError
proto.valueOf = proto.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">let</span> curr = <span class="hljs-keyword">this</span>, q = [], files = []
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">if</span> (curr.stack){
      <span class="hljs-keyword">let</span> stack = <span class="hljs-built_in">String</span>(curr.stack)
      <span class="hljs-keyword">let</span> segs = stack.split(<span class="hljs-string">'\n'</span>).map(<span class="hljs-function"><span class="hljs-params">seg</span> =&gt;</span> seg.trim())
      files = segs.filter(<span class="hljs-function"><span class="hljs-params">seg</span> =&gt;</span> seg != <span class="hljs-string">"Error"</span>)
    }
    <span class="hljs-keyword">else</span>{
      q.unshift({<span class="hljs-attr">name</span>: curr.name,
                 <span class="hljs-attr">msg</span>: curr.message,
                 <span class="hljs-attr">env</span>: curr.env})
    }
  } <span class="hljs-keyword">while</span> (curr = curr.e)

  <span class="hljs-keyword">let</span> frames = []
  <span class="hljs-keyword">let</span> c = files.length, i = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (i &lt; c){
    <span class="hljs-keyword">let</span> file = files[i]
    <span class="hljs-keyword">let</span> e = q[i]
    <span class="hljs-keyword">let</span> frame = {
      <span class="hljs-attr">name</span>: e &amp;&amp; e.name,
      <span class="hljs-attr">msg</span>: e &amp;&amp; e.msg,
      <span class="hljs-attr">env</span>: e &amp;&amp; e.env,
      <span class="hljs-attr">file</span>: file
    }
    frames.push(<span class="hljs-built_in">JSON</span>.stringify(frame))
    i += <span class="hljs-number">1</span>
  }
  <span class="hljs-keyword">return</span> frames.join(<span class="hljs-string">"\n"</span>)
}</code></pre>
<ol><li>每个函数定义都通过<code>try/catch</code>捕获栈帧局部状态</li></ol>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function add(a, b){
  try{
    var sum = a + b
    throw Error()
  }
  catch(e){
    throw StackTraceError(e, [&quot;a:&quot;, a, &quot;b&quot;, b, &quot;sum&quot;, sum].join(&quot;::&quot;))
  }
  return sum
}

function add2(a){
  try{
    return 2 + add(0, a)
  }
  catch(e){
    throw StackTraceError(e, [&quot;a&quot;, a].join(&quot;::&quot;))
  }
}

function main(){
  try{
    add2(2)
  }
  catch(e){
    throw StackTraceError(e, &quot;&quot;)
  }
}

try{
  main()
} catch(e){
  console.log(e+'')
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
  <span class="hljs-keyword">try</span>{
    <span class="hljs-keyword">var</span> sum = a + b
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>()
  }
  <span class="hljs-keyword">catch</span>(e){
    <span class="hljs-keyword">throw</span> StackTraceError(e, [<span class="hljs-string">"a:"</span>, a, <span class="hljs-string">"b"</span>, b, <span class="hljs-string">"sum"</span>, sum].join(<span class="hljs-string">"::"</span>))
  }
  <span class="hljs-keyword">return</span> sum
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a</span>)</span>{
  <span class="hljs-keyword">try</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + add(<span class="hljs-number">0</span>, a)
  }
  <span class="hljs-keyword">catch</span>(e){
    <span class="hljs-keyword">throw</span> StackTraceError(e, [<span class="hljs-string">"a"</span>, a].join(<span class="hljs-string">"::"</span>))
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">try</span>{
    add2(<span class="hljs-number">2</span>)
  }
  <span class="hljs-keyword">catch</span>(e){
    <span class="hljs-keyword">throw</span> StackTraceError(e, <span class="hljs-string">""</span>)
  }
}

<span class="hljs-keyword">try</span>{
  main()
} <span class="hljs-keyword">catch</span>(e){
  <span class="hljs-built_in">console</span>.log(e+<span class="hljs-string">''</span>)
}</code></pre>
<p>chrome下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="{&quot;name&quot;:&quot;StackTraceError&quot;,&quot;msg&quot;:&quot;Internal error.&quot;,&quot;env&quot;:&quot;a::0::b::2::sum::2&quot;,&quot;file&quot;:&quot;at add (file:///home/john/index.html:57:11)&quot;}
{&quot;name&quot;:&quot;StackTraceError&quot;,&quot;msg&quot;:&quot;Internal error.&quot;,&quot;env&quot;:&quot;a:;2&quot;,&quot;file&quot;:&quot;at add2 (file:///home/john/index.html:67:16)&quot;}
{&quot;name&quot;:&quot;StackTraceError&quot;,&quot;msg&quot;:&quot;Internal error.&quot;,&quot;env&quot;:&quot;&quot;,&quot;file&quot;:&quot;at main (file:///home/john/index.html:76:5)&quot;}
{&quot;file&quot;:&quot;at file:///home/john/index.html:84:3&quot;}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs json"><code>{<span class="hljs-attr">"name"</span>:<span class="hljs-string">"StackTraceError"</span>,<span class="hljs-attr">"msg"</span>:<span class="hljs-string">"Internal error."</span>,<span class="hljs-attr">"env"</span>:<span class="hljs-string">"a::0::b::2::sum::2"</span>,<span class="hljs-attr">"file"</span>:<span class="hljs-string">"at add (file:///home/john/index.html:57:11)"</span>}
{<span class="hljs-attr">"name"</span>:<span class="hljs-string">"StackTraceError"</span>,<span class="hljs-attr">"msg"</span>:<span class="hljs-string">"Internal error."</span>,<span class="hljs-attr">"env"</span>:<span class="hljs-string">"a:;2"</span>,<span class="hljs-attr">"file"</span>:<span class="hljs-string">"at add2 (file:///home/john/index.html:67:16)"</span>}
{<span class="hljs-attr">"name"</span>:<span class="hljs-string">"StackTraceError"</span>,<span class="hljs-attr">"msg"</span>:<span class="hljs-string">"Internal error."</span>,<span class="hljs-attr">"env"</span>:<span class="hljs-string">""</span>,<span class="hljs-attr">"file"</span>:<span class="hljs-string">"at main (file:///home/john/index.html:76:5)"</span>}
{<span class="hljs-attr">"file"</span>:<span class="hljs-string">"at file:///home/john/index.html:84:3"</span>}</code></pre>
<p> 上面这种做法有三个问题</p>
<ol>
<li>V8引擎不会对包含<code>try/catch</code>的函数进行优化，如果每个函数都包含<code>try/catch</code>那会严重影响执行效率。</li>
<li>这种方式显然不能让每个开发人员手写，必须通过预编译器来静态织入，开发难度有点大哦。</li>
<li>像<code>sum</code>这种临时变量其实并不用记录，因为它可以被运算出来，只要记录<code>a</code>和<code>b</code>即可。</li>
</ol>
<p> 假如我们写的全是纯函数（就是相同入参必定得到相同的返回值，函数内部不依赖外部状态，如加法一样，1+1永远等于2），那么我们只需捕获入口/公用函数的入参即可恢复整个案发现场了。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function add(a, b){
  var sum = a + b
  throw Error()
  return sum
}

function add2(a){
  try{
    return 2 + add(0, a)
  }
  catch(e){
    throw {error:e, env:[&quot;a:&quot;, a].join(&quot;::&quot;)})
  }
}

function main(){
  add2(2)
}

try{
  main()
} catch(e){
  console.log(e+'')
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
  <span class="hljs-keyword">var</span> sum = a + b
  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>()
  <span class="hljs-keyword">return</span> sum
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a</span>)</span>{
  <span class="hljs-keyword">try</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + add(<span class="hljs-number">0</span>, a)
  }
  <span class="hljs-keyword">catch</span>(e){
    <span class="hljs-keyword">throw</span> {<span class="hljs-attr">error</span>:e, <span class="hljs-attr">env</span>:[<span class="hljs-string">"a:"</span>, a].join(<span class="hljs-string">"::"</span>)})
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
  add2(<span class="hljs-number">2</span>)
}

<span class="hljs-keyword">try</span>{
  main()
} <span class="hljs-keyword">catch</span>(e){
  <span class="hljs-built_in">console</span>.log(e+<span class="hljs-string">''</span>)
}</code></pre>
<p> 然后我们就可以拿着报错信息从<code>add2</code>逐步调试到<code>add</code>中了。假如用ClojureScript我们还可以定义个macro简化一下</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=";; 私有函数
(defn- add [a b]
  (let [sum (+ a b)]
    (throw (Error.))
    sum))
;; 入口/公用函数
(defn-pub add2 [a]
  (+ 2 (add 0 a)))

(defn main []
  (add2 2))

(try
 (main)
 (catch e
  (println e)))" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs clojure"><code><span class="hljs-comment">;; 私有函数</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn-</span></span> add [a b]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [sum (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> a b)]
    (<span class="hljs-name"><span class="hljs-builtin-name">throw</span></span> (<span class="hljs-name">Error.</span>))
    sum))
<span class="hljs-comment">;; 入口/公用函数</span>
(<span class="hljs-name">defn-pub</span> add2 [a]
  (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">2</span> (<span class="hljs-name">add</span> <span class="hljs-number">0</span> a)))

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> main []
  (<span class="hljs-name">add2</span> <span class="hljs-number">2</span>))

(<span class="hljs-name"><span class="hljs-builtin-name">try</span></span>
 (<span class="hljs-name">main</span>)
 (<span class="hljs-name">catch</span> e
  (<span class="hljs-name">println</span> e)))</code></pre>
<p>defn-pub macro的定义</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="(defmacro defn-pub [name args &amp; body]
  (let [e (gensym)
        arg-names (mapv str args)]
    `(def ~name
       (fn ~args
         (try ~@body
           (catch js/Object ~e
             (throw (clj->js {:e ~e, :env (zipmap ~arg-names ~args)}))))))))" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs clojure"><code>(<span class="hljs-name"><span class="hljs-builtin-name">defmacro</span></span> defn-pub [name args &amp; body]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [e (<span class="hljs-name"><span class="hljs-builtin-name">gensym</span></span>)
        arg-names (<span class="hljs-name"><span class="hljs-builtin-name">mapv</span></span> str args)]
    `(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> ~name
       (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> ~args
         (<span class="hljs-name"><span class="hljs-builtin-name">try</span></span> ~@body
           (<span class="hljs-name">catch</span> js/Object ~e
             (<span class="hljs-name"><span class="hljs-builtin-name">throw</span></span> (<span class="hljs-name">clj-&gt;js</span> {<span class="hljs-symbol">:e</span> ~e, <span class="hljs-symbol">:env</span> (<span class="hljs-name"><span class="hljs-builtin-name">zipmap</span></span> ~arg-names ~args)}))))))))</code></pre>
<h2 id="articleHeader11">总结</h2>
<p> 写到这里其实也没有一个很好的方式去捕获案发现场证据，在入口/公用函数中加入<code>try/catch</code>是我现阶段能想到比较可行的方式，请各位多多指点。<br>尊重原创，转载请注明转自：<a href="http://www.cnblogs.com/fsjohnhuang/p/7729527.html" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/fsjohn...</a>  ^_^肥仔John</p>
<h2 id="articleHeader12">参考</h2>
<p><a href="http://www.cnblogs.com/exiahan/p/4310010.html" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/exiaha...</a><br><a href="http://blog.csdn.net/qiu265843468/article/details/17844419" rel="nofollow noreferrer" target="_blank">http://blog.csdn.net/qiu26584...</a><br><a href="http://lucasfcosta.com/2017/02/17/JavaScript-Errors-and-Stack-Traces.html" rel="nofollow noreferrer" target="_blank">http://lucasfcosta.com/2017/0...</a><br><a href="http://blog.shaochuancs.com/about-error-capturestacktrace/" rel="nofollow noreferrer" target="_blank">http://blog.shaochuancs.com/a...</a></p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
前端魔法堂——调用栈，异常实例中的宝藏

## 原文链接
[https://segmentfault.com/a/1190000011717178](https://segmentfault.com/a/1190000011717178)

