---
title: '全面进阶 H5 直播' 
date: 2019-01-17 2:30:25
hidden: true
slug: 8hk4d2ujrx8
categories: [reprint]
---

{{< raw >}}

                    
<h2 id="articleHeader0">视频格式？编码？</h2>
<p>如果我们想要理解 HTML5 视频，首先需要知道，你应该知道，但你不知道的内容？那怎么去判断呢？<br>ok，很简单，我提几个问题即可，如果某些童鞋知道答案的话，可以直接跳过。</p>
<ol>
<li><p>你知道 ogg,mp4,flv,webm（前面加个点 <code>.</code>）这些叫做什么吗？</p></li>
<li><p>那 FLV，MPEG-4，VP8 是啥？</p></li>
<li><p>如果，基友问你要片源，你会说我这是 mp4 的还是 MPEG-4 的呢？</p></li>
</ol>
<p>当然，还有一些问题，我这里就不废话了。上面主要想说的其实就两个概念：<a href="https://zh.wikipedia.org/wiki/%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F" rel="nofollow noreferrer" target="_blank">视频文件格式</a>（容器格式），<a href="https://zh.wikipedia.org/wiki/%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8" rel="nofollow noreferrer" target="_blank">视频编解码器</a>（视频编码格式）。当然，还有另外一种，叫做音频编解码器。简而言之，就是这三个概念比较重要：</p>
<ul>
<li><p>视频文件格式（容器格式）</p></li>
<li><p>视频编解码器（视频编码格式）</p></li>
<li><p>音频编解码器（音频编码格式）</p></li>
</ul>
<p>这里，我们主要讲解一下前面两个。视频一开始会由两个端采集，一个是视频输入口，是一个音频输入口。然后，采集的数据会分别进行相关处理，简而言之就是，将视频/音频流，通过一定的手段转换为比特流。最终，将这里比特流以一定顺序放到一个盒子里进行存放，从而生成我们最终所看到的，比如，mp4/mp3/flv 等等音视频格式。</p>
<h3 id="articleHeader1">视频编码格式</h3>
<p>视频编码格式就是我们上面提到的第一步，将物理流转换为比特流，并且进行压缩。同样，它的压缩编码格式会决定它的视频文件格式。所以，第一步很重要。针对于 HTML5 中的 video/audio，它实际上是支持多种编码格式的，但局限于各浏览器厂家的普及度，目前视频格式支持度最高的是 MPEG-4/H.264，音频则是 MP3/AC3。（下面就主要说下视频的，音频就先不谈了。）</p>
<p>目前市面上，主流浏览器支持的几个有：</p>
<ul>
<li><p>H.264</p></li>
<li><p>MEPG-4 第 2 部分</p></li>
<li><p>VP8</p></li>
<li><p>Ogg</p></li>
<li><p>WebM（免费）</p></li>
</ul>
<p>其它格式，我们这里就不过多赘述，来看一下前两个比较有趣的。如下图：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916402?w=916&amp;h=262" src="https://static.alili.tech/img/remote/1460000008916402?w=916&amp;h=262" alt="demo" title="demo" style="cursor: pointer;"></span></p>
<p>请问，上面箭头所指的编码格式是同一个吗？</p>
<p>答案是：No~</p>
<p>因为，MPEG-4 实际上是于 1999 年提出的一个标准。而 H.264 则是后台作为优化提出的新的标准。简单来说就是，<strong>我们通常说的 MPEG-4 其实就是MPEG-4 Part 2。而，H.264 则是MPEG-4（第十部分，也叫ISO/IEC 14496-10），又可以理解为 MPEG-4 AVC</strong>。而两者，不同的地方，可以参考：<a href="http://www.jianshu.com/p/4def60dd594f" rel="nofollow noreferrer" target="_blank">latthias</a> 的讲解。简单的区别是：H.264 压缩率比以前的 MPEG-4（第 2 部分） 高很多。简单可以参考的就是：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916403?w=964&amp;h=368" src="https://static.alili.tech/img/remote/1460000008916403?w=964&amp;h=368" alt="demo" title="demo" style="cursor: pointer;"></span></p>
<p>详细参考: <a href="http://www.jianshu.com/p/4def60dd594f" rel="nofollow noreferrer" target="_blank">编码格式详解</a></p>
<h3 id="articleHeader2">视频文件格式</h3>
<p>视频文件格式实际上，我们常常称作为容器格式，也就是，我们一般生活中最经常谈到的格式，flv，mp4，ogg 格式等。<strong>它就可以理解为将比特流按照一定顺序放进特定的盒子里。</strong>那选用不同格式来装视频有什么问题吗？<br>答案是，没有任何问题，但是你需要知道如何将该盒子解开，并且能够找到对应的解码器进行解码。那如果按照这样看的话，对于这些 mp4，ogv，webm等等视频格式，只要我有这些对应的解码器以及播放器，那么就没有任何问题。那么针对于，将视频比特流放进一个盒子里面，如果其中某一段出现问题，那么最终生成的文件实际上是不可用的，因为这个盒子本身就是有问题的。<br>不过，上面有一个误解的地方在于，我只是将视频理解为一个静态的流。试想一下，如果一个视频需要持续不断的播放，例如，直播，现场播报等。这里，我们就拿 <a href="http://wolfcrow.com/blog/program-stream-vs-transport-stream-the-simple-difference/" rel="nofollow noreferrer" target="_blank">TS/PS</a> 流来进行讲解。</p>
<ul>
<li><p>PS（Program Stream）: 静态文件流</p></li>
<li><p>TS（Transport Stream）: 动态文件流</p></li>
</ul>
<p>针对于上面两种容器格式，实际上是对一个视频比特流做了不一样的处理。</p>
<ul>
<li><p>PS: 将完成视频比特流放到一个盒子里，生成固定的文件</p></li>
<li><p>TS: 将接受到的视频，分成不同的盒子里。最终生成带有多个盒子的文件。</p></li>
</ul>
<p>那么结果就是，如果一个或多个盒子出现损坏，PS 格式无法观看，而 TS 只是会出现跳帧或者马赛克效应。两者具体的区别就是：<strong>对于视频的容错率越高，则会选用 TS，对视频容错率越低，则会选用 PS。</strong></p>
<p>常用为：</p>
<ul>
<li><p>AVI：MPEG-2，DIVX，XVID，AC-1，H.264;</p></li>
<li><p>WMV：WMV，AC-1;</p></li>
<li><p>RM、RMVB：RV， RM;</p></li>
<li><p>MOV：MPEG-2，XVID，H.264;</p></li>
<li><p>TS/PS：MPEG-2，H.264，MPEG-4;</p></li>
<li><p>MKV：可以封装所有的视频编码格式。</p></li>
</ul>
<p>详细参考：<a href="https://zh.wikipedia.org/wiki/%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F" rel="nofollow noreferrer" target="_blank">视频文件格式</a></p>
<h2 id="articleHeader3">直播协议</h2>
<p>2016 年是直播元年，一是由于各大宽带提供商顺应民意<code>增宽降价</code>，二是大量资本流进了直播板块，促进了技术的更新迭代。市面上，最常用的是 Apple 推出的 HLS 直播协议（原始支持 H5 播放），当然，还有 RTMP、HTTP-FLV、RTP等。<br>这里，再问一个问题：</p>
<ol><li><p>HLS 和 MPEG-4/H.264 以及容器格式 TS/PS 是啥关系？</p></li></ol>
<p>简单来说，没关系。</p>
<p><strong>HLS 根本就不会涉及到视频本身的解码问题。它的存在只是为了确保你的视频能够及时，快速，正确的播放。</strong></p>
<p>现在，直播行业依旧很火，而 HTML5 直播，一直以来都是一个比较蛋疼的内容。一是，浏览器厂商更新速度比较慢，二是，这并不是我们前端专攻的一块，所以，有时候的确很鸡肋。当然，进了前端，你就别想着休息。接下来，我们来详细的看一下市面上主流的几个协议。</p>
<h3 id="articleHeader4">HLS</h3>
<p>HLS 全称是 HTTP Live Streaming。这是 <a href="https://developer.apple.com/streaming/" rel="nofollow noreferrer" target="_blank">Apple</a> 提出的直播流协议。目前，IOS 和 高版本 Android 都支持 HLS。那什么是 HLS 呢？<br>HLS 主要的两块内容是 <code>.m3u8</code> 文件和 <code>.ts</code> 播放文件。接受服务器会将接受到的视频流进行缓存，然后缓存到一定程度后，会将这些视频流进行编码格式化，同时会生成一份 <code>.m3u8</code> 文件和其它很多的 <code>.ts</code> 文件。根据 <a href="https://en.wikipedia.org/wiki/HTTP_Live_Streaming" rel="nofollow noreferrer" target="_blank">wiki</a> 阐述，HLS 的基本架构为：</p>
<ul>
<li>
<p>服务器：后台服务器接受视频流，然后进行编码和片段化。</p>
<ul>
<li><p>编码：视频格式编码采用 H.264。音频编码为 AAC, MP3, AC-3，EC-3。然后使用 MPEG-2 Transport Stream 作为容器格式。</p></li>
<li><p>分片：将 TS 文件分成若干个相等大小的 <code>.ts</code> 文件。并且生成一个 <code>.m3u8</code> 作为索引文件（确保包的顺序）</p></li>
</ul>
</li>
<li><p>分发：由于 HLS 是基于 HTTP 的，所以，作为分发，最常用的就是 CDN 了。</p></li>
<li><p>客户端：使用一个 URL 去下载 m3u8 文件，然后，开始下载 ts 文件，下载完成后，使用 <code>playback software</code>（即时播放器） 进行播放。</p></li>
</ul>
<p>这里，我们着重介绍一下客户端的过程。首先，直播之所以是直播，在于它的内容是实时更新的。那 HLS 是怎么完成呢？<br>我们使用 HLS 直接就用一个 video 进行包括即可：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<video controls autoplay>  
    <source src=&quot;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&quot; type=&quot;application/vnd.apple.mpegurl&quot; /> 
    <p class=&quot;warning&quot;>Your browser does not support HTML5 video.</p>  
</video>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code>&lt;<span class="hljs-selector-tag">video</span> controls autoplay&gt;  
    &lt;source src=<span class="hljs-string">"http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8"</span> type=<span class="hljs-string">"application/vnd.apple.mpegurl"</span> /&gt; 
    &lt;<span class="hljs-selector-tag">p</span> class=<span class="hljs-string">"warning"</span>&gt;Your browser does not support HTML5 <span class="hljs-selector-tag">video</span>.&lt;/p&gt;  
&lt;/video&gt;</code></pre>
<p>根据上面的描述，它实际上就是去请求一个 <code>.m3u8</code> 的索引文件。该文件包含了对 <code>.ts</code> 文件的相关描述，例如：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#EXT-X-VERSION:3            PlayList 的版本，可带可不带。下面有说明
#EXTM3U                     m3u文件头
#EXT-X-TARGETDURATION:10    分片最大时长，单位为 s
#EXT-X-MEDIA-SEQUENCE:1     第一个TS分片的序列号，如果没有，默认为 0
#EXT-X-ALLOW-CACHE          是否允许cache
#EXT-X-ENDLIST              m3u8文件结束符
#EXTINF                     指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code><span class="hljs-selector-id">#EXT-X-VERSION</span>:<span class="hljs-number">3</span>            PlayList 的版本，可带可不带。下面有说明
<span class="hljs-selector-id">#EXTM3U</span>                     m3u文件头
<span class="hljs-selector-id">#EXT-X-TARGETDURATION</span>:<span class="hljs-number">10</span>    分片最大时长，单位为 s
<span class="hljs-selector-id">#EXT-X-MEDIA-SEQUENCE</span>:<span class="hljs-number">1</span>     第一个TS分片的序列号，如果没有，默认为 <span class="hljs-number">0</span>
<span class="hljs-selector-id">#EXT-X-ALLOW-CACHE</span>          是否允许cache
<span class="hljs-selector-id">#EXT-X-ENDLIST</span>              m3u8文件结束符
<span class="hljs-selector-id">#EXTINF</span>                     指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效</code></pre>
<p>不过，这只是一个非常简单，不涉及任何功能的直播流。实际上，HLS 的整个架构，可以分为：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916404?w=1061&amp;h=924" src="https://static.alili.tech/img/remote/1460000008916404?w=1061&amp;h=924" alt="stream_playlists_2x.png-35.5kB" title="stream_playlists_2x.png-35.5kB" style="cursor: pointer;"></span></p>
<p>当然，如果你使用的是 <code>masterplaylist</code> 作为链接，如：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<video controls autoplay>  
    <source src=&quot;http://devimages.apple.com/iphone/samples/bipbop/masterplaylist.m3u8&quot; type=&quot;application/vnd.apple.mpegurl&quot; /> 
    <p class=&quot;warning&quot;>Your browser does not support HTML5 video.</p>  
</video>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code>&lt;<span class="hljs-selector-tag">video</span> controls autoplay&gt;  
    &lt;source src=<span class="hljs-string">"http://devimages.apple.com/iphone/samples/bipbop/masterplaylist.m3u8"</span> type=<span class="hljs-string">"application/vnd.apple.mpegurl"</span> /&gt; 
    &lt;<span class="hljs-selector-tag">p</span> class=<span class="hljs-string">"warning"</span>&gt;Your browser does not support HTML5 <span class="hljs-selector-tag">video</span>.&lt;/p&gt;  
&lt;/video&gt;</code></pre>
<p>我们看一下，masterplaylist 里面具体的内容是啥：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#EXTM3U
#EXT-X-VERSION:6
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2855600,CODECS=&quot;avc1.4d001f,mp4a.40.2&quot;,RESOLUTION=960x540
live/medium.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=5605600,CODECS=&quot;avc1.640028,mp4a.40.2&quot;,RESOLUTION=1280x720
live/high.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1755600,CODECS=&quot;avc1.42001f,mp4a.40.2&quot;,RESOLUTION=640x360
live/low.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=545600,CODECS=&quot;avc1.42001e,mp4a.40.2&quot;,RESOLUTION=416x234
live/cellular.m3u8" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code><span class="hljs-selector-id">#EXTM3U</span>
<span class="hljs-selector-id">#EXT-X-VERSION</span>:<span class="hljs-number">6</span>
<span class="hljs-selector-id">#EXT-X-STREAM-INF</span>:PROGRAM-ID=<span class="hljs-number">1</span>,BANDWIDTH=<span class="hljs-number">2855600</span>,CODECS=<span class="hljs-string">"avc1.4d001f,mp4a.40.2"</span>,RESOLUTION=<span class="hljs-number">960</span>x540
live/medium<span class="hljs-selector-class">.m3u8</span>
<span class="hljs-selector-id">#EXT-X-STREAM-INF</span>:PROGRAM-ID=<span class="hljs-number">1</span>,BANDWIDTH=<span class="hljs-number">5605600</span>,CODECS=<span class="hljs-string">"avc1.640028,mp4a.40.2"</span>,RESOLUTION=<span class="hljs-number">1280</span>x720
live/high<span class="hljs-selector-class">.m3u8</span>
<span class="hljs-selector-id">#EXT-X-STREAM-INF</span>:PROGRAM-ID=<span class="hljs-number">1</span>,BANDWIDTH=<span class="hljs-number">1755600</span>,CODECS=<span class="hljs-string">"avc1.42001f,mp4a.40.2"</span>,RESOLUTION=<span class="hljs-number">640</span>x360
live/low<span class="hljs-selector-class">.m3u8</span>
<span class="hljs-selector-id">#EXT-X-STREAM-INF</span>:PROGRAM-ID=<span class="hljs-number">1</span>,BANDWIDTH=<span class="hljs-number">545600</span>,CODECS=<span class="hljs-string">"avc1.42001e,mp4a.40.2"</span>,RESOLUTION=<span class="hljs-number">416</span>x234
live/cellular.m3u8</code></pre>
<p><code>EXT-X-STREAM-INF</code> 这个标签头代表：当前用户的播放环境。masterplaylist 主要干的事就是根据, 当前用户的带宽，分辨率，解码器等条件决定使用哪一个流。所以，master playlist 是为了更好的用户体验而存在的。不过，弊端就是后台储备流的量会成倍增加。<br>现在，我们来主要看一下,如果你使用 master playlist，那么整个流程是啥？<br>当填写了 master playlist URL，那么用户只会下载一次该 master playlist。接着，播放器根据当前的环境决定使用哪一个 media playlist（就是 子 m3u8 文件）。如果，在播放当中，用户的播放条件发生变化时，播放器也会切换对应的 media playlist。关于 master playlist 内容，我们就先介绍到这里。<br>关于 HLS，感觉主要内容还在 media playlist 上。当然，media playlist 还分为三种 list：</p>
<ul>
<li><p>live playlist: 动态列表。顾名思义，该列表是动态变化的，里面的 ts 文件会实时更新，并且过期的 ts 索引会被删除。默认，情况下都是使用动态列表。</p></li>
<li><p>event playlist: 静态列表。它和动态列表主要区别就是，原来的 ts 文件索引不会被删除，该列表是不断更新，而且文件大小会逐渐增大。它会在文件中，直接添加 <code>#EXT-X-PLAYLIST-TYPE:EVENT</code> 作为标识。</p></li>
<li><p>VOD playlist: 全量列表。它就是将所有的 ts 文件都列在 list 当中。如果，使用该列表，就和播放一整个视频没有啥区别了。它是使用 <code>#EXT-X-ENDLIST</code> 表示文件结尾。</p></li>
</ul>
<p><strong>live playlist DEMO：</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#EXTM3U
#EXT-X-VERSION:6
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:26
#EXTINF:9.901,
http://media.example.com/wifi/segment26.ts
#EXTINF:9.901,
http://media.example.com/wifi/segment27.ts
#EXTINF:9.501,
http://media.example.com/wifi/segment28.ts" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code><span class="hljs-selector-id">#EXTM3U</span>
<span class="hljs-selector-id">#EXT-X-VERSION</span>:<span class="hljs-number">6</span>
<span class="hljs-selector-id">#EXT-X-TARGETDURATION</span>:<span class="hljs-number">10</span>
<span class="hljs-selector-id">#EXT-X-MEDIA-SEQUENCE</span>:<span class="hljs-number">26</span>
<span class="hljs-selector-id">#EXTINF</span>:<span class="hljs-number">9.901</span>,
http:<span class="hljs-comment">//media.example.com/wifi/segment26.ts</span>
<span class="hljs-selector-id">#EXTINF</span>:<span class="hljs-number">9.901</span>,
http:<span class="hljs-comment">//media.example.com/wifi/segment27.ts</span>
<span class="hljs-selector-id">#EXTINF</span>:<span class="hljs-number">9.501</span>,
http:<span class="hljs-comment">//media.example.com/wifi/segment28.ts</span></code></pre>
<p><strong>evet playlist DEMO：</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#EXTM3U
#EXT-X-VERSION:6
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:EVENT
#EXTINF:9.9001,
http://media.example.com/wifi/segment0.ts
#EXTINF:9.9001,
http://media.example.com/wifi/segment1.ts
#EXTINF:9.9001,
http://media.example.com/wifi/segment2.ts" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code><span class="hljs-selector-id">#EXTM3U</span>
<span class="hljs-selector-id">#EXT-X-VERSION</span>:<span class="hljs-number">6</span>
<span class="hljs-selector-id">#EXT-X-TARGETDURATION</span>:<span class="hljs-number">10</span>
<span class="hljs-selector-id">#EXT-X-MEDIA-SEQUENCE</span>:<span class="hljs-number">0</span>
<span class="hljs-selector-id">#EXT-X-PLAYLIST-TYPE</span>:EVENT
<span class="hljs-selector-id">#EXTINF</span>:<span class="hljs-number">9.9001</span>,
http:<span class="hljs-comment">//media.example.com/wifi/segment0.ts</span>
<span class="hljs-selector-id">#EXTINF</span>:<span class="hljs-number">9.9001</span>,
http:<span class="hljs-comment">//media.example.com/wifi/segment1.ts</span>
<span class="hljs-selector-id">#EXTINF</span>:<span class="hljs-number">9.9001</span>,
http:<span class="hljs-comment">//media.example.com/wifi/segment2.ts</span></code></pre>
<p><strong>VOD playlist DEMO：</strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#EXTM3U
#EXT-X-VERSION:6
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:9.9001,
http://media.example.com/wifi/segment0.ts
#EXTINF:9.9001,
http://media.example.com/wifi/segment1.ts
#EXTINF:9.9001,
http://media.example.com/wifi/segment2.ts
#EXT-X-ENDLIST" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs vala"><code><span class="hljs-meta">#EXTM3U</span>
<span class="hljs-meta">#EXT-X-VERSION:6</span>
<span class="hljs-meta">#EXT-X-TARGETDURATION:10</span>
<span class="hljs-meta">#EXT-X-MEDIA-SEQUENCE:0</span>
<span class="hljs-meta">#EXT-X-PLAYLIST-TYPE:VOD</span>
<span class="hljs-meta">#EXTINF:9.9001,</span>
http:<span class="hljs-comment">//media.example.com/wifi/segment0.ts</span>
<span class="hljs-meta">#EXTINF:9.9001,</span>
http:<span class="hljs-comment">//media.example.com/wifi/segment1.ts</span>
<span class="hljs-meta">#EXTINF:9.9001,</span>
http:<span class="hljs-comment">//media.example.com/wifi/segment2.ts</span>
<span class="hljs-meta">#EXT-X-ENDLIST</span></code></pre>
<p>上面提到过一个 <code>EXT-X-VERSION</code> 这样的标签，这是用来表示当前 HLS 的版本。那 HLS 有哪些版本呢？<br>根据 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/AboutHTTPLiveStreaming/about/about.html" rel="nofollow noreferrer" target="_blank">apple 官方文档</a> 的说明，我们可以了解到，不同版本的区别：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916405?w=623&amp;h=756" src="https://static.alili.tech/img/remote/1460000008916405?w=623&amp;h=756" alt="page.png-18.4kB" title="page.png-18.4kB" style="cursor: pointer;"></span></p>
<p>当然，HLS 支持的功能，并不只是分片播放（专门适用于直播），它还包括其他应有的功能。</p>
<ul>
<li><p>使用 HTTPS 加密 ts 文件</p></li>
<li><p>快/倒放</p></li>
<li><p>广告插入</p></li>
<li><p>不同分辨率视频切换</p></li>
</ul>
<h4>HLS 的弊端</h4>
<p>由于 HLS 是基于 HTTP 的，所以，它关于 HTTP 的好处，我们大部分都了解，比如，高兼容性，高可扩展性等。不过正由于是 HTTP 协议，所以会在握手协议上造成一定的延迟性。HLS 首次连接时，总共的延时包括：</p>
<ol><li><p>TCP 握手，2. m3u8 文件下载，3. m3u8 下的 ts 文件下载。</p></li></ol>
<p>其中，每个 ts 文件，大概会存放 5s~10s 的时长，并且每个 m3u8 文件会存放 3~8 个 ts 文件。我们折中算一下，5 个 ts 文件，每个时长大约 8s 那么，总的下来，一共延时 40s。当然，这还不算上 TCP 握手，m3u8 文件下载等问题。那优化办法有吗？有的，那就是减少每个 m3u8 文件中的 ts 数量和 ts 文件时长，不过，这样也会成倍的增加后台承受流量请求的压力。所以，这还是需要到业务中去探索最优的配置（打个广告：腾讯云的直播视频流业务，做的确实挺棒。）<br>关于 HLS 的详细内容，可以参考：<a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/AboutHTTPLiveStreaming/about/about.html" rel="nofollow noreferrer" target="_blank">HLS 详解</a><br>关于 m3u8 文件的标签内容，可以参考：<a href="https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-4.3.4" rel="nofollow noreferrer" target="_blank">HLS 标签头详解</a><br>总而言之，HLS 之所以能这么流行，关键在于它的支持度是真的广，所以，对于一般 H5 直播来说，应该是非常友好的。不过，既然是直播，关键在于它的实时性，而 HLS 天生就存在一定的延时，所以，就可以考虑其他低延时的方案，比如 RTMP，HTTP-FLV。下面，我们来看一下 RTMP 内容。</p>
<h3 id="articleHeader5">RTMP</h3>
<p>RTMP 全称为：Real-Time Messaging Protocol 。它是专门应对实时交流场景而开发出来的一个协议。它爹是 <a href="https://en.wikipedia.org/wiki/Macromedia" rel="nofollow noreferrer" target="_blank">Macromedia</a>，后来卖身给了 Adobe。RTMP 根据不同的业务场景，有很多变种：</p>
<ul>
<li><p>纯 RTMP 使用 TCP 连接，默认端口为 1935（有可能被封）。</p></li>
<li><p>RTMPS: 就是 RTMP + TLS/SSL</p></li>
<li><p>RTMPE: RTMP + encryption。在 RTMP 原始协议上使用，Adobe 自身的加密方法</p></li>
<li><p>RTMPT: RTMP + HTTP。使用 HTTP 的方式来包裹 RTMP 流，这样能直接通过防火墙。</p></li>
<li><p>RTMFP: RMPT + UDP。该协议常常用于 P2P 的场景中，针对延时有变态的要求。</p></li>
</ul>
<p>既然是 Adobe 公司开发的（算吧），那么，该协议针对的就是 Flash Video，即，FLV。不过，在移动端上，Flash Player 已经被杀绝了，那为啥还会出现这个呢？简单来说，它主要是针对 PC 端的。RTMP 出现的时候，还是 零几 年的时候，IE 还在大行其道，Flash Player 也并未被各大浏览器所排斥。那时候 RTMP 毋庸置疑的可以在视频界有自己的一席之地。</p>
<p>RTMP 由于借由 TCP 长连接协议，所以，客户端向服务端推流这些操作而言，延时性很低。它会将上传的流分成不同的分片，这些分片的大小，有时候变，有时候不会变。默认情况下就是，64B 的音频数据 + 128B 的视频数据 + 其它数据（比如 头，协议标签等）。但 RTMP 具体传输的时候，会将分片进一步划分为包，即，视频包，音频包，协议包等。因为，RTMP 在进行传输的时候，会建立不同的通道，来进行数据的传输，这样对于不同的资源，对不同的通道设置相关的带宽上限。</p>
<p>RTMP 处理的格式是 MP3/ACC + FLV1。<br>不过，由于支持性的原因，RTMP 并未在 H5 直播中，展示出优势。下列是简单的对比：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916406?w=654&amp;h=101" src="https://static.alili.tech/img/remote/1460000008916406?w=654&amp;h=101" alt="dff.png-15.8kB" title="dff.png-15.8kB" style="cursor: pointer; display: inline;"></span></p>
<h3 id="articleHeader6">HTTP-FLV</h3>
<p>HTTP-FLV 和 RTMPT 类似，都是针对于 FLV 视频格式做的直播分发流。但，两者有着很大的区别。</p>
<ul>
<li>
<p>相同点</p>
<ul>
<li><p>两者都是针对 FLV 格式</p></li>
<li><p>两者延时都很低</p></li>
<li><p>两者都走的 HTTP 通道</p></li>
</ul>
</li>
<li>
<p>不同点</p>
<ul>
<li>
<p>HTTP-FLv</p>
<ul>
<li><p>直接发起长连接，下载对应的 FLV 文件</p></li>
<li><p>头部信息简单</p></li>
</ul>
</li>
<li>
<p>RTMPT</p>
<ul>
<li><p>握手协议过于复杂</p></li>
<li><p>分包，组包过程耗费精力大</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过上面来看，HTTP-FLV 和 RTMPT 确实不是一回事，但，如果了解 <a href="https://github.com/ossrs/srs/wiki" rel="nofollow noreferrer" target="_blank">SRS</a>（simple rtmp server），那么 对 HTTP-FLV 应该清楚不少。SRS 本质上，就是 RTMP + FLV 进行传输。因为 RTMP 发的包很容易处理，通常 RTMP 协议会作为视频上传端来处理，然后经由服务器转换为 FLV 文件，通过 HTTP-FLV 下发给用户。</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916407?w=571&amp;h=229" src="https://static.alili.tech/img/remote/1460000008916407?w=571&amp;h=229" alt="STRU.png-2.9kB" title="STRU.png-2.9kB" style="cursor: pointer;"></span></p>
<p>现在市面上，比较常用的就是 HTTP-FLV 进行播放。但，由于手机端上不支持，所以，H5 的 HTTP-FLV 也是一个痛点。不过，现在 <a href="https://github.com/Bilibili/flv.js?utm_source=tool.lu" rel="nofollow noreferrer" target="_blank">flv.js</a> 可以帮助高版本的浏览器，通过 <a href="http://caniuse.com/#search=mediasource" rel="nofollow noreferrer" target="_blank">mediaSource</a> 来进行解析。HTTP-FLV 的使用方式也很简单。和 HLS 一样，只需要添加一个连接即可：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<object type=&quot;application/x-shockwave-flash&quot; src=&quot;http://s6.pdim.gs/static/a2a36bc596148316.flv&quot;></object>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs nimrod"><code style="word-break: break-word; white-space: initial;">&lt;<span class="hljs-keyword">object</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"application/x-shockwave-flash"</span> src=<span class="hljs-string">"http://s6.pdim.gs/static/a2a36bc596148316.flv"</span>&gt;&lt;/<span class="hljs-keyword">object</span>&gt;</code></pre>
<p>不过，并不是末尾是 <code>.flv</code> 的都是 HTTP-FLV 协议，因为，涉及 FLV 的流有<a href="https://github.com/ossrs/srs/wiki/v2_EN_DeliveryHttpStream%60" rel="nofollow noreferrer" target="_blank">三种</a>，它们三种的使用方式都是一模一样的。</p>
<ul>
<li><p>FLV 文件：相当于就是一整个文件，官方称为 渐进 HTTP 流。它的特点是只能渐进下载，不能进行点播。</p></li>
<li><p>FLV 伪流：该方式，可以通过在末尾添加 <code>?start=xxx</code> 的参数，指定返回的对应开始时间视频数据。该方式比上面那种就多了一个点播的功能。本质上还是 FLV 直播。</p></li>
<li><p>FLV 直播流：这就是 HTTP-FLV 真正所支持的流。SRS 在内部使用的是 RTMP 进行分发，然后在传给用户的使用，经过一层转换，变为 HTTP 流，最终传递给用户。</p></li>
</ul>
<p>上面说到，HTTP-FLV 就是长连接，简而言之只需要加上一个 <code>Connection:keep-alive</code> 即可。关键是它的响应头，由于，HTTP-FLV 传递的是视频格式，所有，它的 <code>Content-Type</code> 和 <code>Transfer-Encoding</code> 需要设置其它值。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Content-Type:video/x-flv
Expires:Fri, 10 Feb 2017 05:24:03 GMT
Pragma:no-cache
Transfer-Encoding:chunked" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs yaml"><code><span class="hljs-attr">Content-Type:</span><span class="hljs-string">video/x-flv</span>
<span class="hljs-attr">Expires:</span><span class="hljs-string">Fri,</span> <span class="hljs-number">10</span> <span class="hljs-string">Feb</span> <span class="hljs-number">2017</span> <span class="hljs-number">05</span><span class="hljs-string">:24:03</span> <span class="hljs-string">GMT</span>
<span class="hljs-attr">Pragma:</span><span class="hljs-literal">no</span><span class="hljs-bullet">-cache</span>
<span class="hljs-attr">Transfer-Encoding:</span><span class="hljs-string">chunked</span></code></pre>
<p>不过，一般而言，直播服务器一般和业务服务是不会放在一块的，所以这里，可能会额外需要支持跨域直播的相关技术。在 XHR2 里面，解决办法也很简单，直接使用 CORS 即可：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 那么整个响应头，可以为：
Access-Control-Allow-credentials:true
Access-Control-Allow-max-age:86400
Access-Control-Allow-methods:GET,POST,OPTIONS
Access-Control-Allow-Origin:*
Cache-Control:no-cache
Content-Type:video/x-flv
Expires:Fri, 10 Feb 2017 05:24:03 GMT
Pragma:no-cache
Transfer-Encoding:chunked" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs yaml"><code><span class="hljs-string">//</span> <span class="hljs-string">那么整个响应头，可以为：</span>
<span class="hljs-attr">Access-Control-Allow-credentials:</span><span class="hljs-literal">true</span>
<span class="hljs-attr">Access-Control-Allow-max-age:</span><span class="hljs-number">86400</span>
<span class="hljs-attr">Access-Control-Allow-methods:</span><span class="hljs-string">GET,POST,OPTIONS</span>
<span class="hljs-attr">Access-Control-Allow-Origin:</span><span class="hljs-string">*</span>
<span class="hljs-attr">Cache-Control:</span><span class="hljs-literal">no</span><span class="hljs-bullet">-cache</span>
<span class="hljs-attr">Content-Type:</span><span class="hljs-string">video/x-flv</span>
<span class="hljs-attr">Expires:</span><span class="hljs-string">Fri,</span> <span class="hljs-number">10</span> <span class="hljs-string">Feb</span> <span class="hljs-number">2017</span> <span class="hljs-number">05</span><span class="hljs-string">:24:03</span> <span class="hljs-string">GMT</span>
<span class="hljs-attr">Pragma:</span><span class="hljs-literal">no</span><span class="hljs-bullet">-cache</span>
<span class="hljs-attr">Transfer-Encoding:</span><span class="hljs-string">chunked</span></code></pre>
<p>对于 HTTP-FLV 来说，关键难点在于 RTMP 和 HTTP 协议的转换，这里我就不多说了。因为，我们主要针对的是前端开发，讲一下和前端相关的内容。</p>
<p>接下来，我们在主要来介绍一下 FLV 格式的。因为，后面我们需要通过 mediaSource 来解码 FLV。</p>
<h2 id="articleHeader7">FLV 格式浅析</h2>
<p>FLV 原始格式，Adobe 可以直接看 <a href="https://www.adobe.com/content/dam/Adobe/en/devnet/flv/pdfs/video_file_format_spec_v10.pdf" rel="nofollow noreferrer" target="_blank">flv格式详解</a>。我这里就抽主要的内容讲讲。FLV 也是与时俱进，以前 FLV 的格式叫做 FLV，新版的可以叫做 F4V。两者的区别，简单的区分方法就是：</p>
<ul>
<li><p>FLV 是专门针对 Flash 播放器的</p></li>
<li><p>F4V 是有点像 MEPG 格式的 Flash 播放，主要为了兼容 H.264/ACC。F4V 不支持 FLV（两者本来都不是同一个格式）</p></li>
</ul>
<p>这里我们主要针对 FLV 进行相关了解。因为，一般情况下，后台发送视频流时，为了简洁快速，就是发送 FLV 视频。FLV 由于年限比较久，它所支持的内容是 H.263，VP6 codec。FLV 一般可以嵌套在 <code>.swf</code> 文件当中，不过，对于 <code>HTTP-FLV</code> 等 FLV 直播流来说，一般直接使用 <code>.flv</code> 文件即可。在 07 年的时候，提出了 F4V 这个视频格式，当然，FLV 等也会向前兼容。</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916408?w=832&amp;h=349" src="https://static.alili.tech/img/remote/1460000008916408?w=832&amp;h=349" alt="flv" title="flv" style="cursor: pointer;"></span></p>
<p>这里，我们来正式介绍一下 FLV 的格式。一个完整的 FLV 流包括 FLV Header + FLV Packets。</p>
<h3 id="articleHeader8">FLV Header</h3>
<p>FLV 格式头不难，就几个字段：</p>
<table>
<thead><tr>
<th align="left">Field</th>
<th align="left">Data Type</th>
<th align="left">Default</th>
<th>Details</th>
</tr></thead>
<tbody>
<tr>
<td align="left">Signature</td>
<td align="left">byte[3]</td>
<td align="left">“FLV”</td>
<td>有三个B的大小,算是一种身份的象征</td>
</tr>
<tr>
<td align="left">Version</td>
<td align="left">uint8</td>
<td align="left">1</td>
<td>只有 0x01 是有效的。其实就是默认值</td>
</tr>
<tr>
<td align="left">Flags</td>
<td align="left">uint8 bitmask</td>
<td align="left">0x05</td>
<td>表示该流的特征。0x04 是 audio，0x01 是 video，0x05 是 audio+video</td>
</tr>
<tr>
<td align="left">Header Size</td>
<td align="left">uint32_be</td>
<td align="left">9</td>
<td>用来跳过多余的头</td>
</tr>
</tbody>
</table>
<h3 id="articleHeader9">FLV Packets</h3>
<p>在 FLV 的头部之后，就正式开始发送 FLV 文件。文件会被拆解为数个包（FLV tags）进行传输。每个包都带有 15B 的头。前 4 个字节是用来代表前一个包的头部内容，用来完成倒放的功能。整个包的结构为：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916409?w=820&amp;h=360" src="https://static.alili.tech/img/remote/1460000008916409?w=820&amp;h=360" alt="FLV" title="FLV" style="cursor: pointer;"></span></p>
<p>具体解释如下：</p>
<table>
<thead><tr>
<th align="left">字段</th>
<th align="left">字段大小</th>
<th align="left">默认值</th>
<th align="left">详解</th>
</tr></thead>
<tbody>
<tr>
<td align="left">Size of previous packet</td>
<td align="left">uint32_be</td>
<td align="left">0</td>
<td align="left">关于前一个包的信息，如果是第一个包，则该部分为 NULL</td>
</tr>
<tr>
<td align="left">Packet Type</td>
<td align="left">uint8</td>
<td align="left">18</td>
<td align="left">设置包的内容，如果是第一个包，则该部分为 AMF 元数据</td>
</tr>
<tr>
<td align="left">Payload Size</td>
<td align="left">uint24_be</td>
<td align="left">varies</td>
<td align="left">该包的大小</td>
</tr>
<tr>
<td align="left">Timestamp Lower</td>
<td align="left">uint24_be</td>
<td align="left">0</td>
<td align="left">起始时间戳</td>
</tr>
<tr>
<td align="left">Timestamp Upper</td>
<td align="left">uint8</td>
<td align="left">0</td>
<td align="left">持续时间戳，通常加上 Lower 实际上戳，代表整个时间。</td>
</tr>
<tr>
<td align="left">Stream ID</td>
<td align="left">uint24_be</td>
<td align="left">0</td>
<td align="left">流的类型，第一个流设为 NULL</td>
</tr>
<tr>
<td align="left">Payload Data</td>
<td align="left">freeform</td>
<td align="left">varies</td>
<td align="left">传输数据</td>
</tr>
</tbody>
</table>
<p>其中，由于 Packet Type 的值可以取多个， 需要额外说明一下。</p>
<ul><li>
<p>Packet Type</p>
<ul>
<li><p>1: RTMP 包的大小</p></li>
<li><p>3: RTMP 字节读包反馈，RTMP ping，RTMP 服务器带宽，RTMP 客户端带宽</p></li>
<li><p>8: 音频和视频的数据</p></li>
<li><p>15: RTMP flex 流</p></li>
<li><p>24: 经过封装的 flash video。</p></li>
</ul>
</li></ul>
<p>上面是关于 FLV 简单的介绍。不过，如果没有 `<br>Media Source Extensions` 的帮助，那么上面说的基本上全是废话。由于，Flash Player 已经被时代所遗弃，所以，我们不能在浏览器上，顺利的播放 FLV 视频。接下来，我们先来详细了解一下 MSE 的相关内容。</p>
<h2 id="articleHeader10">Media Source Extensions</h2>
<p>在没有 MSE 出现之前，前端对 video 的操作，仅仅局限在对视频文件的操作，而并不能对视频流做任何相关的操作。现在 MSE 提供了一系列的<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaSource" rel="nofollow noreferrer" target="_blank">接口</a>，使开发者可以直接提供 media stream。</p>
<p>那 MSE 是如何完成视频流的加载和播放呢？</p>
<h3 id="articleHeader11">入门实例</h3>
<p>这可以参考 google 的 <a href="https://developers.google.com/web/fundamentals/getting-started/primers/media-source-extensions" rel="nofollow noreferrer" target="_blank">MSE 简介</a></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var vidElement = document.querySelector('video');

if (window.MediaSource) {
  var mediaSource = new MediaSource();
  vidElement.src = URL.createObjectURL(mediaSource);
  mediaSource.addEventListener('sourceopen', sourceOpen);
} else {
  console.log(&quot;The Media Source Extensions API is not supported.&quot;)
}

function sourceOpen(e) {
  URL.revokeObjectURL(vidElement.src);
  var mime = 'video/webm; codecs=&quot;opus, vp9&quot;';
  var mediaSource = e.target;
  var sourceBuffer = mediaSource.addSourceBuffer(mime);
  var videoUrl = 'droid.webm';
  fetch(videoUrl)
    .then(function(response) {
      return response.arrayBuffer();
    })
    .then(function(arrayBuffer) {
      sourceBuffer.addEventListener('updateend', function(e) {
        if (!sourceBuffer.updating &amp;&amp; mediaSource.readyState === 'open') {
          mediaSource.endOfStream();
        }
      });
      sourceBuffer.appendBuffer(arrayBuffer);
    });
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> vidElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'video'</span>);

<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.MediaSource) {
  <span class="hljs-keyword">var</span> mediaSource = <span class="hljs-keyword">new</span> MediaSource();
  vidElement.src = URL.createObjectURL(mediaSource);
  mediaSource.addEventListener(<span class="hljs-string">'sourceopen'</span>, sourceOpen);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"The Media Source Extensions API is not supported."</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sourceOpen</span>(<span class="hljs-params">e</span>) </span>{
  URL.revokeObjectURL(vidElement.src);
  <span class="hljs-keyword">var</span> mime = <span class="hljs-string">'video/webm; codecs="opus, vp9"'</span>;
  <span class="hljs-keyword">var</span> mediaSource = e.target;
  <span class="hljs-keyword">var</span> sourceBuffer = mediaSource.addSourceBuffer(mime);
  <span class="hljs-keyword">var</span> videoUrl = <span class="hljs-string">'droid.webm'</span>;
  fetch(videoUrl)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>{
      <span class="hljs-keyword">return</span> response.arrayBuffer();
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arrayBuffer</span>) </span>{
      sourceBuffer.addEventListener(<span class="hljs-string">'updateend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (!sourceBuffer.updating &amp;&amp; mediaSource.readyState === <span class="hljs-string">'open'</span>) {
          mediaSource.endOfStream();
        }
      });
      sourceBuffer.appendBuffer(arrayBuffer);
    });
}</code></pre>
<p>可以从上面的代码看出，一套完整的执行代码，不仅需要使用 MSE 而且，还有一下这些相关的 API。</p>
<ul>
<li><p>HTMLVideoElement.getVideoPlaybackQuality()</p></li>
<li><p>SourceBuffer</p></li>
<li><p>SourceBufferList</p></li>
<li><p>TextTrack.sourceBuffer</p></li>
<li><p>TrackDefault</p></li>
<li><p>TrackDefaultList</p></li>
<li><p>URL.createObjectURL()</p></li>
<li><p>VideoPlaybackQuality</p></li>
<li><p>VideoTrack.sourceBuffer</p></li>
</ul>
<p>我们简单讲解一下上面的流程。根据 google 的阐述，整个过程可以为：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916410?w=305&amp;h=250" src="https://static.alili.tech/img/remote/1460000008916410?w=305&amp;h=250" alt="image.png-16kB" title="image.png-16kB" style="cursor: pointer;"></span></p>
<ul>
<li><p>第一步，通过异步拉取数据。</p></li>
<li><p>第二步，通过 MediaSource 处理数据。</p></li>
<li><p>第三步，将数据流交给 audio/video 标签进行播放。</p></li>
</ul>
<p>而中间传递的数据都是通过 <code>Buffer</code> 的形式来进行传递的。</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000008916411?w=504&amp;h=574" src="https://static.alili.tech/img/remote/1460000008916411?w=504&amp;h=574" alt="image.png-29.5kB" title="image.png-29.5kB" style="cursor: pointer;"></span></p>
<p>中间有个需要注意的点，MS 的实例通过 <code>URL.createObjectURL()</code> 创建的 url 并不会同步连接到 video.src。换句话说，<code>URL.createObjectURL()</code> 只是将底层的流（MS）和 video.src 连接中间者，一旦两者连接到一起之后，该对象就没用了。</p>
<p>那么什么时候 MS 才会和 video.src 连接到一起呢？</p>
<p>创建实例都是同步的，但是底层流和 video.src 的连接时异步的。MS 提供了一个 <code>sourceopen</code> 事件给我们进行这项异步处理。一旦连接到一起之后，该 URL object 就没用了，处于内存节省的目的，可以使用 <code>URL.revokeObjectURL(vidElement.src)</code> 销毁指定的 URL object。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="mediaSource.addEventListener('sourceopen', sourceOpen);

function sourceOpen(){
    URL.revokeObjectURL(vidElement.src)
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code>mediaSource.addEventListener(<span class="hljs-string">'sourceopen'</span>, sourceOpen);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sourceOpen</span><span class="hljs-params">()</span></span>{
    URL.revokeObjectURL(vidElement.src)
}</code></pre>
<h4>MS 对流的解析</h4>
<p>MS 提供了我们对底层音视频流的处理，那一开始我们怎么决定以何种格式进行编解码呢？</p>
<p>这里，可以使用 <code>addSourceBuffer(mime)</code> 来设置相关的编码器：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  var mime = 'video/webm; codecs=&quot;opus, vp9&quot;';  
  var sourceBuffer = mediaSource.addSourceBuffer(mime);  " title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs ebnf"><code><span class="hljs-attribute">  var mime</span> = <span class="hljs-string">'video/webm; codecs="opus, vp9"'</span>;  
<span class="hljs-attribute">  var sourceBuffer</span> = mediaSource.addSourceBuffer(mime);  </code></pre>
<p>然后通过，异步拉取相关的音视频流：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="fetch(url)
.then(res=>{
    return res.arrayBuffer();
})
.then(buffer=>{
    sourceBuffer.appendBuffer(buffer);
})" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs coq"><code>fetch(url)
.<span class="hljs-keyword">then</span>(res=&gt;{
    <span class="hljs-keyword">return</span> res.arrayBuffer();
})
.<span class="hljs-keyword">then</span>(buffer=&gt;{
    sourceBuffer.appendBuffer(buffer);
})</code></pre>
<p>如果视频已经传完了，而相关的 Buffer 还在占用内存，这时候，就需要我们显示的中断当前的 Buffer 内容。那么最终我们的异步处理结果变为：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="fetch(url)
.then(res=>{
    return res.arrayBuffer();
})
.then(function(arrayBuffer) {
      sourceBuffer.addEventListener('updateend', function(e) {
      // 是否有持续更新的流
        if (!sourceBuffer.updating &amp;&amp; mediaSource.readyState === 'open') {
        // 没有，则中断连接
          mediaSource.endOfStream();
        }
      });
      sourceBuffer.appendBuffer(arrayBuffer);
    });" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code>fetch(url)
.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>{
    <span class="hljs-keyword">return</span> res.arrayBuffer();
})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arrayBuffer</span>) </span>{
      sourceBuffer.addEventListener(<span class="hljs-string">'updateend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-comment">// 是否有持续更新的流</span>
        <span class="hljs-keyword">if</span> (!sourceBuffer.updating &amp;&amp; mediaSource.readyState === <span class="hljs-string">'open'</span>) {
        <span class="hljs-comment">// 没有，则中断连接</span>
          mediaSource.endOfStream();
        }
      });
      sourceBuffer.appendBuffer(arrayBuffer);
    });</code></pre>
<p>上面我们大致了解了一下关于 Media Source Extensions 的大致流程，但里面的细节我们还没有细讲。接下来，我们来具体看一下 MSE 一篮子的生态技术包含哪些内容。首先是，MediaSource</p>
<h2 id="articleHeader12">MediaSource</h2>
<p>MS(MediaSource) 可以理解为多个视频流的管理工具。以前，我们只能下载一个清晰度的流，并且不能平滑切换低画质或者高画质的流，而现在我们可以利用 MS 实现这里特性。我们先来简单了解一下他的 API。</p>
<h3 id="articleHeader13">MS 的创建</h3>
<p>创建一个 MS:</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var mediaSource = new MediaSource();" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haxe"><code style="word-break: break-word; white-space: initial;"><span class="hljs-keyword">var</span> mediaSource = <span class="hljs-keyword">new</span> <span class="hljs-type">MediaSource</span>();</code></pre>
<h3 id="articleHeader14">相关方法</h3>
<h4>addSourceBuffer()</h4>
<p>该是用来返回一个具体的视频流，接受一个 mimeType 表示该流的编码格式。例如：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var mimeType = 'video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;';
var sourceBuffer = mediaSource.addSourceBuffer(mimeType);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs ebnf"><code><span class="hljs-attribute">var mimeType</span> = <span class="hljs-string">'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'</span>;
<span class="hljs-attribute">var sourceBuffer</span> = mediaSource.addSourceBuffer(mimeType);</code></pre>
<p>sourceBuffer 是直接和视频流有交集的 API。例如：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function sourceOpen (_) {
  var mediaSource = this;
  var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
  fetchAB(assetURL, function (buf) {
    sourceBuffer.addEventListener('updateend', function (_) {
      mediaSource.endOfStream();
      video.play();
    });
    // 通过 fetch 添加视频 Buffer
    sourceBuffer.appendBuffer(buf);
  });
};" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sourceOpen</span> <span class="hljs-params">(_)</span> </span>{
  <span class="hljs-keyword">var</span> mediaSource = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">var</span> sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
  fetchAB(assetURL, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buf)</span> </span>{
    sourceBuffer.addEventListener(<span class="hljs-string">'updateend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_)</span> </span>{
      mediaSource.endOfStream();
      video.play();
    });
    <span class="hljs-comment">// 通过 fetch 添加视频 Buffer</span>
    sourceBuffer.appendBuffer(buf);
  });
};</code></pre>
<p>它通过 <code>appendBuffer</code> 直接添加视频流，实现播放。不过，在使用 <code>addSourceBuffer</code> 创建之前，还需要保证当前浏览器是否支持该编码格式。</p>
<h4>removeSourceBuffer()</h4>
<p>用来移除某个 sourceBuffer。移除也主要是考虑性能原因，将不需要的流移除以节省相应的空间，格式为：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="mediaSource.removeSourceBuffer(sourceBuffer);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs abnf"><code style="word-break: break-word; white-space: initial;">mediaSource.removeSourceBuffer(sourceBuffer)<span class="hljs-comment">;</span></code></pre>
<h4>endOfStream()</h4>
<p>用来表示接受的视频流的停止，注意，这里并不是断开，相当于只是下好了一部分视频，然后你可以进行播放。此时，MS 的状态变为：<code>ended</code>。例如：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="
  var mediaSource = this;
  var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
  fetchAB(assetURL, function (buf) {
    sourceBuffer.addEventListener('updateend', function (_) {
      mediaSource.endOfStream(); // 结束当前的接受
      video.play(); // 可以播放当前获得的流
    });
    sourceBuffer.appendBuffer(buf);
  });" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code>
  <span class="hljs-keyword">var</span> mediaSource = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">var</span> sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
  fetchAB(assetURL, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buf)</span> </span>{
    sourceBuffer.addEventListener(<span class="hljs-string">'updateend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_)</span> </span>{
      mediaSource.endOfStream(); <span class="hljs-comment">// 结束当前的接受</span>
      video.play(); <span class="hljs-comment">// 可以播放当前获得的流</span>
    });
    sourceBuffer.appendBuffer(buf);
  });</code></pre>
<h4>isTypeSupported()</h4>
<p>该是用来检测当前浏览器是否支持指定视频格式的解码。格式为：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var isItSupported = mediaSource.isTypeSupported(mimeType); // 返回值为 Boolean" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code style="word-break: break-word; white-space: initial;"><span class="hljs-keyword">var</span> isItSupported = mediaSource.isTypeSupported(mimeType); <span class="hljs-comment">// 返回值为 Boolean</span></code></pre>
<p>mimeType 可以为 type 或者 type + codec。</p>
<p>例如：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 不同的浏览器支持不一样，不过基本的类型都支持。
MediaSource.isTypeSupported('audio/mp3'); // false，这里应该为 audio/mpeg 
MediaSource.isTypeSupported('video/mp4'); // true
MediaSource.isTypeSupported('video/mp4; codecs=&quot;avc1.4D4028, mp4a.40.2&quot;'); // true" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs less"><code><span class="hljs-comment">// 不同的浏览器支持不一样，不过基本的类型都支持。</span>
<span class="hljs-selector-tag">MediaSource</span><span class="hljs-selector-class">.isTypeSupported</span>(<span class="hljs-string">'audio/mp3'</span>); <span class="hljs-comment">// false，这里应该为 audio/mpeg </span>
<span class="hljs-selector-tag">MediaSource</span><span class="hljs-selector-class">.isTypeSupported</span>(<span class="hljs-string">'video/mp4'</span>); <span class="hljs-comment">// true</span>
<span class="hljs-selector-tag">MediaSource</span><span class="hljs-selector-class">.isTypeSupported</span>(<span class="hljs-string">'video/mp4; codecs="avc1.4D4028, mp4a.40.2"'</span>); <span class="hljs-comment">// true</span></code></pre>
<p>这里有一份具体的 <a href="https://wiki.whatwg.org/wiki/Video_type_parameters#Browser_Support" rel="nofollow noreferrer" target="_blank">mimeType</a> 参考列表。</p>
<h3 id="articleHeader15">MS 的状态</h3>
<p>当 MS 从创建开始，都会自带一个 <code>readyState</code> 属性，用来表示其当前打开的状态。MS 有三个状态：</p>
<ul>
<li><p>closed: 当前 MS 没有和 media element(比如：video.src) 相关联。创建时，MS 就是该状态。</p></li>
<li><p>open: source 打开，并且准备接受通过 sourceBuffer.appendBuffer 添加的数据。</p></li>
<li><p>ended: 当 endOfStream() 执行完成，会变为该状态，此时，source 依然和 media element 连接。</p></li>
</ul>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var mediaSource = new MediaSource;
mediaSource.readyState; // 默认为 closed" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haxe"><code><span class="hljs-keyword">var</span> mediaSource = <span class="hljs-keyword">new</span> <span class="hljs-type">MediaSource</span>;
mediaSource.readyState; <span class="hljs-comment">// 默认为 closed</span></code></pre>
<p>当由 closed 变为 open 状态时，需要监听 <code>sourceopen</code> 事件。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="video.src = URL.createObjectURL(mediaSource);
mediaSource.addEventListener('sourceopen', sourceOpen);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs mipsasm"><code>video.src = URL.createObjectURL(mediaSource)<span class="hljs-comment">;</span>
mediaSource.<span class="hljs-keyword">addEventListener('sourceopen', </span>sourceOpen)<span class="hljs-comment">;</span></code></pre>
<p>MS 针对这几个状态变化，提供了相关的事件：<code>sourceopen</code>，<code>sourceended</code>，<code>sourceclose</code>。</p>
<ul>
<li><p>sourceopen: 当  "closed" to "open" 或者 "ended" to "open" 时触发。</p></li>
<li><p>sourceended: 当  "open" to "ended" 时触发。</p></li>
<li><p>sourceclose: 当 "open" to "closed" 或者 "ended" to "closed" 时触发。</p></li>
</ul>
<p>MS 还提供了其他的监听事件 sourceopen，sourceended，sourceclose，updatestart，update，updateend，error，abort，addsourcebuffer，removesourcebuffer. 这里主要选了比较重要的，其他的可以参考官方文档。</p>
<h3 id="articleHeader16">MS 属性</h3>
<p>比较常用的属性有: duration，readyState。</p>
<ul><li><p>duration: 获得当前媒体播放的时间，既可以设置(get)，也可以获取(set)。单位为 s(秒)</p></li></ul>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="mediaSource.duration = 5.5; // 设置媒体流播放的时间
var myDuration = mediaSource.duration; // 获得媒体流开始播放的时间" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lasso"><code>mediaSource.<span class="hljs-built_in">duration</span> = <span class="hljs-number">5.5</span>; <span class="hljs-comment">// 设置媒体流播放的时间</span>
<span class="hljs-built_in">var</span> myDuration = mediaSource.<span class="hljs-built_in">duration</span>; <span class="hljs-comment">// 获得媒体流开始播放的时间</span></code></pre>
<p>在实际应用中为：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="sourceBuffer.addEventListener('updateend', function (_) {
      mediaSource.endOfStream();
      mediaSource.duration = 120; // 设置当前流播放的时间
      video.play();
    });" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code>sourceBuffer.addEventListener(<span class="hljs-string">'updateend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_)</span> </span>{
      mediaSource.endOfStream();
      mediaSource.duration = <span class="hljs-number">120</span>; <span class="hljs-comment">// 设置当前流播放的时间</span>
      video.play();
    });</code></pre>
<ul><li><p>readyState: 获得当前 MS 的状态。取值上面已经讲过了: <code>closed</code>，<code>open</code>，<code>ended</code>。</p></li></ul>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var mediaSource = new MediaSource;
  //此时的 mediaSource.readyState 状态为 closed" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haxe"><code><span class="hljs-keyword">var</span> mediaSource = <span class="hljs-keyword">new</span> <span class="hljs-type">MediaSource</span>;
  <span class="hljs-comment">//此时的 mediaSource.readyState 状态为 closed</span></code></pre>
<p>以及：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="sourceBuffer.addEventListener('updateend', function (_) {
      mediaSource.endOfStream(); // 调用该方法后结果为：ended
      video.play();
    });" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code>sourceBuffer.addEventListener(<span class="hljs-string">'updateend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_)</span> </span>{
      mediaSource.endOfStream(); <span class="hljs-comment">// 调用该方法后结果为：ended</span>
      video.play();
    });</code></pre>
<p>除了上面两个属性外，还有 <code>sourceBuffers</code>，<code>activeSourceBuffers</code> 这两个属性。用来返回通过 <code>addSourceBuffer()</code> 创建的 SourceBuffer 数组。这没啥过多的难度。</p>
<p>接下来我们就来看一下靠底层的 <code>sourceBuffer</code>。</p>
<h2 id="articleHeader17">SourceBuffer</h2>
<p>SourceBuffer 是由 <code>mediaSource</code> 创建，并直接和 <code>HTMLMediaElement</code> 接触。简单来说，它就是一个流的容器，里面提供的 <code>append()</code>，<code>remove()</code> 来进行流的操作，它可以包含一个或者多个 <code>media segments</code>。同样，接下来，我们再来看一下该构造函数上的基本属性和内容。</p>
<h3 id="articleHeader18">基础内容</h3>
<p>前面说过 sourceBuffer 主要是一个用来存放流的容器，那么，它是怎么存放的，它存放的内容是啥，有没有顺序等等。这些都是 sourceBuffer 最最根本的问题。OK，接下来，我们来看一下的它的基本架构有些啥。</p>
<p>参考 <a href="https://www.w3.org/TR/media-source/#sourcebuffer" rel="nofollow noreferrer" target="_blank">W3C</a>，可以基本了解到里面的内容为：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="interface SourceBuffer : EventTarget {
             attribute AppendMode          mode;
    readonly attribute boolean             updating;
    readonly attribute TimeRanges          buffered;
             attribute double              timestampOffset;
    readonly attribute AudioTrackList      audioTracks;
    readonly attribute VideoTrackList      videoTracks;
    readonly attribute TextTrackList       textTracks;
             attribute double              appendWindowStart;
             attribute unrestricted double appendWindowEnd;
             attribute EventHandler        onupdatestart;
             attribute EventHandler        onupdate;
             attribute EventHandler        onupdateend;
             attribute EventHandler        onerror;
             attribute EventHandler        onabort;
    void appendBuffer(BufferSource data);
    void abort();
    void remove(double start, unrestricted double end);
};" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs glsl"><code>interface SourceBuffer : EventTarget {
             <span class="hljs-keyword">attribute</span> AppendMode          mode;
    <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">attribute</span> boolean             updating;
    <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">attribute</span> TimeRanges          buffered;
             <span class="hljs-keyword">attribute</span> <span class="hljs-type">double</span>              timestampOffset;
    <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">attribute</span> AudioTrackList      audioTracks;
    <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">attribute</span> VideoTrackList      videoTracks;
    <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">attribute</span> TextTrackList       textTracks;
             <span class="hljs-keyword">attribute</span> <span class="hljs-type">double</span>              appendWindowStart;
             <span class="hljs-keyword">attribute</span> unrestricted <span class="hljs-type">double</span> appendWindowEnd;
             <span class="hljs-keyword">attribute</span> EventHandler        onupdatestart;
             <span class="hljs-keyword">attribute</span> EventHandler        onupdate;
             <span class="hljs-keyword">attribute</span> EventHandler        onupdateend;
             <span class="hljs-keyword">attribute</span> EventHandler        onerror;
             <span class="hljs-keyword">attribute</span> EventHandler        onabort;
    <span class="hljs-type">void</span> appendBuffer(BufferSource data);
    <span class="hljs-type">void</span> abort();
    <span class="hljs-type">void</span> remove(<span class="hljs-type">double</span> start, unrestricted <span class="hljs-type">double</span> end);
};</code></pre>
<p>上面这些属性决定了其 sourceBuffer 整个基础。</p>
<p>首先是 <code>mode</code>。上面说过，SB(SourceBuffer) 里面存储的是 media segments（就是你每次通过 append 添加进去的流片段）。SB.mode 有两种格式：</p>
<ul>
<li><p>segments: 乱序排放。通过 <code>timestamps</code> 来标识其具体播放的顺序。比如：20s的 buffer，30s 的 buffer 等。</p></li>
<li><p>sequence: 按序排放。通过 <code>appendBuffer</code> 的顺序来决定每个 mode 添加的顺序。<code>timestamps</code> 根据 sequence 自动产生。</p></li>
</ul>
<p>那么上面两个哪个是默认值呢？</p>
<p>看情况，讲真，没骗你。</p>
<p>当 <code>media segments</code> 天生自带 <code>timestamps</code>，那么 <code>mode</code> 就为 <code>segments</code> ，否则为 <code>sequence</code>。所以，一般情况下，我们是不用管它的值。不过，你可以在后面，将 <code>segments</code> 设置为 <code>sequence</code> 这个是没毛病的。反之，将 <code>sequence</code> 设置为 <code>segments</code> 就有问题了。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var bufferMode = sourceBuffer.mode;
if (bufferMode == 'segments') {
  sourceBuffer.mode = 'sequence';
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs bash"><code>var bufferMode = <span class="hljs-built_in">source</span>Buffer.mode;
<span class="hljs-keyword">if</span> (bufferMode == <span class="hljs-string">'segments'</span>) {
  <span class="hljs-built_in">source</span>Buffer.mode = <span class="hljs-string">'sequence'</span>;
}</code></pre>
<p>然后另外两个就是 <code>buffered</code> 和 <code>updating</code>。</p>
<ul>
<li><p>buffered：返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges" rel="nofollow noreferrer" target="_blank">timeRange</a> 对象。用来表示当前被存储在 SB 中的 buffer。</p></li>
<li><p>updating: 返回 Boolean，表示当前 SB 是否正在被更新。例如: SourceBuffer.appendBuffer(), SourceBuffer.appendStream(), SourceBuffer.remove() 调用时。</p></li>
</ul>
<p>另外还有一些其他的相关属性，比如 textTracks,timestampOffset,trackDefaults，这里就不多说了。实际上，SB 是一个事件驱动的对象，一些常见的处理，都是在具体的事件中完成的。那么它又有哪些事件呢？</p>
<h3 id="articleHeader19">事件触发</h3>
<p>在 SB 中，相关事件触发包括：</p>
<ul>
<li><p>updatestart： 当 updating 由 false 变为 true。</p></li>
<li><p>update：当 append()/remove() 方法被成功调用完成时，updating 由 true 变为 false。</p></li>
<li><p>updateend: append()/remove() 已经结束</p></li>
<li><p>error: 在 append() 过程中发生错误，updating 由 true 变为 false。</p></li>
<li><p>abort: 当 append()/remove() 过程中，使用 <code>abort()</code> 方法废弃时，会触发。此时，updating 由 true 变为 false。</p></li>
</ul>
<p>注意上面有两个事件比较类似：<code>update</code> 和 <code>updateend</code>。都是表示处理的结束，不同的是，update 比 updateend 先触发。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="sourceBuffer.addEventListener('updateend', function (e) {
    // 当指定的 buffer 加载完后，就可以开始播放
      mediaSource.endOfStream();
      video.play();
    });" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code>sourceBuffer.addEventListener(<span class="hljs-string">'updateend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> </span>{
    <span class="hljs-comment">// 当指定的 buffer 加载完后，就可以开始播放</span>
      mediaSource.endOfStream();
      video.play();
    });</code></pre>
<h3 id="articleHeader20">相关方法</h3>
<p>SB 处理流的方法就是 +/- ： appendBuffer, remove。另外还有一个中断处理函数 <code>abort()</code>。</p>
<ul>
<li><p>appendBuffer(ArrayBuffer)：用来添加 ArrayBuffer。该 ArrayBuffer 一般是通过 fetch 的 <code>response.arrayBuffer();</code> 来获取的。</p></li>
<li>
<p>remove(start, end)： 用来移除具体某段的 media segments。</p>
<ul><li><p>@param start/end: 都是时间单位（s）。用来表示具体某段的 media segments 的范围。</p></li></ul>
</li>
<li><p>abort(): 用来放弃当前 append 流的操作。不过，该方法的业务场景也比较有限。它只能用在当 SB 正在更新流的时候。即，此时通过 fetch,已经接受到新流，并且使用 appendBuffer 添加，此为开始的时间。然后到 updateend 事件触发之前，这段时间之内调用 <code>abort()</code>。有一个业务场景是，当用户移动进度条，而，此时 fetch 已经获取前一次的 media segments，那么可以使用 <code>abort</code> 放弃该操作，转而请求新的 media segments。具体可以参考：<a href="https://github.com/nickdesaulniers/netfix/blob/gh-pages/demo/bufferWhenNeeded.html#L92-L101" rel="nofollow noreferrer" target="_blank">abort 使用</a></p></li>
</ul>
<p>上面主要介绍了处理音视频流需要用的 Web 技术，后面章节，我们接入实战，具体来讲一下，如何做到使用 MSE 进行 remux 和 demux。</p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
全面进阶 H5 直播

## 原文链接
[https://segmentfault.com/a/1190000008916399](https://segmentfault.com/a/1190000008916399)

