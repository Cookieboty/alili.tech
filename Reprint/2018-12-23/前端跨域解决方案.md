---
title: '前端跨域解决方案' 
date: 2018-12-23 2:30:07
hidden: true
slug: dres9pm77ka
categories: [reprint]
---

{{< raw >}}

                    
<h1 id="articleHeader0">浏览器同源策略</h1>
<h2 id="articleHeader1">什么是浏览器同源策略？</h2>
<p>“同源策略”（Same Origin Policy）是浏览器安全的基础。</p>
<blockquote>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</blockquote>
<p>在判断两个页面的url是否具有相同的源之前，我们先来看一下一个url（统一资源定位符）的基本组成部分。</p>
<blockquote>对于一个url，它的基本组成部分是：协议 :// 域名（或者是ip） : 端口（如果指定了） / 路径。</blockquote>
<p>那么下面我们来举个例子：</p>
<p>对于<code>http://www.example.com/static</code>来说，协议就是<code>http</code>，它的域名是<code>www.example.com</code>，它的路径是<code>static</code>，这里的端口号省略了（默认为80）。</p>
<p>值得一提的是，在这个域名下面，<code>example.com</code>是主域名，而<code>www.example.com</code>是子域名，同样的<code>a.example.com</code>也是一个与前面所述不同的另一个子域名。并且，上面这三个域名<strong>互不相同</strong>。</p>
<p>这里不再展开赘述，相关知识请查阅与计算机网络有关的知识。</p>
<p>那如何判断页面是否具有相同的源呢？</p>
<blockquote>如果协议，端口（如果指定了）和域名对于两个页面是相同的，则两个页面具有相同的源。</blockquote>
<p>也就是说，判断同源的三要素是：<strong>协议</strong>、<strong>端口</strong>、<strong>域名</strong>。</p>
<p>需要注意的是，如果是一个域名二级域名，比如上面提到的<code>www.example.com</code>，它与另外一个二级域名<code>a.example.com</code>，虽然他们的主域相同，但是子域不同，于是这两个就<strong>不是同一个域名</strong>，所以也不能说是同源。三级域名依次类推...</p>
<p>下表给出了相对<code>http://store.company.com/dir/page.html</code>同源检测的示例：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000012256437?w=1426&amp;h=261" src="https://static.alili.tech/img/remote/1460000012256437?w=1426&amp;h=261" alt="" title="" style="cursor: pointer;"></span></p>
<h2 id="articleHeader2">关于Cookie和Session</h2>
<p>说到同源策略，必不可少的就是Cookie这个东西了。</p>
<p>而讲到Cookie，跟它关联在一起的又有Session。</p>
<p>对于这两者，这里不做大篇幅的介绍，具体去<a href="http://www.cnblogs.com/linguoguo/p/5106618.html" rel="nofollow noreferrer" target="_blank">传送门</a>查阅。</p>
<p>这里我们做一下简要的总结：</p>
<ul>
<li>Cookie受到浏览器同源策略的限制，A页面的Cookie无法被B页面的Cookie访问和操作。</li>
<li>Cookie最大存储容量一般为4KB，由服务器生成，在HTTP报文首部设置<code>Set-Cookie</code>可以指定生成Cookie的内容和生命周期，如果由浏览器生成则在关掉浏览器后失效。</li>
<li>Cookie存储在浏览器端，由于每次发送HTTP请求默认会把Cookie附到HTTP首部上去，所以Cookie主要用来身份认证，而不用来存储其他信息，防止HTTP报文过大。</li>
<li>Session存储在服务器，主要与Cookie配合使用完成身份认证和状态保持的功能。只有Cookie或只有Session都无法完成身份认证和状态保持的功能。</li>
</ul>
<p>最后，对Cookie和Session实现的身份认证和状态保持功能做一个举例。</p>
<p>假设现在有一个学生信息管理系统，此时数据库已经有学生的相关信息。（账号、密码、个人信息等等）  <br>然后当学生登录这个系统，通过POST请求把用户的账户密码发送到后台服务器。当后台服务器接收到这些参数的时候，会跟数据库保存的记录进行匹配。  <br>一旦匹配成功，也就是用户的账号密码都正确的情况下，这个时候后台服务器会在Session中记录一个值，可以是用户名或者其他能够唯一标识用户的字段。  <br>当把这个值保存在Session中后，后台服务器会返回响应告知客户端登录成功，可以进行后续的操作。此时，后台服务器会在HTTP响应报文中添加一个字段<code>Set-Cookie</code>，它的值是当前Session的SessionID，（这个SessionID是指向我们当前的那个Session的，在Node的Express中express-session会封装好这个过程）当然还会设置Cookie的其他属性，比如说过期时间<code>Expires</code>等等。  <br>当浏览器接收到这个HTTP响应报文的时候，就会在本地设置一个Cookie，它的过期时间由响应报文中<code>Set-Cookie</code>中的<code>Expires</code>字段的值决定，如果为空，则关闭浏览器（即会话结束时）后失效。<br>之后，每次向后台服务器发送请求的时候，浏览器默认会把这个Cookie加在HTTP请求报文的Cookie中。这样，每次后台服务器接收到请求的时候，会根据Cookie中的SessionID去找到我们的Session。<br>假如这个SessionID映射得到Session，那么这个时候说明浏览器是已经登录过了。于是，就可以进行后续的一些相关的操作。  <br>另外，值得一提的是，<strong>Session机制决定了当前客户只会获取到自己的Session，而不会获取到别人的Session。各客户的Session也彼此独立，互不可见。</strong>也就是说，当多个客户端执行程序时，服务器会保存多个客户端的Session。获取Session的时候也不需要声明获取谁的Session。</p>
<p>这就是Cookie和Session做状态保持和身份验证的一个具体的例子。</p>
<h2 id="articleHeader3">关于iframe</h2>
<p>说到同源限制，还有一个不得不提的就是iframe。</p>
<p>iframe可以在父页面中嵌入一个子页面，在日常开发中一旦使用，避免不了的就要涉及到不同的iframe页面进行通信的问题，可能是获得其他iframe的DOM，或者是获取其他iframe上的全局变量或方法等等。</p>
<p>同源下的iframe，也就是iframe中的<code>src</code>属性的URL符合同源的条件，那么通过iframe的<code>contentDocument</code>和<code>contentWindow</code>获取其他iframe的DOM或者全局变量、方法都是很简单的事情。</p>
<p>那如果是非同源的两个iframe，单纯的通过变量访问的方式就受到同源限制了。</p>
<p>为了解决这个问题，HTML5引入了一个新的API：<strong><code>postMessage</code></strong>，主要就是用来解决存在跨域问题的iframe页面之间通信的问题。</p>
<p>下面简单的举一个例子，假如现在有两个不同的页面，A页面的url是<code>http://localhost:4002/parent.html</code>，B页面的url的是<code>http://localhost:4003/child.html</code>，现在我把B页面用iframe嵌在A页面下面，代码（精简）是这样子的。现在我要实现的是向子页面B传递一个消息：</p>
<p>A页面代码：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<body>
    <h1>A页面</h1>
    <iframe src=&quot;http://localhost:4003/child.html&quot; id=&quot;child&quot;>
    </iframe>
    <script>
        window.onload = function() {
            document.getElementById(&quot;child&quot;).contentWindow.postMessage(&quot;父页面发来贺电&quot;, &quot;http://localhost:4003&quot;);
        }
    </script>
</body>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="xml hljs"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>A页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://localhost:4003/child.html"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"child"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"child"</span>).contentWindow.postMessage(<span class="hljs-string">"父页面发来贺电"</span>, <span class="hljs-string">"http://localhost:4003"</span>);
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>B页面代码：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<body>
    <h1>B页面</h1>
    <script>
        window.onload = function() {
            window.addEventListener(&quot;message&quot;, function(e) {
                //判断信息的来源是否来自于父页面，保证信息源的安全
                if(e.source != window.parent) return;
                alert(e.data);
            });
        };
    </script>
</body>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="xml hljs"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>B页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"message"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-comment">//判断信息的来源是否来自于父页面，保证信息源的安全</span>
                <span class="hljs-keyword">if</span>(e.source != <span class="hljs-built_in">window</span>.parent) <span class="hljs-keyword">return</span>;
                alert(e.data);
            });
        };
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>结果如图：<br><span class="img-wrap"><img data-src="/img/remote/1460000012256438?w=1356&amp;h=694" src="https://static.alili.tech/img/remote/1460000012256438?w=1356&amp;h=694" alt="" title="" style="cursor: pointer;"></span></p>
<p><code>postMessage</code>接受两个参数，一个是要传送的<code>data</code>，另外一个是目标窗口的源，如果想传给任何窗口，可以设置成<code>*</code>。  <br>目标页面接收信息的时候，使用的是<code>window.addEventListener("message", function() {})</code>。</p>
<h2 id="articleHeader4">不受同源限制的情况</h2>
<p>当然也有不受同源限制的情况存在，主要有以下列举的：</p>
<ol>
<li>
<code>script</code>标签允许跨域嵌入脚本，稍后介绍的JSONP就是利用这个“漏洞”来实现。</li>
<li>
<code>img</code>标签、<code>link</code>标签、<code>@font-face</code>不受跨域影响。</li>
<li>
<code>video</code>和<code>audio</code>嵌入的资源。</li>
<li>
<code>iframe</code>载入的任何资源。（不是iframe之间的通信）</li>
<li>
<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;applet&gt;</code>的插件。</li>
<li>
<code>WebSocket</code>不受同源策略的限制。</li>
</ol>
<h1 id="articleHeader5">开发时常用解决方案</h1>
<h2 id="articleHeader6">CORS——跨域资源共享</h2>
<p>注：以下跨域资源共享的两种请求辨析内容摘抄至阮一峰的<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" rel="nofollow noreferrer" target="_blank">《跨域资源共享》</a>一文。</p>
<h3 id="articleHeader7">什么是跨域资源共享？</h3>
<blockquote>CORS是一个W3C标准，全称是“跨域资源共享”（Cross-origin resource sharing）。</blockquote>
<p>它允许浏览器向跨源服务器发出XMLHttpRequest请求，从而克服了AJAX只能同源发送请求的限制。</p>
<p>实现CORS主要在于<strong>服务器</strong>的设置，关键在于服务器<strong>HTTP响应报文首部</strong>的设置。前端部分大致还是跟原来发AJAX请求没什么区别，只是需要对AJAX进行一些相关的设置，稍后我们都会讲到。</p>
<h3 id="articleHeader8">CORS的两种请求</h3>
<p>在讲解如何实现跨域资源共享的时候，我们先来看一下CORS的两种请求。</p>
<p>浏览器将CORS分为两种请求，一种是简单请求，另外一种对应的肯定就是非简单请求。</p>
<p>只要同时满足下面两大条件，就属于简单请求：</p>
<p>请求的方法是一下的三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>HTTP的头信息不超过以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type: 只限于三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/formdata</code>、<code>text/plain</code>。</li>
</ul>
<p>凡是不同时满足以上两种条件，就属于非简单请求。</p>
<p>浏览器对于两种请求处理是不一样的。</p>
<h4>简单请求</h4>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在HTTP请求报文首部，增加一个<code>Origin</code>字段。如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0..." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="http hljs"><code class="http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/cors</span> HTTP/1.1
<span class="hljs-attribute">Origin</span>: http://api.bob.com
<span class="hljs-attribute">Host</span>: api.alice.com
<span class="hljs-attribute">Accept-Language</span>: en-US
<span class="hljs-attribute">Connection</span>: keep-alive
<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0...</code></pre>
<p>上面<code>Origin</code>字段的用来说明本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="http hljs"><code class="http"><span class="hljs-attribute">Access-Control-Allow-Origin</span>: http://api.bob.com
<span class="hljs-attribute">Access-Control-Allow-Credentials</span>: true
<span class="hljs-attribute">Access-Control-Expose-Headers</span>: FooBar
<span class="hljs-attribute">Content-Type</span>: text/html; charset=utf-8</code></pre>
<p>上面的HTTP响应报文首部信息中，有三个与CORS请求相关的字段，都是以<code>Access-Control-</code>开头。</p>
<p><strong>Access-Control-Allow-Origin</strong><br>该字段是必须的，它的值要么是请求<code>Origin</code>字段，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>Access-Control-Allow-Credentials</strong><br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie<strong>不包括</strong>在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>值得一提的是，如果想要CORS支持Cookie，不仅要在服务器指定HTTP响应报文首部字段，还需要在AJAX中打开<code>withCredentials</code>的属性。（jQuery中AJAX设置后面会讲到）</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var xhr = new XMLHttpRequest();
xhr.withCredentials = true;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
xhr.withCredentials = <span class="hljs-literal">true</span>;</code></pre>
<p>有些浏览器在省略<code>withCredentials</code>设置的时候，还是会发送Cookie。于是，可以显式关闭这个属性。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="xhr.withCredentials = false;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript" style="word-break: break-word; white-space: initial;">xhr.withCredentials = <span class="hljs-literal">false</span>;</code></pre>
<p><strong>需要注意的是，如果要发送Cookie，<code>Acess-Control-Allow-Origin</code>不能设置为<code>*</code>，必须设置成具体的域名，如果是本地调试的话可以考虑设置成<code>null</code>。</strong></p>
<p><strong>Access-Control-Expose-Headers</strong><br>该字段可选。CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader('FooBar')</code>可以返回<code>FooBar</code>字段的值。</p>
<h4>非简单请求</h4>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>下面是一段JavaScript脚本：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> url = <span class="hljs-string">'http://api.alice.com/cors'</span>;
<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
xhr.open(<span class="hljs-string">'PUT'</span>, url, <span class="hljs-literal">true</span>);
xhr.setRequestHeader(<span class="hljs-string">'X-Custom-Header'</span>, <span class="hljs-string">'value'</span>);
xhr.send();</code></pre>
<p>很明显，这是一个非简单请求，使用了PUT方法来发送请求，并且自定义了一个HTTP请求报文的首部字段。  </p>
<p>于是，浏览器发现这是一个非简单的请求，就自动发出了一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的HTTP头信息。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0..." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="http hljs"><code class="http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/cors</span> HTTP/1.1
<span class="hljs-attribute">Origin</span>: http://api.bob.com
<span class="hljs-attribute">Access-Control-Request-Method</span>: PUT
<span class="hljs-attribute">Access-Control-Request-Headers</span>: X-Custom-Header
<span class="hljs-attribute">Host</span>: api.alice.com
<span class="hljs-attribute">Accept-Language</span>: en-US
<span class="hljs-attribute">Connection</span>: keep-alive
<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0...</code></pre>
<p>"预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，“预检”请求的头信息还包括两个特殊字段。</p>
<p><strong>Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS会用到哪些HTTP方法，上面是PUT。</p>
<p><strong>Access-Control-Request-Headers</strong></p>
<p>该字段是一个用逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息。上面的例子是<code>X-Custom-Header</code>。</p>
<p>于是，服务器收到“预检”请求之后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨域请求，就可以做出回应。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="http hljs"><code class="http">HTTP/1.1 <span class="hljs-number">200</span> OK
<span class="hljs-attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT
<span class="hljs-attribute">Server</span>: Apache/2.0.61 (Unix)
<span class="hljs-attribute">Access-Control-Allow-Origin</span>: http://api.bob.com
<span class="hljs-attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT
<span class="hljs-attribute">Access-Control-Allow-Headers</span>: X-Custom-Header
<span class="hljs-attribute">Content-Type</span>: text/html; charset=utf-8
<span class="hljs-attribute">Content-Encoding</span>: gzip
<span class="hljs-attribute">Content-Length</span>: 0
<span class="hljs-attribute">Keep-Alive</span>: timeout=2, max=100
<span class="hljs-attribute">Connection</span>: Keep-Alive
<span class="hljs-attribute">Content-Type</span>: text/plain</code></pre>
<p>如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs sql"><code class="console">XMLHttpRequest cannot <span class="hljs-keyword">load</span> <span class="hljs-keyword">http</span>://api.alice.com.
Origin <span class="hljs-keyword">http</span>://api.bob.com <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> allowed <span class="hljs-keyword">by</span> <span class="hljs-keyword">Access</span>-Control-<span class="hljs-keyword">Allow</span>-Origin.</code></pre>
<p>服务器回应的其他CORS相关字段如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="http hljs"><code class="http"><span class="hljs-attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT
<span class="hljs-attribute">Access-Control-Allow-Headers</span>: X-Custom-Header
<span class="hljs-attribute">Access-Control-Allow-Credentials</span>: true
<span class="hljs-attribute">Access-Control-Max-Age</span>: 1728000</code></pre>
<p>对比简单请求服务器响应的CORS字段，发现多了三个：</p>
<p><strong>Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。</p>
<p><strong>Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。</p>
<p><strong>Access-Control-Max-Age</strong><br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<p>于是，一旦浏览器通过了“预检”，以后每次浏览器正常的CORS请求，都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都有一个<code>Access-Control-Allow-Origin</code>头信息字段。如果开启了Cookie设置，那还有一个<code>Access-Control-Allow-Credentials:true</code>。</p>
<h3 id="articleHeader9">如何在Node实现跨域资源共享？</h3>
<p>那怎么在Node中结合Express设置后台的跨域部分呢？</p>
<p>其实很简单，需要设置的就是上面所述的几个响应首部的字段，主要考虑两种类型的请求和是否需要使用Cookie。具体设置如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="app.all(&quot;*&quot;, function(req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;, /* url | * | null */);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Authorization, X-Requested-With&quot;);
    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;); /* 服务器支持的所有字段 */
    res.header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); /* 当使用Cookie时 */
    res.header(&quot;Access-Control-Max-Age&quot;, 300000); /* 设置预检请求的有效期 */
    if (req.method === &quot;OPTIONS&quot;) return res.send(200); /*让options请求快速返回*/
    else next();
});" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">app.all(<span class="hljs-string">"*"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
    res.header(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, <span class="hljs-comment">/* url | * | null */</span>);
    res.header(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, <span class="hljs-string">"Authorization, X-Requested-With"</span>);
    res.header(<span class="hljs-string">"Access-Control-Allow-Methods"</span>, <span class="hljs-string">"PUT,POST,GET,DELETE,OPTIONS"</span>); <span class="hljs-comment">/* 服务器支持的所有字段 */</span>
    res.header(<span class="hljs-string">"Access-Control-Allow-Credentials"</span>, <span class="hljs-string">"true"</span>); <span class="hljs-comment">/* 当使用Cookie时 */</span>
    res.header(<span class="hljs-string">"Access-Control-Max-Age"</span>, <span class="hljs-number">300000</span>); <span class="hljs-comment">/* 设置预检请求的有效期 */</span>
    <span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">"OPTIONS"</span>) <span class="hljs-keyword">return</span> res.send(<span class="hljs-number">200</span>); <span class="hljs-comment">/*让options请求快速返回*/</span>
    <span class="hljs-keyword">else</span> next();
});</code></pre>
<p>上面的设置有几个需要注意的地方：</p>
<ol>
<li>如果需要本地调试，也就是在本地HTML页面发请求（类似<code>file://...</code>之类的url），可以把<code>Access-Control-Allwo-Origin</code>的值设置为Null，这样子就能够使用Cookie。如果设置成<code>*</code>，虽然也可以跨域发送请求，但是这个时候<strong>没有办法使用Cookie</strong>。</li>
<li>
<code>Access-Control-Allow-Headers</code>字段不是必须的，仅当发送的请求有<code>Access-Control-Request-Headers</code>时需要设置。</li>
<li>使用Cookie的时候要配置<code>Access-Control-Allow-Methods</code>字段。</li>
<li>“预检”请求可设置缓存时间，可以保证不多次发送“预检”请求。</li>
<li>需要判断是否为“预检”请求，当拦截“预检”请求的时候直接返回。</li>
</ol>
<p>如果使用jQuery封装的AJAX发送请求，那么需要在相应的JS代码设置：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="$.ajaxSetup({ xhrFields: { withCredentials: true }, crossDomain: true });" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript" style="word-break: break-word; white-space: initial;">$.ajaxSetup({ <span class="hljs-attr">xhrFields</span>: { <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span> }, <span class="hljs-attr">crossDomain</span>: <span class="hljs-literal">true</span> });</code></pre>
<p><code>withCredentials</code>是设置CORS发送Cookie，默认是不发送的。  <br><code>crossDomain</code>告知AJAX允许跨域。</p>
<p>以上就是CORS设置跨域的具体介绍。</p>
<h2 id="articleHeader10">基于JSONP技术实现跨域</h2>
<h3 id="articleHeader11">JSONP原理</h3>
<p>对于JSONP来说，前面也已经提到了，其实它是利用了某些不受同源限制的标签的所谓“漏洞”，来实现“曲线救国”式的跨域的方案。</p>
<p>它借用<code>script</code>标签不受同源限制的这个特性，通过<strong>动态的给页面添加一个<code>script</code>标签，利用事先声明好的数据处理函数来获取数据。</strong></p>
<p>值得一提的是，JSONP这种方法其实和CORS有很大的区别，它并不属于一种规范。所谓的JSONP是应用JSON数据的一种新方法，它只不过是被包含在函数调用中的JSON。</p>
<p>在JSONP中包含两部分：<strong>回调函数和数据</strong>。其中，回调函数是当响应到来时要放在当前页面被调用的函数。而数据，就是传入回调函数中的JSON字符串，也就是回调函数的参数了。下面我们简单模拟一下JSONP的通信过程。</p>
<p>JSONP的原理详细讲解可以看这个<a href="https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" rel="nofollow noreferrer" target="_blank">传送门</a>。</p>
<p>我们来简单的模拟一下JSONP的通信过程。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function handleResponse(response) {
    console.log(response.data);
}
var script = document.createElement(&quot;script&quot;);
script.src = &quot;http://example.com/jsonp/getSomething?uid=123&amp;callback=hadleResponse&quot;
document.body.insertBefore(script, document.body.firstChild);
/*handleResponse({&quot;data&quot;: &quot;hey&quot;})*/" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleResponse</span>(<span class="hljs-params">response</span>) </span>{
    <span class="hljs-built_in">console</span>.log(response.data);
}
<span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);
script.src = <span class="hljs-string">"http://example.com/jsonp/getSomething?uid=123&amp;callback=hadleResponse"</span>
<span class="hljs-built_in">document</span>.body.insertBefore(script, <span class="hljs-built_in">document</span>.body.firstChild);
<span class="hljs-comment">/*handleResponse({"data": "hey"})*/</span></code></pre>
<p>它的过程是这样子的：</p>
<ol>
<li>当我们通过新建一个<code>script</code>标签请求时，后台会根据相应的参数来生成相应的JSON数据。比如说上面这个链接，传递了<code>handleResponse</code>给后台，然后后台根据这个参数再结合数据生成了<code>handleResponse({"data": "hey"})</code>。</li>
<li>紧接着，这个返回的JSON数据其实就可以被当成一个js脚本，就是对一个函数的调用。</li>
<li>由于我们事先已经声明了这么一个回调函数，于是当资源加载进来的时候，直接就对函数进行调用，于是数据当然就能获取到了。</li>
<li>至此，跨域通信完成。</li>
</ol>
<p>另外，想要实现JSONP，后台服务器也必须做相应的设置。</p>
<p>值得一提的是，JSONP是存在一定的局限性的：</p>
<ul>
<li>只能用于GET请求</li>
<li>存在安全问题，请求代码中可能存在安全隐患</li>
<li>要确定JSONP请求是否失败并不容易</li>
</ul>
<h3 id="articleHeader12">一个简单的JSONP实现</h3>
<p>下面是一个实现JSONP的库，我们来一起分析一下它的源代码。这是源码的<a href="https://github.com/webmodules/jsonp" rel="nofollow noreferrer" target="_blank">github地址</a>。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="/**
 * Module dependencies
 */

var debug = require('debug')('jsonp');
//使用依赖

/**
 * Module exports.
 */

module.exports = jsonp;
//输出模块

/**
 * Callback index.
 */

var count = 0;
//回调函数的index值，便于取名。

/**
 * Noop function.
 */

function noop(){}
//无操作空函数，以便使用后把window[id]置空

/**
 * JSONP handler
 *
 * Options:
 *  - param {String} qs parameter (`callback`)
 *  - prefix {String} qs parameter (`__jp`)
 *  - name {String} qs parameter (`prefix` + incr)
 *  - timeout {Number} how long after a timeout error is emitted (`60000`)
 *
 * @param {String} url
 * @param {Object|Function} optional options / callback //这里的callback是取得数据后的callback，不是传给服务器的callback
 * @param {Function} optional callback
 */


function jsonp(url, opts, fn){
  if ('function' == typeof opts) {
    fn = opts;
    opts = {};
  }
  if (!opts) opts = {};

  var prefix = opts.prefix || '__jp';

  // use the callback name that was passed if one was provided.
  // otherwise generate a unique name by incrementing our counter.
  var id = opts.name || (prefix + (count++));

  var param = opts.param || 'callback';
  var timeout = null != opts.timeout ? opts.timeout : 60000;
  var enc = encodeURIComponent;
  var target = document.getElementsByTagName('script')[0] || document.head;
  var script;
  var timer;

  //一定时间内后台服务器没有返回视为超时
  if (timeout) {
    timer = setTimeout(function(){
      cleanup();
      if (fn) fn(new Error('Timeout'));
    }, timeout);
  }
  //回复原始设置、清空状态
  function cleanup(){
    if (script.parentNode) script.parentNode.removeChild(script);
    window[id] = noop;
    if (timer) clearTimeout(timer);
  }
  //取消操作
  function cancel(){
    if (window[id]) {
      cleanup();
    }
  }
    
  //声明函数，等待script标签加载的url引入完毕后调用
  window[id] = function(data){
    debug('jsonp got', data);
    cleanup();
    if (fn) fn(null, data);//node中约定第一个参数为err，但是这里不传，直接就置为null
  };

  // add qs component
  url += (~url.indexOf('?') ? '&amp;' : '?') + param + '=' + enc(id);
  url = url.replace('?&amp;', '?');

  debug('jsonp req &quot;%s&quot;', url);

  // create script
  script = document.createElement('script');
  script.src = url;
  target.parentNode.insertBefore(script, target);
  //引入script标签后会直接去调用声明的函数，然后函数会把script标签带有的data给传出去

  return cancel;
  //返回初始状态
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">/**
 * Module dependencies
 */</span>

<span class="hljs-keyword">var</span> debug = <span class="hljs-built_in">require</span>(<span class="hljs-string">'debug'</span>)(<span class="hljs-string">'jsonp'</span>);
<span class="hljs-comment">//使用依赖</span>

<span class="hljs-comment">/**
 * Module exports.
 */</span>

<span class="hljs-built_in">module</span>.exports = jsonp;
<span class="hljs-comment">//输出模块</span>

<span class="hljs-comment">/**
 * Callback index.
 */</span>

<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
<span class="hljs-comment">//回调函数的index值，便于取名。</span>

<span class="hljs-comment">/**
 * Noop function.
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>)</span>{}
<span class="hljs-comment">//无操作空函数，以便使用后把window[id]置空</span>

<span class="hljs-comment">/**
 * JSONP handler
 *
 * Options:
 *  - param {String} qs parameter (`callback`)
 *  - prefix {String} qs parameter (`__jp`)
 *  - name {String} qs parameter (`prefix` + incr)
 *  - timeout {Number} how long after a timeout error is emitted (`60000`)
 *
 * @param {String} url
 * @param {Object|Function} optional options / callback //这里的callback是取得数据后的callback，不是传给服务器的callback
 * @param {Function} optional callback
 */</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">url, opts, fn</span>)</span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-string">'function'</span> == <span class="hljs-keyword">typeof</span> opts) {
    fn = opts;
    opts = {};
  }
  <span class="hljs-keyword">if</span> (!opts) opts = {};

  <span class="hljs-keyword">var</span> prefix = opts.prefix || <span class="hljs-string">'__jp'</span>;

  <span class="hljs-comment">// use the callback name that was passed if one was provided.</span>
  <span class="hljs-comment">// otherwise generate a unique name by incrementing our counter.</span>
  <span class="hljs-keyword">var</span> id = opts.name || (prefix + (count++));

  <span class="hljs-keyword">var</span> param = opts.param || <span class="hljs-string">'callback'</span>;
  <span class="hljs-keyword">var</span> timeout = <span class="hljs-literal">null</span> != opts.timeout ? opts.timeout : <span class="hljs-number">60000</span>;
  <span class="hljs-keyword">var</span> enc = <span class="hljs-built_in">encodeURIComponent</span>;
  <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'script'</span>)[<span class="hljs-number">0</span>] || <span class="hljs-built_in">document</span>.head;
  <span class="hljs-keyword">var</span> script;
  <span class="hljs-keyword">var</span> timer;

  <span class="hljs-comment">//一定时间内后台服务器没有返回视为超时</span>
  <span class="hljs-keyword">if</span> (timeout) {
    timer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      cleanup();
      <span class="hljs-keyword">if</span> (fn) fn(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Timeout'</span>));
    }, timeout);
  }
  <span class="hljs-comment">//回复原始设置、清空状态</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanup</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">if</span> (script.parentNode) script.parentNode.removeChild(script);
    <span class="hljs-built_in">window</span>[id] = noop;
    <span class="hljs-keyword">if</span> (timer) clearTimeout(timer);
  }
  <span class="hljs-comment">//取消操作</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancel</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>[id]) {
      cleanup();
    }
  }
    
  <span class="hljs-comment">//声明函数，等待script标签加载的url引入完毕后调用</span>
  <span class="hljs-built_in">window</span>[id] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
    debug(<span class="hljs-string">'jsonp got'</span>, data);
    cleanup();
    <span class="hljs-keyword">if</span> (fn) fn(<span class="hljs-literal">null</span>, data);<span class="hljs-comment">//node中约定第一个参数为err，但是这里不传，直接就置为null</span>
  };

  <span class="hljs-comment">// add qs component</span>
  url += (~url.indexOf(<span class="hljs-string">'?'</span>) ? <span class="hljs-string">'&amp;'</span> : <span class="hljs-string">'?'</span>) + param + <span class="hljs-string">'='</span> + enc(id);
  url = url.replace(<span class="hljs-string">'?&amp;'</span>, <span class="hljs-string">'?'</span>);

  debug(<span class="hljs-string">'jsonp req "%s"'</span>, url);

  <span class="hljs-comment">// create script</span>
  script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
  script.src = url;
  target.parentNode.insertBefore(script, target);
  <span class="hljs-comment">//引入script标签后会直接去调用声明的函数，然后函数会把script标签带有的data给传出去</span>

  <span class="hljs-keyword">return</span> cancel;
  <span class="hljs-comment">//返回初始状态</span>
}</code></pre>
<h3 id="articleHeader13">基于JSONP库的封装</h3>
<p>接着，我们可以利用上面的这个库，给它进行一个封装，下面是我们自己写的<code>_jsonp</code>函数：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="/* 这个是自己定义的一个_jsonp */
/**
 * @param {String} url 
 * @param {Object} data 
 * @param {Object} option 
 * @returns 
 */
function _jsonp(url, data, option) {
  url += (url.indexOf('?') < 0 ? '?' : '&amp;') + param(data);

  return new Promise((resolve, reject) => {
    jsonp(url, option, (err, data) => {
      if (!err) {
        resolve(data);
      } else {
        reject(err);
      }
    });
  });
  /* 这里把jsonp封装成了一个promise对象，回调函数中如果成功的话会把数据带回来然后resolve出去 */
}
//紧接着是对参数的一个序列化
function param(data) {
  let url = '';
  for (var k in data) {
    let value = data[k] !== undefined ? data[k] : '';
    url += `&amp;${k}=${encodeURIComponent(value)}`;
  }
  return url ? url.substring(1) : '';/* 这里的substring保证不会有多余的&amp; */
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">/* 这个是自己定义的一个_jsonp */</span>
<span class="hljs-comment">/**
 * @param {String} url 
 * @param {Object} data 
 * @param {Object} option 
 * @returns 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_jsonp</span>(<span class="hljs-params">url, data, option</span>) </span>{
  url += (url.indexOf(<span class="hljs-string">'?'</span>) &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">'?'</span> : <span class="hljs-string">'&amp;'</span>) + param(data);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    jsonp(url, option, (err, data) =&gt; {
      <span class="hljs-keyword">if</span> (!err) {
        resolve(data);
      } <span class="hljs-keyword">else</span> {
        reject(err);
      }
    });
  });
  <span class="hljs-comment">/* 这里把jsonp封装成了一个promise对象，回调函数中如果成功的话会把数据带回来然后resolve出去 */</span>
}
<span class="hljs-comment">//紧接着是对参数的一个序列化</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">param</span>(<span class="hljs-params">data</span>) </span>{
  <span class="hljs-keyword">let</span> url = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> data) {
    <span class="hljs-keyword">let</span> value = data[k] !== <span class="hljs-literal">undefined</span> ? data[k] : <span class="hljs-string">''</span>;
    url += <span class="hljs-string">`&amp;<span class="hljs-subst">${k}</span>=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(value)}</span>`</span>;
  }
  <span class="hljs-keyword">return</span> url ? url.substring(<span class="hljs-number">1</span>) : <span class="hljs-string">''</span>;<span class="hljs-comment">/* 这里的substring保证不会有多余的&amp; */</span>
}</code></pre>
<h3 id="articleHeader14">在jQuery中使用JSONP</h3>
<p>另外，在jQuery中的AJAX中，已经封装了JSONP，下面简单介绍一下如何去使用。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="$.ajax({  
    type: &quot;get&quot;,  
    url: &quot;http://example.com&quot;,  
    dataType: &quot;jsonp&quot;,  
    jsonp: &quot;callback&quot;,
    jsonpCallback: &quot;responseCallback&quot;,
    success: function (data) {  
        console.log(data);
    },  
    error: function (data) {  
        console.log(data);
    }  
});" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">$.ajax({  
    <span class="hljs-attr">type</span>: <span class="hljs-string">"get"</span>,  
    <span class="hljs-attr">url</span>: <span class="hljs-string">"http://example.com"</span>,  
    <span class="hljs-attr">dataType</span>: <span class="hljs-string">"jsonp"</span>,  
    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">"callback"</span>,
    <span class="hljs-attr">jsonpCallback</span>: <span class="hljs-string">"responseCallback"</span>,
    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{  
        <span class="hljs-built_in">console</span>.log(data);
    },  
    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{  
        <span class="hljs-built_in">console</span>.log(data);
    }  
});</code></pre>
<p>在AJAX中，主要设置<code>dataType</code>类型为<code>jsonp</code>。对于<code>jsonp</code>参数来说，默认值是<code>callback</code>，而<code>jsonpCallback</code>参数的值默认是jQuery自己生成的。如果想自己指定一个回调函数，可像代码中对<code>jsonpCallback</code>进行设置。上面的代码中，最终的url将会是<code>http://example.com?callback=responseCallback</code>。</p>
<h2 id="articleHeader15">使用代理服务器转发请求</h2>
<p>由于同源策略仅存在于<strong>浏览器</strong>。对于服务器与服务器之间的通讯，是不存在任何同源限制的说法的。  <br>因此，使用代理服务器来转发请求也是我们在日常开发中解决跨域的一个常用的手段。  <br>实现的方法很简单，只要你会使用Node和Express。  <br>需要注意的是，通常后台服务器都会自己的一个验证的机制，比如说微信文章在<code>iframe</code>中图片是加载不出来的，因为其后台对<code>referer</code>进行了验证。另外，有些服务器也会通过发送一些<code>uid</code>等等之类的字符串供后台校验。因此，我们在使用代理服务器的时候，要重点关注<strong>请求的参数</strong>，这样才能准确的模拟出请求并转发。</p>
<p>下面简单介绍如何使用代理服务器转发请求。</p>
<ul>
<li>分析url请求所需要的参数。</li>
<li>代理服务器暴露出一个api，这个路由实际的功能是去请求真正的服务器。</li>
<li>之后，我们只要请求这个api，我们所建的代理服务器就会默认的帮我们去转发请求到真正的服务器上，其中会加上一些相应的参数。</li>
</ul>
<p>最后，我们来利用反微信图片防盗链这个实例来写一个代理服务器。</p>
<h3 id="articleHeader16">如何使用代理服务器反微信图片防盗链？</h3>
<p>当我们上线了一个网站的时候，然后<code>img</code>标签引用了微信图片的地址，会出现下面的这种情况。</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000012256439?w=1251&amp;h=348" src="https://static.alili.tech/img/remote/1460000012256439?w=1251&amp;h=348" alt="" title="" style="cursor: pointer;"></span></p>
<p>这就是所谓的防盗链。</p>
<p>现在我们给它加上一个代理，代码如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var express = require(&quot;express&quot;);
var superagent = require(&quot;superagent&quot;);
var app = express();

app.use(&quot;/static&quot;, express.static(&quot;public&quot;));

app.get(&quot;/getwxImg&quot;, (req, res) => {
    //如果单纯的去获取会出现参数丢失的情况，因为出现了两个问号
    var url = req.url.substring(req.url.indexOf(&quot;param=&quot;) + 6);
    res.writeHead(200, {
        'Content-Type': 'image/*'
    });
    superagent.get(url)
        .set('Referer', '')
        .set(&quot;User-Agent&quot;,
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
        )
        .end(function (err, result) {
            if (err) {
                return false;
            }
            res.end(result.body);
            return;
        });
});

app.listen(4001, (err) => {
    if (err) {
        console.log(err);
    } else {
        console.log(&quot;server run!&quot;);
    }
});" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">"express"</span>);
<span class="hljs-keyword">var</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">"superagent"</span>);
<span class="hljs-keyword">var</span> app = express();

app.use(<span class="hljs-string">"/static"</span>, express.static(<span class="hljs-string">"public"</span>));

app.get(<span class="hljs-string">"/getwxImg"</span>, (req, res) =&gt; {
    <span class="hljs-comment">//如果单纯的去获取会出现参数丢失的情况，因为出现了两个问号</span>
    <span class="hljs-keyword">var</span> url = req.url.substring(req.url.indexOf(<span class="hljs-string">"param="</span>) + <span class="hljs-number">6</span>);
    res.writeHead(<span class="hljs-number">200</span>, {
        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'image/*'</span>
    });
    superagent.get(url)
        .set(<span class="hljs-string">'Referer'</span>, <span class="hljs-string">''</span>)
        .set(<span class="hljs-string">"User-Agent"</span>,
        <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span>
        )
        .end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) </span>{
            <span class="hljs-keyword">if</span> (err) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            res.end(result.body);
            <span class="hljs-keyword">return</span>;
        });
});

app.listen(<span class="hljs-number">4001</span>, (err) =&gt; {
    <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-built_in">console</span>.log(err);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"server run!"</span>);
    }
});</code></pre>
<p>这样子，我们就可以把链接修改成我们服务器的地址，然后把真正的url作为我们的参数。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<!-- 这是有代理的情况 -->
<img src=&quot;http://localhost:4001/getwxImg?param=http://mmbiz.qpic.cn/mmbiz/CoJreiaicGKekEsuheJJ7Xh53AFe1BJKibyaQzsFiaxfHHdYibsHzfnicbcsj6yBmtYoJXxia9tFufsPxyn48UxiaccaAA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;tp=webp&quot;>
<!-- 下面是没有代理的情况 -->
<img src=&quot;http://mmbiz.qpic.cn/mmbiz/CoJreiaicGKekEsuheJJ7Xh53AFe1BJKibyaQzsFiaxfHHdYibsHzfnicbcsj6yBmtYoJXxia9tFufsPxyn48UxiaccaAA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;tp=webp&quot;>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="xml hljs"><code class="html"><span class="hljs-comment">&lt;!-- 这是有代理的情况 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://localhost:4001/getwxImg?param=http://mmbiz.qpic.cn/mmbiz/CoJreiaicGKekEsuheJJ7Xh53AFe1BJKibyaQzsFiaxfHHdYibsHzfnicbcsj6yBmtYoJXxia9tFufsPxyn48UxiaccaAA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;tp=webp"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 下面是没有代理的情况 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://mmbiz.qpic.cn/mmbiz/CoJreiaicGKekEsuheJJ7Xh53AFe1BJKibyaQzsFiaxfHHdYibsHzfnicbcsj6yBmtYoJXxia9tFufsPxyn48UxiaccaAA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;tp=webp"</span>&gt;</span></code></pre>
<p>结果如下：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000012256440?w=1252&amp;h=552" src="https://static.alili.tech/img/remote/1460000012256440?w=1252&amp;h=552" alt="" title="" style="cursor: pointer;"></span></p>
<p>结果显而易见，这就是所谓的代理服务器，附上github<a href="https://github.com/Devinnn/weixinPictureReverseUrl" rel="nofollow noreferrer" target="_blank">项目地址</a>。</p>
<hr>
<p>参考链接：  <br>浏览器同源策略：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" rel="nofollow noreferrer" target="_blank">https://developer.mozilla.org...</a>  <br>Cookie与Session：<a href="http://www.cnblogs.com/linguoguo/p/5106618.html" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/linguo...</a>  <br>CORS跨域资源共享：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" rel="nofollow noreferrer" target="_blank">http://www.ruanyifeng.com/blo...</a></p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
前端跨域解决方案

## 原文链接
[https://segmentfault.com/a/1190000012256432](https://segmentfault.com/a/1190000012256432)

