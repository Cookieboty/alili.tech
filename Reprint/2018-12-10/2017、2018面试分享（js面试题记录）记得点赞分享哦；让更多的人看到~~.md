---
title: '2017、2018面试分享（js面试题记录）记得点赞分享哦；让更多的人看到~~' 
date: 2018-12-10 2:30:07
hidden: true
slug: w37jjv9v63j
categories: [reprint]
---

{{< raw >}}

                    
<h1 id="articleHeader0">2017面试分享（js面试题记录）</h1>
<h3 id="articleHeader1">1. 最简单的一道题</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="    '11' * 2
    'a8' * 3
    var a = 2, b = 3;
    var c = a+++b; // c = 5
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js">    <span class="hljs-string">'11'</span> * <span class="hljs-number">2</span>
    <span class="hljs-string">'a8'</span> * <span class="hljs-number">3</span>
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> c = a+++b; <span class="hljs-comment">// c = 5</span>
</code></pre>
<h3 id="articleHeader2">2. 一道this的问题</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="    var num = 10;
    var obj = {
        num:8,
        inner: {
            num: 6,
            print: function () {
                console.log(this.num);
            }
        }
    }
    num = 888;
    obj.inner.print(); // 6
    var fn = obj.inner.print;
    fn(); //888
    (obj.inner.print)(); //6
    (obj.inner.print = obj.inner.print)(); //888 这个点没有太理解，虽然答对了" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">    <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">var</span> obj = {
        <span class="hljs-attr">num</span>:<span class="hljs-number">8</span>,
        <span class="hljs-attr">inner</span>: {
            <span class="hljs-attr">num</span>: <span class="hljs-number">6</span>,
            <span class="hljs-attr">print</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.num);
            }
        }
    }
    num = <span class="hljs-number">888</span>;
    obj.inner.print(); <span class="hljs-comment">// 6</span>
    <span class="hljs-keyword">var</span> fn = obj.inner.print;
    fn(); <span class="hljs-comment">//888</span>
    (obj.inner.print)(); <span class="hljs-comment">//6</span>
    (obj.inner.print = obj.inner.print)(); <span class="hljs-comment">//888 这个点没有太理解，虽然答对了</span></code></pre>
<h3 id="articleHeader3">3. var和function的预解析问题,以及变量和function的先后顺序的问题</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="    // 以下代码执行输出结果是什么
    function b () {
        console.log(a);
        var a = 10;
        function a() {};
        a = 100;
        console.log(a);
    }
    b();

    function c () {
        console.log(a);
        function a() {};
        var a = 10;
        a = 100;
        console.log(a);
    }
    c();

    (function d (num) {
        console.log(num);
        var num = 10;
    }(100))

    (function e (num) {
        console.log(num);
        var num = 10;
        function num () {};
    }(100))

    (function f (num) {
        function num () {};
        console.log(num);
        var num =10
        console.log(num);
    }(100))

    //仍然是预解析(在与解析过程中还要考虑一下当前变量的作用于)
    function m () {
        console.log(a1); // underfined
        console.log(a2); // underfined
        console.log(b1); // underfined
        console.log(b2); // underfined
        if(false) {
            function b1 (){};
            var a1 = 10;
        }
        if(true) {
            function b2 (){};
            var a2 = 10;
        }
        console.log(a1); // underfined
        console.log(a2); // 10
        console.log(b1); // underfined
        console.log(b2); // function
    }
    m();

    function n() {
        if(2>1) {
            arr = 10;
            brr = 10;
            let arr;
            var brr;
            console.log(arr);
            console.log(brr);
        }
    }
    n(); // ReferenceError" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">    <span class="hljs-comment">// 以下代码执行输出结果是什么</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(a);
        <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{};
        a = <span class="hljs-number">100</span>;
        <span class="hljs-built_in">console</span>.log(a);
    }
    b();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(a);
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{};
        <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
        a = <span class="hljs-number">100</span>;
        <span class="hljs-built_in">console</span>.log(a);
    }
    c();

    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d</span> (<span class="hljs-params">num</span>) </span>{
        <span class="hljs-built_in">console</span>.log(num);
        <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;
    }(<span class="hljs-number">100</span>))

    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span> (<span class="hljs-params">num</span>) </span>{
        <span class="hljs-built_in">console</span>.log(num);
        <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">num</span> (<span class="hljs-params"></span>) </span>{};
    }(<span class="hljs-number">100</span>))

    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params">num</span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">num</span> (<span class="hljs-params"></span>) </span>{};
        <span class="hljs-built_in">console</span>.log(num);
        <span class="hljs-keyword">var</span> num =<span class="hljs-number">10</span>
        <span class="hljs-built_in">console</span>.log(num);
    }(<span class="hljs-number">100</span>))

    <span class="hljs-comment">//仍然是预解析(在与解析过程中还要考虑一下当前变量的作用于)</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">m</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(a1); <span class="hljs-comment">// underfined</span>
        <span class="hljs-built_in">console</span>.log(a2); <span class="hljs-comment">// underfined</span>
        <span class="hljs-built_in">console</span>.log(b1); <span class="hljs-comment">// underfined</span>
        <span class="hljs-built_in">console</span>.log(b2); <span class="hljs-comment">// underfined</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>) {
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b1</span> (<span class="hljs-params"></span>)</span>{};
            <span class="hljs-keyword">var</span> a1 = <span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) {
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b2</span> (<span class="hljs-params"></span>)</span>{};
            <span class="hljs-keyword">var</span> a2 = <span class="hljs-number">10</span>;
        }
        <span class="hljs-built_in">console</span>.log(a1); <span class="hljs-comment">// underfined</span>
        <span class="hljs-built_in">console</span>.log(a2); <span class="hljs-comment">// 10</span>
        <span class="hljs-built_in">console</span>.log(b1); <span class="hljs-comment">// underfined</span>
        <span class="hljs-built_in">console</span>.log(b2); <span class="hljs-comment">// function</span>
    }
    m();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>&gt;<span class="hljs-number">1</span>) {
            arr = <span class="hljs-number">10</span>;
            brr = <span class="hljs-number">10</span>;
            <span class="hljs-keyword">let</span> arr;
            <span class="hljs-keyword">var</span> brr;
            <span class="hljs-built_in">console</span>.log(arr);
            <span class="hljs-built_in">console</span>.log(brr);
        }
    }
    n(); <span class="hljs-comment">// ReferenceError</span></code></pre>
<p>此阶段浏览器只是对var、function、函数形参进行一个解析的准备过程。而且在这个“预解析”过程中，有一个预解析先后顺序，即函数的形参 -&gt; function -&gt; var。而且重名时预留函数、后来者覆盖前者。预解析结果形参如果有值则解析到值，没有则为underfined，函数则解析到整个函数体，变量都为underfined；这道题目中没有参数出现，所以先不讨论。所以这道题在“预解析”时，函数声明权重优先会被提升</p>
<h3 id="articleHeader4">4. 一个算法问题</h3>
<p>有一个已经排序的数组，比方[1,4,6,9,11,15,18],给你一个新的数，插入到数组中，写一个function</p>
<h3 id="articleHeader5">5.  函数节流是什么，有什么优点（之前没有了解过这个概念，懵逼了）</h3>
<h4>函数节流的目的</h4>
<p>从字面上就可以理解，函数节流就是用来节流函数从而一定程度上优化性能的。例如，DOM 操作比起非DOM 交互需要更多的内存和CPU 时间。连续尝试进行过多的DOM 相关操作可能会导致浏览器挂起，有时候甚至会崩溃。尤其在IE 中使用onresize 事件处理程序的时候容易发生，当调整浏览器大小的时候，该事件会连续触发。在onresize 事件处理程序内部如果尝试进行DOM 操作，其高频率的更改可能会让浏览器崩溃。又例如，我们常见的一个搜索的功能，我们一般是绑定keyup事件，每按下一次键盘就搜索一次。但是我们的目的主要是每输入一些内容搜索一次而已。为了解决这些问题，就可以使用定时器对函数进行节流。</p>
<h4>函数节流的原理</h4>
<p>某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。<br><a href="http://www.cnblogs.com/LuckyWinty/p/5949970.html" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/LuckyW...</a></p>
<h3 id="articleHeader6">6.  写一个方法，实现传入两个参数(parentNode, childNode),要求如果childNode是parentNode的子孙节点，则返回为true，否则返回为false</h3>
<h3 id="articleHeader7">7.  dom事件流原理是什么，分为那几个阶段？</h3>
<p>事件捕获 处于目标阶段 事件冒泡</p>
<h3 id="articleHeader8">8.  dom事件委托什么原理，有什么优缺点</h3>
<h4>事件委托原理:事件冒泡机制</h4>
<h4>优点</h4>
<p>1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。<br>2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适</p>
<h4>缺点</h4>
<p>事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</p>
<h3 id="articleHeader9">9.  http的cache机制，以及200状态下怎么实现 from cache（表示接触最多的就是304的from cache）（用于优化，没有接触过，需要理解）</h3>
<h4>含义</h4>
<p>定义：浏览器缓存（Browser Caching）是为了加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。</p>
<h4>作用</h4>
<p>cache的作用：<br>1、减少延迟，让你的网站更快，提高用户体验。<br>2、避免网络拥塞，减少请求量，减少输出带宽。</p>
<h4>实现手段</h4>
<p>Cache-Control中的max-age是实现内容cache的主要手段，共有3种常用策略：max-age和Last-Modified（If-Modified-Since）的组合、仅max-age、max-age和ETag的组合。</p>
<p>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。<br>对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
<h3 id="articleHeader10">10.  一个原型链继承的问题</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="    // 有一个构造函数A，写一个函数B，继承A
    function A (num) {
        this.titileName = num;
    }
    A.prototype = {
        fn1: function () {},
        fn2: function () {}
    }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">    <span class="hljs-comment">// 有一个构造函数A，写一个函数B，继承A</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span> (<span class="hljs-params">num</span>) </span>{
        <span class="hljs-keyword">this</span>.titileName = num;
    }
    A.prototype = {
        <span class="hljs-attr">fn1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
        <span class="hljs-attr">fn2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
    }</code></pre>
<p>这个问题的关注点是B继承的A的静态属性，同时B的原型链中不存在A实例的titleName属性</p>
<h3 id="articleHeader11">11. 什么是虚拟dom</h3>
<p>React为啥这么大？因为它实现了一个虚拟DOM（Virtual DOM）。虚拟DOM是干什么的？这就要从浏览器本身讲起</p>
<p>如我们所知，在浏览器渲染网页的过程中，加载到HTML文档后，会将文档解析并构建DOM树，然后将其与解析CSS生成的CSSOM树一起结合产生爱的结晶——RenderObject树，然后将RenderObject树渲染成页面（当然中间可能会有一些优化，比如RenderLayer树）。这些过程都存在与渲染引擎之中，渲染引擎在浏览器中是于JavaScript引擎（JavaScriptCore也好V8也好）分离开的，但为了方便JS操作DOM结构，渲染引擎会暴露一些接口供JavaScript调用。由于这两块相互分离，通信是需要付出代价的，因此JavaScript调用DOM提供的接口性能不咋地。各种性能优化的最佳实践也都在尽可能的减少DOM操作次数。</p>
<p>而虚拟DOM干了什么？它直接用JavaScript实现了DOM树（大致上）。组件的HTML结构并不会直接生成DOM，而是映射生成虚拟的JavaScript DOM结构，React又通过在这个虚拟DOM上实现了一个 diff 算法找出最小变更，再把这些变更写入实际的DOM中。这个虚拟DOM以JS结构的形式存在，计算性能会比较好，而且由于减少了实际DOM操作次数，性能会有较大提升</p>
<h3 id="articleHeader12">12. js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型</h3>
<p>1.基本数据类型（自身不可拆分的）：Undefined、Null、Boolean、Number、String<br>2.引用数据类型（对象）：Object （Array，Date，RegExp，Function）<br>ES6基本数据类型多了个symbol 据说这道题刷了百分之二十的人   感谢Abbyshen提出</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function gettype(nm){
    return Object.prototype.toString.call(nm);
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs ada"><code><span class="hljs-keyword">function</span> <span class="hljs-title">gettype</span>(nm){
    <span class="hljs-keyword">return</span> <span class="hljs-type">Object.prototype.toString.call(nm)</span>;
}</code></pre>
<h3 id="articleHeader13">13. dom选择器优先级是什么，以及权重值计算（一道老问题了）</h3>
<p>1.行内样式 1000<br>2.id 0100<br>3.类选择器、伪类选择器、属性选择器[type="text"] 0010<br>4.标签选择器、伪元素选择器(::first-line) 0001<br>5.通配符*、子选择器、相邻选择器 0000</p>
<h3 id="articleHeader14">14. vue双向数据绑定的原理是什么</h3>
<p>首先传输对象的双向数据绑定 Object.defineProperty(target, key, decription),在decription中设置get和set属性（此时应注意description中get和set不能与描述属性共存）<br>数组的实现与对象不同。<br>同时运用观察者模式实现wather，用户数据和view视图的更新</p>
<h3 id="articleHeader15">15. react和vue比较来说有什么区别</h3>
<p>1 component层面，web component和virtual dom<br>2 数据绑定（vue双向，react的单向）等好多<br>3 计算属性  vue 有，提供方便；而 react 不行<br>4 vue 可以 watch 一个数据项；而 react 不行<br>5 vue 由于提供的 direct 特别是预置的 directive 因为场景场景开发更容易；react 没有<br>6 生命周期函数名太长 directive</p>
<h3 id="articleHeader16">16. git使用过程中，如果你在开发着业务，突然另一个分支有一个bug要改，你怎么办</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="git stash       //将本次修改存到暂存区（紧急切换分支时）
git stash pop   //将所有暂存区的内容取出来
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs gauss"><code>git stash       <span class="hljs-comment">//将本次修改存到暂存区（紧急切换分支时）</span>
git stash <span class="hljs-keyword">pop</span>   <span class="hljs-comment">//将所有暂存区的内容取出来</span>
</code></pre>
<h3 id="articleHeader17">17. postcss的使用</h3>
<h3 id="articleHeader18">18. 网页布局有哪几种，有什么区别</h3>
<p>静态、自适应、流式、响应式四种网页布局<br>静态布局：意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；<br>自适应布局：就是说你看到的页面，里面元素的位置会变化而大小不会变化；<br>流式布局：你看到的页面，元素的大小会变化而位置不会变化——这就导致如果屏幕太大或者太小都会导致元素无法正常显示。<br>自适应布局：每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</p>
<h3 id="articleHeader19">18. 执行下面代码</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var a = {};
var b = {key: 'b'};
var c = {key: 'c'};
var d = [3,5,6];
a[b] = 123;
a[c] = 345;
a[d] = 333;
console.log(a[b]);  // 345
console.log(a[c]);  // 345
console.log(a[d]);  // 333" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> a = {};
<span class="hljs-keyword">var</span> b = {<span class="hljs-attr">key</span>: <span class="hljs-string">'b'</span>};
<span class="hljs-keyword">var</span> c = {<span class="hljs-attr">key</span>: <span class="hljs-string">'c'</span>};
<span class="hljs-keyword">var</span> d = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];
a[b] = <span class="hljs-number">123</span>;
a[c] = <span class="hljs-number">345</span>;
a[d] = <span class="hljs-number">333</span>;
<span class="hljs-built_in">console</span>.log(a[b]);  <span class="hljs-comment">// 345</span>
<span class="hljs-built_in">console</span>.log(a[c]);  <span class="hljs-comment">// 345</span>
<span class="hljs-built_in">console</span>.log(a[d]);  <span class="hljs-comment">// 333</span></code></pre>
<h3 id="articleHeader20">19.</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="    var R = (function() {
        var u = {a:1,b:2};
        var r = {
            fn: function(k) {
                return u[k];
            }
        }
        return r;
    }());
    R.fn('a');  // 1" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="JS">    <span class="hljs-keyword">var</span> R = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> u = {<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>};
        <span class="hljs-keyword">var</span> r = {
            <span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k</span>) </span>{
                <span class="hljs-keyword">return</span> u[k];
            }
        }
        <span class="hljs-keyword">return</span> r;
    }());
    R.fn(<span class="hljs-string">'a'</span>);  <span class="hljs-comment">// 1</span></code></pre>
<p>上述代码中如何获取匿名函数中的u</p>
<h3 id="articleHeader21">20. 不适用循环语句（包括map、forEach方法）实现一个100长度的数组，索引值和值相同的数组[0,1,2,3,4,5........99]</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var arr = new Array(100);
//方法1
[...arr.keys()];
//方法二
Array.from(arr.keys());

//方法三
Array.from({length: 100});

// 方法四 借助string
var arr1 = new Array(101);
var str = arr1.join('1,');
str = str.replace(/(1\,)/g, function ($0, $1, index) {
    var start = '' + Math.ceil(index/2);
    if(index < str.length - 2) {
        start += ','
    }
    return start;
});
return str.split(',');


// 方法五（函数式，参考网络）
function reduce(arr, val) {
    if(Object.prototype.toString.apply(val)){
        return;
    }
    if(val >= 100) {
        return arr;
    }
    arr.push(val);
    return reduce(arr, val+1);
}
var res = reduce([], 0)" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>);
<span class="hljs-comment">//方法1</span>
[...arr.keys()];
<span class="hljs-comment">//方法二</span>
<span class="hljs-built_in">Array</span>.from(arr.keys());

<span class="hljs-comment">//方法三</span>
<span class="hljs-built_in">Array</span>.from({<span class="hljs-attr">length</span>: <span class="hljs-number">100</span>});

<span class="hljs-comment">// 方法四 借助string</span>
<span class="hljs-keyword">var</span> arr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">101</span>);
<span class="hljs-keyword">var</span> str = arr1.join(<span class="hljs-string">'1,'</span>);
str = str.replace(<span class="hljs-regexp">/(1\,)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$<span class="hljs-number">0</span>, $<span class="hljs-number">1</span>, index</span>) </span>{
    <span class="hljs-keyword">var</span> start = <span class="hljs-string">''</span> + <span class="hljs-built_in">Math</span>.ceil(index/<span class="hljs-number">2</span>);
    <span class="hljs-keyword">if</span>(index &lt; str.length - <span class="hljs-number">2</span>) {
        start += <span class="hljs-string">','</span>
    }
    <span class="hljs-keyword">return</span> start;
});
<span class="hljs-keyword">return</span> str.split(<span class="hljs-string">','</span>);


<span class="hljs-comment">// 方法五（函数式，参考网络）</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">arr, val</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Object</span>.prototype.toString.apply(val)){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span>(val &gt;= <span class="hljs-number">100</span>) {
        <span class="hljs-keyword">return</span> arr;
    }
    arr.push(val);
    <span class="hljs-keyword">return</span> reduce(arr, val+<span class="hljs-number">1</span>);
}
<span class="hljs-keyword">var</span> res = reduce([], <span class="hljs-number">0</span>)</code></pre>
<h3 id="articleHeader22">21. 下面语句执行结果输出</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var a = function (val, index) {
    console.log(index);
    return {
        fn: function (name) {
            return a(name, val);
        }
    }
}

var b = a(0); // underfined
b.fn(1); // 0
b.fn(2); // 0
b.fn(3); // 0" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, index</span>) </span>{
    <span class="hljs-built_in">console</span>.log(index);
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
            <span class="hljs-keyword">return</span> a(name, val);
        }
    }
}

<span class="hljs-keyword">var</span> b = a(<span class="hljs-number">0</span>); <span class="hljs-comment">// underfined</span>
b.fn(<span class="hljs-number">1</span>); <span class="hljs-comment">// 0</span>
b.fn(<span class="hljs-number">2</span>); <span class="hljs-comment">// 0</span>
b.fn(<span class="hljs-number">3</span>); <span class="hljs-comment">// 0</span></code></pre>
<h3 id="articleHeader23">22. 科普</h3>
<p>1) dom节点的根节点是不是body<br>回答： 不是，dom节点的根节点是html(包含head和body，head中分为meta、title等。body又分为一组)</p>
<p>2）dom元素都会有offsetParent吗<br>回答： offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位, 则offsetParent属性的取值为根元素(在标准兼容模式下为html元素；在怪异呈现模式下为body元素)的引用。 当容器元素的style.display 被设置为 "none"时（译注：IE和Opera除外），offsetParent属性 返回 null。</p>
<p>3) [1,3,5]转译成字符串是什么<br>回答： '1,3,5'<br>调用toString方法，生成该字符串</p>
<p>4）li标签的祖级元素可以为li，父级元素也可以为例<br>回答： 错误</p>
<h3 id="articleHeader24">23. jsonp原理，jquery是怎么实现的，这样实现有什么好处和坏处</h3>
<h4>原理</h4>
<p>在同源策略下;在某个服务器下的页面是无法获取到该服务器以外的数据的;Jquery中ajax 的核心是通过 XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加 &lt;script&gt;标签来调用服务器提供的 js脚本<br>当我们正常地请求一个JSON数据的时候，服务端返回的是一串 JSON类型的数据，而我们使用 JSONP模式来请求数据的时候服务端返回的是一段可执行的 JavaScript代码。因为jsonp 跨域的原理就是用的动态加载 script的src ，所以我们只能把参数通过 url的方式传递, 所以jsonp的 type类型只能是get ！</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="$.ajax({
    url: 'http://192.168.1.114/yii/demos/test.php', //不同的域
    type: 'GET', // jsonp模式只有GET 是合法的
    data: {
        'action': 'aaron'
    },
    dataType: 'jsonp', // 数据类型
    jsonp: 'backfunc', // 指定回调函数名，与服务器端接收的一致，并回传回来
})
其实jquery 内部会转化成
http://192.168.1.114/yii/demos/test.php?backfunc=jQuery2030038573939353227615_1402643146875&amp;action=aaron
然后动态加载
<script type=&quot;text/javascript&quot;src=&quot;http://192.168.1.114/yii/demos/test.php?backfunc=>
然后后端就会执行backfunc(传递参数 )，把数据通过实参的形式发送出去。
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lasso"><code>$.ajax({
    url: <span class="hljs-string">'http://192.168.1.114/yii/demos/test.php'</span>, <span class="hljs-comment">//不同的域</span>
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'GET'</span>, <span class="hljs-comment">// jsonp模式只有GET 是合法的</span>
    <span class="hljs-built_in">data</span>: {
        <span class="hljs-string">'action'</span>: <span class="hljs-string">'aaron'</span>
    },
    dataType: <span class="hljs-string">'jsonp'</span>, <span class="hljs-comment">// 数据类型</span>
    jsonp: <span class="hljs-string">'backfunc'</span>, <span class="hljs-comment">// 指定回调函数名，与服务器端接收的一致，并回传回来</span>
})
其实jquery 内部会转化成
http:<span class="hljs-comment">//192.168.1.114/yii/demos/test.php?backfunc=jQuery2030038573939353227615_1402643146875&amp;action=aaron</span>
然后动态加载
&lt;script <span class="hljs-keyword">type</span>=<span class="hljs-string">"text/javascript"</span>src=<span class="hljs-string">"http://192.168.1.114/yii/demos/test.php?backfunc=&gt;
然后后端就会执行backfunc(传递参数 )，把数据通过实参的形式发送出去。
</span></code></pre>
<p>在jquery 源码中， jsonp的实现方式是动态添加&lt;script&gt;标签来调用服务器提供的 js脚本。jquery 会在window对象中加载一个全局的函数，当 &lt;script&gt;代码插入时函数执行，执行完毕后就 &lt;script&gt;会被移除。同时jquery还对非跨域的请求进行了优化，如果这个请求是在同一个域名下那么他就会像正常的 Ajax请求一样工作。</p>
<h3 id="articleHeader25">24. http协议属于七层协议中的哪一层，下一层是什么</h3>
<p>七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br>tcp属于传输层；http属于应用层。<br>表现层</p>
<h3 id="articleHeader26">25. js垃圾回收机制知道哪些，v8引擎使用的哪一种</h3>
<h4>js的两种回收机制</h4>
<p>1 标记清除（mark and sweep）<br>2 引用计数（reference counting）</p>
<h4>javascript与V8引擎</h4>
<p>垃圾回收机制的好处和坏处</p>
<p>好处：大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题。</p>
<p>坏处：自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理。</p>
<p>V8 自动垃圾回收算法<br><a href="https://segmentfault.com/a/1190000000440270">https://segmentfault.com/a/11...</a></p>
<h3 id="articleHeader27">26. 作用域什么时候生成的？</h3>
<p>页面加载--&gt;创建window全局对象，并生成全局作用域--&gt;然后生成执行上下文，预解析变量(变量提升)，生成全局变量对象；<br>$scope</p>
<h3 id="articleHeader28">27. websocket长连接原理是什么</h3>
<h4>含义</h4>
<p>Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。</p>
<h4>原理</h4>
<p>类似长轮循长连接 ; 发送一次请求 ; 源源不断的得到信息</p>
<h3 id="articleHeader29">28. http缓存知道哪些</h3>
<p><a href="http://blog.csdn.net/yzf913214/article/details/52268651" rel="nofollow noreferrer" target="_blank">http://blog.csdn.net/yzf91321...</a></p>
<h3 id="articleHeader30">29. 讲一下事件循环机制</h3>
<p>执行上下文(Execution context)<br>函数调用栈(call stack)<br>队列数据结构(queue)<br>Promise</p>
<p><a href="https://zhuanlan.zhihu.com/p/25407758" rel="nofollow noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/...</a></p>
<h3 id="articleHeader31">30. 理解web安全吗？都有哪几种，介绍以及如何预防</h3>
<p>1.XSS，也就是跨站脚本注入</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="攻击方法：
1. 手动攻击:
编写注入脚本，比如”/><script>alert(document.cookie());</script><!--等，
手动测试目标网站上有的input, textarea等所有可能输入文本信息的区域
2. 自动攻击
利用工具扫描目标网站所有的网页并自动测试写好的注入脚本，比如：Burpsuite等
防御方法：
1. 将cookie等敏感信息设置为httponly，禁止Javascript通过document.cookie获得
2. 对所有的输入做严格的校验尤其是在服务器端，过滤掉任何不合法的输入，比如手机号必须是数字，通常可以采用正则表达式
3. 净化和过滤掉不必要的html标签，比如：<iframe>, alt,<script> 等
4. 净化和过滤掉不必要的Javascript的事件标签，比如：onclick, onfocus等
5. 转义单引号，双引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符
6. 设置浏览器的安全设置来防范典型的XSS注入
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code>攻击方法：
<span class="hljs-number">1.</span> 手动攻击:
编写注入脚本，比如”/&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">alert(<span class="hljs-built_in">document</span>.cookie());</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>&lt;!--等，
手动测试目标网站上有的input, textarea等所有可能输入文本信息的区域
2. 自动攻击
利用工具扫描目标网站所有的网页并自动测试写好的注入脚本，比如：Burpsuite等
防御方法：
1. 将cookie等敏感信息设置为httponly，禁止Javascript通过document.cookie获得
2. 对所有的输入做严格的校验尤其是在服务器端，过滤掉任何不合法的输入，比如手机号必须是数字，通常可以采用正则表达式
3. 净化和过滤掉不必要的html标签，比如：&lt;iframe&gt;, alt,&lt;script&gt; 等
4. 净化和过滤掉不必要的Javascript的事件标签，比如：onclick, onfocus等
5. 转义单引号，双引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符
6. 设置浏览器的安全设置来防范典型的XSS注入
</code></pre>
<p>2.SQL注入</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="攻击方法：
编写恶意字符串，比如‘ or  1=1--等，
手动测试目标网站上所有涉及数据库操作的地方
防御方法：
1. 禁止目标网站利用动态拼接字符串的方式访问数据库
2. 减少不必要的数据库抛出的错误信息
3. 对数据库的操作赋予严格的权限控制
4. 净化和过滤掉不必要的SQL保留字，比如：where, or, exec 等
5. 转义单引号，上引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs lsl"><code>攻击方法：
编写恶意字符串，比如‘ or  <span class="hljs-number">1</span>=<span class="hljs-number">1</span>--等，
手动测试目标网站上所有涉及数据库操作的地方
防御方法：
<span class="hljs-number">1.</span> 禁止目标网站利用动态拼接字符串的方式访问数据库
<span class="hljs-number">2.</span> 减少不必要的数据库抛出的错误信息
<span class="hljs-number">3.</span> 对数据库的操作赋予严格的权限控制
<span class="hljs-number">4.</span> 净化和过滤掉不必要的SQL保留字，比如：where, or, exec 等
<span class="hljs-number">5.</span> 转义单引号，上引号，尖括号等特殊字符，可以采用htmlencode编码 或者过滤掉这些特殊字符
</code></pre>
<p>3.CSRF，也就是跨站请求伪造</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="就是攻击者冒用用户的名义，向目标站点发送请求
防范方法：
1. 在客户端进行cookie的hashing，并在服务端进行hash认证
2. 提交请求是需要填写验证码
3. 使用One-Time Tokens为不同的表单创建不同的伪随机值  
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs markdown"><code>就是攻击者冒用用户的名义，向目标站点发送请求
防范方法：
<span class="hljs-bullet">1. </span>在客户端进行cookie的hashing，并在服务端进行hash认证
<span class="hljs-bullet">2. </span>提交请求是需要填写验证码
<span class="hljs-bullet">3. </span>使用One-Time Tokens为不同的表单创建不同的伪随机值  
</code></pre>
<h3 id="articleHeader32">40. sessionStorage和localstorage能跨域拿到吗？比如我在www.baidu.com设置的值能在m.baidu.com能拿到吗？为什么</h3>
<p>localStorage会跟cookie一样受到跨域的限制，会被document.domain影响</p>
<h3 id="articleHeader33">41. localstorage不能手动删除的时候，什么时候过期</h3>
<p>除非被清除，否则永久保存  clear()可清楚<br>sessionStorage  仅在当前会话下有效，关闭页面或浏览器后被清除</p>
<h3 id="articleHeader34">42. cookie可以设置什么域？可以设置.com吗</h3>
<p>可以通过设置domin来实现</p>
<h3 id="articleHeader35">43. 登录状态的保存你认为可以保存在sessionstorage或者localstorage或者cookie或者你知道的哪种方式，存在了哪里？？为什么保存在那里</h3>
<h3 id="articleHeader36">44. flux -&gt; redux -&gt; mobx 变化的本质是什么</h3>
<p>存储结构   将对象加工可观察   函数式 vs 面向对象<br><a href="https://zhuanlan.zhihu.com/p/25585910?refer=purerender" rel="nofollow noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/...</a></p>
<h3 id="articleHeader37">45. 按需加载路由怎么加载对应的chunk文件的？换句话说浏览器怎么知道什么时候加载这个chunk，以及webpack是怎么识别那个多个经过hash过的chunk文件</h3>
<h3 id="articleHeader38">50. get和post有什么区别？get可以通过body传递数据吗</h3>
<p>把数据放到 body 里面，必须用 POST 方式取，这是 HTTP 协议限制的。</p>
<h3 id="articleHeader39">51. 下拉刷新你怎么实现</h3>
<h3 id="articleHeader40">52. 预加载options请求为什么会出现，能避免这个请求吗？</h3>
<h1 id="articleHeader41">2018年面试题总结</h1>
<p>收集一下网上的2018年的面试题 ; 希望能对你有所帮助~~</p>
<h3 id="articleHeader42">1.使用css实现一个持续的动画效果</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="animation:mymove 5s infinite;
@keyframes mymove {
from {top:0px;}
to {top:200px;}
}

animation-name    规定需要绑定到选择器的 keyframe 名称。
animation-duration    规定完成动画所花费的时间，以秒或毫秒计。
animation-timing-function    规定动画的速度曲线。
animation-delay    规定在动画开始之前的延迟。
animation-iteration-count    规定动画应该播放的次数。
animation-direction    规定是否应该轮流反向播放动画。" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs scss"><code><span class="hljs-attribute">animation</span>:mymove <span class="hljs-number">5s</span> infinite;
@keyframes mymove {
from {<span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;}
to {<span class="hljs-attribute">top</span>:<span class="hljs-number">200px</span>;}
}

<span class="hljs-attribute">animation-name</span>    规定需要绑定到选择器的 keyframe 名称。
<span class="hljs-attribute">animation-duration</span>    规定完成动画所花费的时间，以秒或毫秒计。
<span class="hljs-attribute">animation-timing-function</span>    规定动画的速度曲线。
<span class="hljs-attribute">animation-delay</span>    规定在动画开始之前的延迟。
<span class="hljs-attribute">animation-iteration-count</span>    规定动画应该播放的次数。
<span class="hljs-attribute">animation-direction</span>    规定是否应该轮流反向播放动画。</code></pre>
<h3 id="articleHeader43">2.使用js实现一个持续的动画效果</h3>
<p>最开始的思路是用定时器实现，最后没有想的太完整，面试官给出的答案是用<code>requestAnimationFrame</code></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="· 定时器思路
var e = document.getElementById('e')
var falg = true;
var left = 0;
setInterval(() => {
    left == 0 ? falg = true : left == 100 ? falg = false : ''
    falg ? e.style.left = ` ${left++}px` : e.style.left = ` ${left--}px`
}, 1000 / 60)
· requestAnimationFrame
兼容性处理
window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          function(callback){
            window.setTimeout(callback, 1000 / 60);
          };
})();
var e = document.getElementById(&quot;e&quot;)
var flag = true;
var left = 0;
function render() {
    left == 0 ? flag = true : left == 100 ? flag = false : '';
    flag ? e.style.left = ` ${left++}px` :
        e.style.left = ` ${left--}px`;
}
(function animloop() {
    render();
    requestAnimFrame(animloop);
})();
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code>· 定时器思路
<span class="hljs-keyword">var</span> e = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'e'</span>)
<span class="hljs-keyword">var</span> falg = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">var</span> left = <span class="hljs-number">0</span>;
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    left == <span class="hljs-number">0</span> ? falg = <span class="hljs-literal">true</span> : left == <span class="hljs-number">100</span> ? falg = <span class="hljs-literal">false</span> : <span class="hljs-string">''</span>
    falg ? e.style.left = <span class="hljs-string">` <span class="hljs-subst">${left++}</span>px`</span> : e.style.left = <span class="hljs-string">` <span class="hljs-subst">${left--}</span>px`</span>
}, <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)
· requestAnimationFrame
兼容性处理
<span class="hljs-built_in">window</span>.requestAnimFrame = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">return</span>  <span class="hljs-built_in">window</span>.requestAnimationFrame       ||
          <span class="hljs-built_in">window</span>.webkitRequestAnimationFrame ||
          <span class="hljs-built_in">window</span>.mozRequestAnimationFrame    ||
          <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)</span>{
            <span class="hljs-built_in">window</span>.setTimeout(callback, <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>);
          };
})();
<span class="hljs-keyword">var</span> e = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"e"</span>)
<span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">var</span> left = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{
    left == <span class="hljs-number">0</span> ? flag = <span class="hljs-literal">true</span> : left == <span class="hljs-number">100</span> ? flag = <span class="hljs-literal">false</span> : <span class="hljs-string">''</span>;
    flag ? e.style.left = <span class="hljs-string">` <span class="hljs-subst">${left++}</span>px`</span> :
        e.style.left = <span class="hljs-string">` <span class="hljs-subst">${left--}</span>px`</span>;
}
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animloop</span>(<span class="hljs-params"></span>) </span>{
    render();
    requestAnimFrame(animloop);
})();
</code></pre>
<p>不足之处请指正（毕竟是现学的）顺便查了一下优势：</p>
<p>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果<br>解决毫秒的不精确性<br>避免过度渲染（渲染频率太高、tab 不可见暂停等等）<br>注：requestAnimFrame 和 定时器一样也头一个类似的清除方法 cancelAnimationFrame</p>
<h3 id="articleHeader44">3.右边宽度固定，左边自适应</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="第一种：

<style>
body{
    display: flex;
}
.left{
    background-color: rebeccapurple;
    height: 200px;
    flex: 1;
}
.right{
    background-color: red;
    height: 200px;
    width: 100px;
}
</style>
<body>
    <div class=&quot;left&quot;></div>
    <div class=&quot;right&quot;></div>
</body>
第二种

<style>
    div {
        height: 200px;
    }
    .left {
        float: right;
        width: 200px;
        background-color: rebeccapurple;
    }
    .right {
        margin-right: 200px;
        background-color: red;
    }
</style>
<body>
    <div class=&quot;left&quot;></div>
    <div class=&quot;right&quot;></div>
</body>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xml"><code>第一种：

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">body</span>{
    <span class="hljs-attribute">display</span>: flex;
}
<span class="hljs-selector-class">.left</span>{
    <span class="hljs-attribute">background-color</span>: rebeccapurple;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;
}
<span class="hljs-selector-class">.right</span>{
    <span class="hljs-attribute">background-color</span>: red;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
第二种

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-selector-tag">div</span> {
        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    }
    <span class="hljs-selector-class">.left</span> {
        <span class="hljs-attribute">float</span>: right;
        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
        <span class="hljs-attribute">background-color</span>: rebeccapurple;
    }
    <span class="hljs-selector-class">.right</span> {
        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;
        <span class="hljs-attribute">background-color</span>: red;
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<h3 id="articleHeader45">4.水平垂直居中</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="第一种

#container{
    position:relative;
}

#center{
    width:100px;
    height:100px;
    position:absolute;
    top:50%;
    left:50%;
    transform: translate(-50%,-50%);
}
第二种

#container{
    position:relative;
}

#center{
    width:100px;
    height:100px;
    position:absolute;
    top:50%;
    left:50%;
    margin:-50px 0 0 -50px;
}
第三种

#container{
    position:relative;
}

#center{
    position:absolute;
    margin:auto;
    top:0;
    bottom:0;
    left:0;
    right:0;
}
第四种 flex

#container{
    display:flex;
    justify-content:center;
    align-items: center;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code>第一种

<span class="hljs-selector-id">#container</span>{
    <span class="hljs-attribute">position</span>:relative;
}

<span class="hljs-selector-id">#center</span>{
    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">position</span>:absolute;
    <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;
    <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-50%,-50%);
}
第二种

<span class="hljs-selector-id">#container</span>{
    <span class="hljs-attribute">position</span>:relative;
}

<span class="hljs-selector-id">#center</span>{
    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">position</span>:absolute;
    <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;
    <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;
    <span class="hljs-attribute">margin</span>:-<span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -<span class="hljs-number">50px</span>;
}
第三种

<span class="hljs-selector-id">#container</span>{
    <span class="hljs-attribute">position</span>:relative;
}

<span class="hljs-selector-id">#center</span>{
    <span class="hljs-attribute">position</span>:absolute;
    <span class="hljs-attribute">margin</span>:auto;
    <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;
    <span class="hljs-attribute">bottom</span>:<span class="hljs-number">0</span>;
    <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;
    <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;
}
第四种 <span class="hljs-selector-tag">flex</span>

<span class="hljs-selector-id">#container</span>{
    <span class="hljs-attribute">display</span>:flex;
    <span class="hljs-attribute">justify-content</span>:center;
    <span class="hljs-attribute">align-items</span>: center;
}</code></pre>
<h3 id="articleHeader46">5.四种定位的区别</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="`static` 是默认值
`relative` 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中
`absolute` 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指`position`不是`static`的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以`body`元素为偏移参照基准, 完全脱离了标准文档流。
`fixed` 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs autohotkey"><code>`static` 是默认值
`relative` 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中
`absolute` 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指`position`不是`static`的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以`body`元素为偏移参照基准, 完全脱离了标准文档流。
`fixed` 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。</code></pre>
<h3 id="articleHeader47">6.封装一个函数，参数是定时器的时间，.then执行回调函数。</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function sleep (time) {
  return new Promise((resolve) => setTimeout(resolve, time));
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span> (<span class="hljs-params">time</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> setTimeout(resolve, time));
}</code></pre>
<h3 id="articleHeader48">7.一行代码实现数组去重？</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="[...new Set([1,2,3,1,'a',1,'a'])]" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs json"><code style="word-break: break-word; white-space: initial;">[...new Set([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,'a',<span class="hljs-number">1</span>,'a'])]</code></pre>
<h3 id="articleHeader49">8.使用addEventListener点击li弹出内容，并且动态添加li之后有效</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
</ul>
var ulNode = document.getElementById(&quot;ul&quot;);
    ulNode.addEventListener('click', function (e) {
        if (e.target &amp;&amp; e.target.nodeName.toUpperCase() == &quot;LI&quot;) {
            alert(e.target.innerHTML);
        }
    }, false);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs maxima"><code>&lt;ul&gt;
    &lt;<span class="hljs-built_in">li</span>&gt;<span class="hljs-number">1</span>&lt;/<span class="hljs-built_in">li</span>&gt;
    &lt;<span class="hljs-built_in">li</span>&gt;<span class="hljs-number">2</span>&lt;/<span class="hljs-built_in">li</span>&gt;
    &lt;<span class="hljs-built_in">li</span>&gt;<span class="hljs-number">3</span>&lt;/<span class="hljs-built_in">li</span>&gt;
    &lt;<span class="hljs-built_in">li</span>&gt;<span class="hljs-number">4</span>&lt;/<span class="hljs-built_in">li</span>&gt;
&lt;/ul&gt;
<span class="hljs-built_in">var</span> ulNode = document.getElementById(<span class="hljs-string">"ul"</span>);
    ulNode.addEventListener('click', function (e) {
        <span class="hljs-keyword">if</span> (e.target &amp;&amp; e.target.nodeName.toUpperCase() == <span class="hljs-string">"LI"</span>) {
            alert(e.target.innerHTML);
        }
    }, <span class="hljs-literal">false</span>);</code></pre>
<h3 id="articleHeader50">9.怎么判断两个对象相等</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="JSON.stringify(obj)==JSON.stringify(obj);//true" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code style="word-break: break-word; white-space: initial;"><span class="hljs-built_in">JSON</span>.stringify(obj)==<span class="hljs-built_in">JSON</span>.stringify(obj);<span class="hljs-comment">//true</span></code></pre>
<h3 id="articleHeader51">10.Vue router 除了 router-link 怎么实现跳转?</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="router.go(1)
router.push('/')" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs less"><code><span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.go</span>(<span class="hljs-number">1</span>)
<span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.push</span>(<span class="hljs-string">'/'</span>)</code></pre>
<h3 id="articleHeader52">11.Vue router 跳转和 location.href 有什么区别？</h3>
<p><code>router</code> 是 <code>hash</code> 改变<br><code>location.href</code> 是页面跳转，刷新页面</p>
<h3 id="articleHeader53">12.重排和重绘</h3>
<p>部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算。这被称为重排。注意这里至少会有一次重排-初始化页面布局。<br>由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新被称为重绘。</p>
<h3 id="articleHeader54">13.什么情况会触发重排和重绘</h3>
<p>添加、删除、更新 DOM 节点<br>通过 display: none 隐藏一个 DOM 节点-触发重排和重绘<br>通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化<br>移动或者给页面中的 DOM 节点添加动画<br>添加一个样式表，调整样式属性<br>用户行为，例如调整窗口大小，改变字号，或者滚动。</p>
<h3 id="articleHeader55">14.js bind 实现机制？手写一个 bind 方法？</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function bind(fn, context){
  return function (){
     return fn.apply(context, arguments);
  }
}
// 柯理化函数思想   感谢pursuitTom的提出
Function.prototype.bind = function (context) {
    var args = Array.prototype.slice.call(arguments, 1);
    var _this = this;
    return function () {
        var thisArgs = [].slice.call(arguments);
        return _this.apply(context, args.concat(thisArgs))
    };
}
// ES6写法 感谢waterc的提出
Function.prototype.bind = function(context, ...res) {
    let self = this
    return function(...arg) {
        return self.apply(context, [...res,...arg])
    }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span><span class="hljs-params">(fn, context)</span></span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span>{
     <span class="hljs-keyword">return</span> fn.apply(context, arguments);
  }
}
<span class="hljs-comment">// 柯理化函数思想   感谢pursuitTom的提出</span>
Function.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(context)</span> </span>{
    <span class="hljs-keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> thisArgs = [].slice.call(arguments);
        <span class="hljs-keyword">return</span> _this.apply(context, args.concat(thisArgs))
    };
}
<span class="hljs-comment">// ES6写法 感谢waterc的提出</span>
Function.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(context, <span class="hljs-rest_arg">...res</span>)</span> </span>{
    let self = <span class="hljs-keyword">this</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...arg</span>)</span> </span>{
        <span class="hljs-keyword">return</span> self.apply(context, [...res,...arg])
    }
}</code></pre>
<h3 id="articleHeader56">15.多个函数</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var a = (function(){return '1';}, function(){return 1;})();
console.log(typeof a); //number" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> a = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-string">'1'</span>;}, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;})();
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//number</span></code></pre>
<h3 id="articleHeader57">16.__proto__、prototype、Object.getPrototypeOf()</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="__proto__是指内部原型，和Object.getPrototypeOf()结果等价
function f(){}
f.__proto__ === Object.getPrototypeOf(f); //true
f.prototype === Object.getPrototypeOf(f); //false" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs delphi"><code>__proto__是指内部原型，和<span class="hljs-keyword">Object</span>.getPrototypeOf()结果等价
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">{}</span>
<span class="hljs-title">f</span>.__<span class="hljs-title">proto__</span> === <span class="hljs-title">Object</span>.<span class="hljs-title">getPrototypeOf</span><span class="hljs-params">(f)</span>;</span> <span class="hljs-comment">//true</span>
f.prototype === <span class="hljs-keyword">Object</span>.getPrototypeOf(f); <span class="hljs-comment">//false</span></code></pre>
<h3 id="articleHeader58">17.浏览记录前后跳转（尚未试验）</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<a href=&quot;javascript:history.go(-1)&quot;>backward</a>
<a href=&quot;javascript:history.go(1)&quot;>forward</a>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:history.go(-1)"</span>&gt;</span>backward<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:history.go(1)"</span>&gt;</span>forward<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>
<h3 id="articleHeader59">下面再有的题就不写序号了；正好到17；是自己喜欢的数字；哈哈</h3>
<h3 id="articleHeader60">setTimeout 和 setInterval 细谈</h3>
<p>常问的点，前者是在一定时间过后将函数添加至执行队列，执行时间=延迟时间+之前函数代码执行时间+执行函数时间。<br>后者是不管前一次是否执行完毕，每隔一定时间重复执行，用于精准执行互相没有影响的重复操作。<br>如果需要控制前后执行顺序，最好使用setTimeout模拟setInterval</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var time = 400, times = 0, max = 10;
function func(){
  times++;
  if(times < max){
    //code here
    setTimeout(func, time);
  } else {
    console.log(&quot;finished&quot;);
  }
}
setTimeout(func, time);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs swift"><code><span class="hljs-keyword">var</span> time = <span class="hljs-number">400</span>, times = <span class="hljs-number">0</span>, <span class="hljs-built_in">max</span> = <span class="hljs-number">10</span>;
function <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{
  times++;
  <span class="hljs-keyword">if</span>(times &lt; <span class="hljs-built_in">max</span>){
    <span class="hljs-comment">//code here</span>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">func</span>, <span class="hljs-title">time</span>);
  } <span class="hljs-title">else</span> </span>{
    console.log(<span class="hljs-string">"finished"</span>);
  }
}
setTimeout(<span class="hljs-function"><span class="hljs-keyword">func</span>, <span class="hljs-title">time</span>);</span></code></pre>
<h3 id="articleHeader61">判断多图片加载完毕</h3>
<p>注：用jQueryObject.ready()只能判断dom结构加载完毕<br>好像描述的不是很清楚，这里写一下代码。<br>方法1：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var counter = 0;
var queryInterval = 30; //ms
var pics = document.getElementsByClassName(&quot;pics&quot;);

function singleQuery(i){
  if(pics[i].complete){
    counter++;
    console.log(i + &quot; is loaded&quot;);
  } else {
    setTimeout(singleQuery, queryInterval, i);
  }
}

function allQuery(callback){
  if(counter < pics.length){
    console.log(&quot;current number of loaded pics: &quot; + counter);
    setTimeout(allQuery, queryInterval, callback);
  } else {
    console.log(&quot;All pics are loaded.&quot;);
    callback();
  }
}

for(var i = 0; i < pics.length; i++){
  setTimeout(singleQuery, queryInterval, i);
}

setTimeout(allQuery, queryInterval, callback);
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> queryInterval = <span class="hljs-number">30</span>; <span class="hljs-comment">//ms</span>
<span class="hljs-keyword">var</span> pics = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">"pics"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">singleQuery</span>(<span class="hljs-params">i</span>)</span>{
  <span class="hljs-keyword">if</span>(pics[i].complete){
    counter++;
    <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">" is loaded"</span>);
  } <span class="hljs-keyword">else</span> {
    setTimeout(singleQuery, queryInterval, i);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allQuery</span>(<span class="hljs-params">callback</span>)</span>{
  <span class="hljs-keyword">if</span>(counter &lt; pics.length){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"current number of loaded pics: "</span> + counter);
    setTimeout(allQuery, queryInterval, callback);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"All pics are loaded."</span>);
    callback();
  }
}

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pics.length; i++){
  setTimeout(singleQuery, queryInterval, i);
}

setTimeout(allQuery, queryInterval, callback);
</code></pre>
<p>主要也是采用setTimeout模拟轮询，判断方式是img标签dom的complete属性（布尔值），缺点是定时器太多。</p>
<p>方法2：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var counter = 0, queryInterval = 50;
var pics = document.getElementsByClassName(&quot;pics&quot;);
for(var i = 0; i < pics.length; i++){
  pics[i].onload = function(){
    counter++;
    console.log(this.id + &quot; is loaded&quot;);
  }
}

function queryPictures(callback){
  if(counter < pics.length){
    console.log(&quot;current number of loaded pics: &quot; + counter);
    setTimeout(queryPictures, queryInterval, callback);
  } else {
    console.log(&quot;All pics are loaded&quot;);
    callback();
  }
}

setTimeout(queryPictures, queryInterval, callback);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>, queryInterval = <span class="hljs-number">50</span>;
<span class="hljs-keyword">var</span> pics = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">"pics"</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pics.length; i++){
  pics[i].onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    counter++;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.id + <span class="hljs-string">" is loaded"</span>);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryPictures</span>(<span class="hljs-params">callback</span>)</span>{
  <span class="hljs-keyword">if</span>(counter &lt; pics.length){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"current number of loaded pics: "</span> + counter);
    setTimeout(queryPictures, queryInterval, callback);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"All pics are loaded"</span>);
    callback();
  }
}

setTimeout(queryPictures, queryInterval, callback);</code></pre>
<p>利用onload绑定图片加载成功后的回调，通过计数器判断是否加载完毕。</p>
<h3 id="articleHeader62">CSS margin重叠问题</h3>
<p>块元素在垂直方向上的margin是很奇怪的，会有重叠现象。<br>如果display都是block，有三种情况：<br>外间距均为正数，竖直方向上会选择最大的外边距作为间隔<br>一正一负，间距 = 正 - |负|<br>两个负，间距 = 0 - 绝对值最大的那个<br>设置display: inline-block的盒子不会有margin重叠，position: absolute的也不会出现。</p>
<h3 id="articleHeader63">CSS选择器优先级 &amp;&amp; CSS选择器效率</h3>
<p>ID &gt; 类 &gt; 标签 &gt; 相邻 &gt; 子选择器 &gt; 后代选择器 &gt; * &gt; 属性 &gt; 伪类</p>
<h3 id="articleHeader64">object.propertyIsEnumerable(xxx)</h3>
<p>判断对象中是否有xxx属性，并且能通过for in枚举，如Array对象的length是不可枚举的</p>
<h3 id="articleHeader65">判断数组</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function isArray(arr){
    return Object.prototype.toString.call(arr) === '[Object Array]';
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs ada"><code><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(arr){
    <span class="hljs-keyword">return</span> <span class="hljs-type">Object.prototype.toString.call(arr)</span> === '[Object <span class="hljs-keyword">Array</span>]';
}
</code></pre>
<h3 id="articleHeader66">git fetch &amp;&amp; git pull</h3>
<p>git pull自动完成了fetch最新远程版本，并且和本地进行merge<br>git fetch获得远程分支，要继续手动merge合并</p>
<h3 id="articleHeader67">WebSocket</h3>
<p>HTML5带来的新协议，通过类似HTTP的请求建立连接。主要目的是可以获取服务端的推送。<br>原来的方式可能是使用long poll（即不中断连接一直等待数据），或者是ajax轮询的方式（每隔一段时间发送请求，建立连接，询问是否有新的数据）。这两种方式的缺点在于long poll的阻塞，以及ajax轮询的冗余连接。<br>WebSocket的设计思想有点类似于回调，在发送请求升级服务端的协议并收到确认信息后，服务端一有新的信息/数据就会主动推送给客户端，至于要一次HTTP握手便可以建立持久连接</p>
<h3 id="articleHeader68">跨域相关</h3>
<p>只要协议、域名、端口有不同，则视为不同的域。（域名和域名对应的IP也是跨域）</p>
<h4>1.CORS: Cross-Origin Resource Sharing</h4>
<p>基于服务器支持的跨域，服务器设置Access-Control-Allow-Origin响应头，浏览器可允许跨域</p>
<h4>2.设置domain</h4>
<p>能从子域设到主域，如a.b.c.com—&gt;b.c.com—&gt;c.com<br>具体情况：在页面中用iframe打开了另一个页面（前提：两个页面主域是相同的）<br>利用frameElement.contentWindow.document.domain设置frame子页面的主域，document.domain设置主页面的主域，之后就能互相获取dom中的数据。<br>缺点是只能用于不同子域间的交互。</p>
<h4>3.例如拥有src属性的img标签，每次改变src属性，都会发起http请求。</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var img = new Image();
img.onload = function(){
  //code here
};
img.onerror = function(){
  //code here
};
img.src=&quot;http://server.com/data?query=3&quot;;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();
img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  <span class="hljs-comment">//code here</span>
};
img.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  <span class="hljs-comment">//code here</span>
};
img.src=<span class="hljs-string">"http://server.com/data?query=3"</span>;</code></pre>
<p>缺点是只能使用GET请求，不能获取数据，一般用于提交统计信息什么的。<br>script、link、iframe只有在添加到DOM中才会发起请求</p>
<h4>4.HTML5 postMessage</h4>
<p>支持IE8+和主流浏览器，写法也简单..</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//source: http://test.org:4000
//get the window object of target origin
var win = window.open(&quot;http://target.com&quot;);
//or this, when a frame is used
var win = document.getElementById(&quot;targetId&quot;).contentWindow;
win.postMessage(&quot;data here&quot;, &quot;http://target.com/rest&quot;);

//target: http://target.com/tiny
function handleMessage(event){
  if(event.orgin!=&quot;http://test.org:4000&quot;)
    return;
  var data = event.data;
  //code here

  //event.source is window.opener
  event.source.postMessage(&quot;response data here&quot;, event.origin);
}
window.addEventListener(&quot;message&quot;, handleMessage, false);" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs cs"><code><span class="hljs-comment">//source: http://test.org:4000</span>
<span class="hljs-comment">//get the window object of target origin</span>
<span class="hljs-keyword">var</span> win = window.open(<span class="hljs-string">"http://target.com"</span>);
<span class="hljs-comment">//or this, when a frame is used</span>
<span class="hljs-keyword">var</span> win = document.getElementById(<span class="hljs-string">"targetId"</span>).contentWindow;
win.postMessage(<span class="hljs-string">"data here"</span>, <span class="hljs-string">"http://target.com/rest"</span>);

<span class="hljs-comment">//target: http://target.com/tiny</span>
<span class="hljs-function">function <span class="hljs-title">handleMessage</span>(<span class="hljs-params"><span class="hljs-keyword">event</span></span>)</span>{
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">event</span>.orgin!=<span class="hljs-string">"http://test.org:4000"</span>)
    <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">event</span>.data;
  <span class="hljs-comment">//code here</span>

  <span class="hljs-comment">//event.source is window.opener</span>
  <span class="hljs-keyword">event</span>.source.postMessage(<span class="hljs-string">"response data here"</span>, <span class="hljs-keyword">event</span>.origin);
}
window.addEventListener(<span class="hljs-string">"message"</span>, handleMessage, <span class="hljs-literal">false</span>);</code></pre>
<h4>5.window.name</h4>
<p>即使在页面打开多层iframe后，每个iframe中window.name 属性值都是相同的，以此用作数据传输的工具。<br>但由于跨域的限制，是无法获取另一个frame中的window.name数据，所以要使用一个同域的代理(proxy.html)：</p>
<h4>6. jsonp</h4>
<p>目前主流跨域方法<br>调用其他域的脚本获取数据，前提是另一个域能知道回调函数名，这个可以通过请求发送给目标域。<br>直接写jQuery封的jsonp</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="$.getJSON(&quot;http://target.com/data?callback=callbackFunctionName&quot;, function(data){});" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code style="word-break: break-word; white-space: initial;">$.getJSON(<span class="hljs-string">"http://target.com/data?callback=callbackFunctionName"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{});</code></pre>
<p>$.getJSON会把获取的responseText转为json，如果url中有callback参数，数据会以script标签形式获取。</p>
<h3 id="articleHeader69">闭包相关</h3>
<h4>什么是闭包</h4>
<blockquote>闭包是指有权访问另一个函数作用域中变量的函数</blockquote>
<h4>怎么创建闭包</h4>
<blockquote>在函数内部嵌套使用函数</blockquote>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function fn() {
           for (var i = 0; i < 2; i++) {
               (function () {
                   var variate = i;
                   setTimeout(function () {
                       console.log(&quot;setTimeout执行后:&quot;+variate);
                   }, 1000);
               })();//闭包,立即执行函数,匿名函数
                            
           }
          console.log(i);//2
          console.log(variate);//variate is not defined
       }
       fn();
       " title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) {
               (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                   <span class="hljs-keyword">var</span> variate = i;
                   setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"setTimeout执行后:"</span>+variate);
                   }, <span class="hljs-number">1000</span>);
               })();<span class="hljs-comment">//闭包,立即执行函数,匿名函数</span>
                            
           }
          <span class="hljs-built_in">console</span>.log(i);<span class="hljs-comment">//2</span>
          <span class="hljs-built_in">console</span>.log(variate);<span class="hljs-comment">//variate is not defined</span>
       }
       fn();
       </code></pre>
<h4>为什么用闭包</h4>
<ul>
<li>因为在闭包内部保持了对外部活动对象的访问,但外部的变量却无法直接访问内部,避免了全局污染;</li>
<li>可以当做私有成员,弥补了因js语法带来的面向对象编程的不足;</li>
<li>可以长久的在内存中保存一个自己想要保存的变量.</li>
</ul>
<h4>闭包的缺点</h4>
<ul>
<li>可能导致内存占用过多,因为闭包携带了自身的函数作用域</li>
<li>闭包只能取得外部包含函数中得最后一个值</li>
</ul>
<p>详见<a href="https://segmentfault.com/a/1190000014540734?utm_source=channel-hottest">https://segmentfault.com/a/11...</a></p>
<h3 id="articleHeader70">a:active 移动端实现</h3>
<p>有时候一些按钮的简单点击交互可以通过css伪类来实现；必须点击了更改颜色；松开恢复；IOS手机会出现伪类无效的情况；iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="document.body.addEventListener('touchstart', function () { //...空函数即可}); " title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code style="word-break: break-word; white-space: initial;"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">'touchstart'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">//...空函数即可}); </span></code></pre>
<h3 id="articleHeader71">ios滑动卡顿</h3>
<p>-webkit-overflow-scrolling:touch  可能会在IOS系统低的情况出现滚动条；尝试溢出解决</p>
<h3 id="articleHeader72">forEach和map的区别</h3>
<p>相同点</p>
<ul>
<li>都是循环遍历数组中的每一项</li>
<li>forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）</li>
<li>匿名函数中的this都是指向window</li>
<li>只能遍历数组</li>
<li>都有兼容问题</li>
</ul>
<p>不同点</p>
<ul>
<li>map速度比foreach快</li>
<li>map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组，</li>
<li>map因为返回数组所以可以链式操作，foreach不能</li>
</ul>
<h3 id="articleHeader73">浅拷贝和深拷贝</h3>
<p>jQuery.extend第一个参数可以是布尔值，用来设置是否深度拷贝的</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="jQuery.extend(true, { a : { a : &quot;a&quot; } }, { a : { b : &quot;b&quot; } } );
jQuery.extend( { a : { a : &quot;a&quot; } }, { a : { b : &quot;b&quot; } } ); " title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-tag">jQuery</span><span class="hljs-selector-class">.extend</span>(<span class="hljs-selector-tag">true</span>, { <span class="hljs-attribute">a </span>: { a : <span class="hljs-string">"a"</span> } }, { <span class="hljs-attribute">a </span>: { b : <span class="hljs-string">"b"</span> } } );
<span class="hljs-selector-tag">jQuery</span><span class="hljs-selector-class">.extend</span>( { <span class="hljs-attribute">a </span>: { a : <span class="hljs-string">"a"</span> } }, { <span class="hljs-attribute">a </span>: { b : <span class="hljs-string">"b"</span> } } ); </code></pre>
<p>最简单的深拷贝</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="aa = JSON.parse( JSON.stringify(a) )" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs ini"><code style="word-break: break-word; white-space: initial;"><span class="hljs-attr">aa</span> = JSON.parse( JSON.stringify(a) )</code></pre>
<p>浅复制---&gt;就是将一个对象的内存地址的“”编号“”复制给另一个对象。深复制---&gt;实现原理，先新建一个空对象，内存中新开辟一块地址，把被复制对象的所有可枚举的(注意可枚举的对象)属性方法一一复制过来，注意要用递归来复制子对象里面的所有属性和方法，直到子子.....属性为基本数据类型。总结，深复制理解两点，1,新开辟内存地址，2,递归来刨根复制。</p>
<h3 id="articleHeader74">外边距合并</h3>
<blockquote>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。<br>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</blockquote>
<h3 id="articleHeader75">Js加载位置区别优缺点</h3>
<p>html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到&lt;script&gt;脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行。<br>所以，大部分网上讨论是将script脚本放在&lt;body&gt;之后，那样dom的生成就不会因为长时间执行script脚本而延迟阻塞，加快了页面的加载速度。</p>
<p>但又不能将所有的script放在body之后，因为有一些页面的效果的实现，是需要预先动态的加载一些js脚本。所以这些脚本应该放在&lt;body&gt;之前。</p>
<p>其次，不能将需要访问dom元素的js放在body之前，因为此时还没有开始生成dom，所以在body之前的访问dom元素的js会出错，或者无效</p>
<p><strong>script放置位置的原则“页面效果实现类的js应该放在body之前，动作，交互，事件驱动，需要访问dom属性的js都可以放在body之后”</strong></p>
<h1 id="articleHeader76">针对上方问题存在没有解答的 ; 或则解答不正确详细的 ; 欢迎留言 ; 我会及时更正 ; 也欢迎留下你认为经典的面试题 ; 我都会补充进来 ; 共同进步</h1>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
2017、2018面试分享（js面试题记录）记得点赞分享哦；让更多的人看到~~

## 原文链接
[https://segmentfault.com/a/1190000013827826](https://segmentfault.com/a/1190000013827826)

