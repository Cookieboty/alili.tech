---
title: 'Java高并发架构设计' 
date: 2019-02-13 2:31:22
hidden: true
slug: 7f52s3sx55
categories: [reprint]
---

{{< raw >}}

                    
<p><strong>序言</strong></p>
<p>高并发经常会发生在有大活跃用户量，用户高聚集的业务场景中，如：秒杀活动，定时领取红包等。</p>
<p>为了让业务可以流畅的运行并且给用户一个好的交互体验，我们需要根据业务场景预估达到的并发量等因素，来设计适合自己业务场景的高并发处理方案。</p>
<p>在电商相关产品开发的这些年，我有幸的遇到了并发下的各种坑，这一路摸爬滚打过来有着不少的血泪史，这里进行的总结，作为自己的归档记录，同时分享给大家。</p>
<h2 id="articleHeader0">一丶服务器架构</h2>
<p>业务从发展的初期到逐渐成熟，服务器架构也是从相对单一到集群，再到分布式服务。</p>
<p>一个可以支持高并发的服务少不了好的服务器架构，需要有均衡负载，数据库需要主从集群，nosql缓存需要主从集群，静态文件需要上传cdn，这些都是能让业务程序流畅运行的强大后盾。</p>
<p>服务器这块多是需要运维人员来配合搭建，具体我就不多说了，点到为止。</p>
<p><strong>大致需要用到的服务器架构如下：</strong></p>
<p>服务器</p>
<p>均衡负载(如：nginx，阿里云SLB)</p>
<p>资源监控</p>
<p>分布式</p>
<p>数据库</p>
<p>主从分离，集群</p>
<p>DBA 表优化，索引优化，等</p>
<p>分布式</p>
<p>nosql</p>
<p>主从分离，集群</p>
<p>主从分离，集群</p>
<p>主从分离，集群</p>
<p>redis</p>
<p>mongodb</p>
<p>memcache</p>
<p>cdn</p>
<p>html</p>
<p>css</p>
<p>js</p>
<p>image</p>
<p><strong>并发测试</strong></p>
<p>高并发相关的业务，需要进行并发的测试，通过大量的数据分析评估出整个架构可以支撑的并发量。</p>
<p>测试高并发可以使用第三方服务器或者自己测试服务器，利用测试工具进行并发请求测试，分析测试数据得到可以支撑并发数量的评估，这个可以作为一个预警参考，俗话说知己自彼百战不殆。</p>
<p>第三方服务:</p>
<p>阿里云性能测试</p>
<p>并发测试工具：</p>
<p>Apache JMeter</p>
<p>Visual Studio性能负载测试</p>
<p>Microsoft Web Application Stress Tool</p>
<p>实战方案</p>
<p>通用方案</p>
<p>日用户流量大，但是比较分散，偶尔会有用户高聚的情况;</p>
<p>场景： 用户签到，用户中心，用户订单，等</p>
<p><strong>服务器架构图：</strong></p>
<p><span class="img-wrap"><img data-src="/img/bVbiq0k?w=720&amp;h=212" src="https://static.alili.tech/img/bVbiq0k?w=720&amp;h=212" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p><strong>说明：</strong></p>
<p>场景中的这些业务基本是用户进入APP后会操作到的，除了活动日(618,双11，等)，这些业务的用户量都不会高聚集，同时这些业务相关的表都是大数据表，业务多是查询操作，所以我们需要减少用户直接命中DB的查询;优先查询缓存，如果缓存不存在，再进行DB查询，将查询结果缓存起来。</p>
<p>更新用户相关缓存需要分布式存储，比如使用用户ID进行hash分组，把用户分布到不同的缓存中，这样一个缓存集合的总量不会很大，不会影响查询效率。</p>
<p><strong>方案如：</strong></p>
<p>用户签到获取积分</p>
<p>计算出用户分布的key,redis hash中查找用户今日签到信息</p>
<p>如果查询到签到信息，返回签到信息</p>
<p>如果没有查询到，DB查询今日是否签到过，如果有签到过，就把签到信息同步redis缓存。</p>
<p>如果DB中也没有查询到今日的签到记录，就进行签到逻辑，操作DB添加今日签到记录，添加签到积分(这整个DB操作是一个事务)</p>
<p>缓存签到信息到redis，返回签到信息</p>
<p>注意</p>
<p>这里会有并发情况下的逻辑问题，如：一天签到多次，发放多次积分给用户。</p>
<p>我的博文[大话程序猿眼里的高并发]有相关的处理方案。</p>
<p><strong>用户订单</strong></p>
<p>这里我们只缓存用户第一页的订单信息，一页40条数据，用户一般也只会看第一页的订单数据</p>
<p>用户访问订单列表，如果是第一页读缓存，如果不是读DB</p>
<p>计算出用户分布的key,redis hash中查找用户订单信息</p>
<p>如果查询到用户订单信息，返回订单信息</p>
<p>如果不存在就进行DB查询第一页的订单数据，然后缓存redis，返回订单信息</p>
<p><strong>用户中心</strong></p>
<p>计算出用户分布的key,redis hash中查找用户订单信息</p>
<p>如果查询到用户信息，返回用户信息</p>
<p>如果不存在进行用户DB查询，然后缓存redis，返回用户信息</p>
<p><strong>其他业务</strong></p>
<p>以上例子是一个相对简单的高并发架构，并发量不是很高的情况可以很好的支撑，但是随着业务的壮大，用户并发量增加，我们的架构也会进行不断的优化和演变，比如对业务进行服务化，每个服务有自己的并发架构，自己的均衡服务器，分布式数据库，nosql主从集群，如：用户服务、订单服务;</p>
<p><strong>消息队列</strong></p>
<p>秒杀、秒抢等活动业务，用户在瞬间涌入产生高并发请求</p>
<p>场景：定时领取红包，等</p>
<p>服务器架构图：</p>
<p><span class="img-wrap"><img data-src="/img/bVbiq0k?w=720&amp;h=212" src="https://static.alili.tech/img/bVbiq0k?w=720&amp;h=212" alt="clipboard.png" title="clipboard.png" style="cursor: pointer; display: inline;"></span></p>
<p><strong>说明：</strong></p>
<p>场景中的定时领取是一个高并发的业务，像秒杀活动用户会在到点的时间涌入，DB瞬间就接受到一记暴击，hold不住就会宕机，然后影响整个业务;</p>
<p>像这种不是只有查询的操作并且会有高并发的插入或者更新数据的业务，前面提到的通用方案就无法支撑，并发的时候都是直接命中DB;</p>
<p>设计这块业务的时候就会使用消息队列的，可以将参与用户的信息添加到消息队列中，然后再写个多线程程序去消耗队列，给队列中的用户发放红包;</p>
<p><strong>方案如：</strong></p>
<p>定时领取红包</p>
<p>一般习惯使用 redis的 list</p>
<p>当用户参与活动，将用户参与信息push到队列中</p>
<p>然后写个多线程程序去pop数据，进行发放红包的业务</p>
<p>这样可以支持高并发下的用户可以正常的参与活动，并且避免数据库服务器宕 机的危险</p>
<p><strong>一级缓存</strong></p>
<p>高并发请求连接缓存服务器超出服务器能够接收的请求连接量，部分用户出现建立连接超时无法读取到数据的问题;</p>
<p>因此需要有个方案当高并发时候时候可以减少命中缓存服务器;</p>
<p>这时候就出现了一级缓存的方案，一级缓存就是使用站点服务器缓存去存储数据，注意只存储部分请求量大的数据，并且缓存的数据量要控制，不能过分的使用站点服务器的内存而影响了站点应用程序的正常运行，一级缓存需要设置秒单位的过期时间，具体时间根据业务场景设定，目的是当有高并发请求的时候可以让数据的获取命中到一级缓存，而不用连接缓存nosql数据服务器，减少nosql数据服务器的压力</p>
<p>比如APP首屏商品数据接口，这些数据是公共的不会针对用户自定义，而且这些数据不会频繁的更新，像这种接口的请求量比较大就可以加入一级缓存;</p>
<p><strong>服务器架构图：</strong></p>
<p><span class="img-wrap"><img data-src="/img/bVbiq0x?w=720&amp;h=183" src="https://static.alili.tech/img/bVbiq0x?w=720&amp;h=183" alt="clipboard.png" title="clipboard.png" style="cursor: pointer; display: inline;"></span></p>
<p>合理的规范和使用nosql缓存数据库，根据业务拆分缓存数据库的集群，这样基本可以很好支持业务，一级缓存毕竟是使用站点服务器缓存所以还是要善用。</p>
<p><strong>静态化数据</strong></p>
<p>高并发请求数据不变化的情况下如果可以不请求自己的服务器获取数据那就可以减少服务器的资源压力。</p>
<p>对于更新频繁度不高，并且数据允许短时间内的延迟，可以通过数据静态化成JSON，XML,HTML等数据文件上传CDN，在拉取数据的时候优先到CDN拉取，如果没有获取到数据再从缓存，数据库中获取，当管理人员操作后台编辑数据再重新生成静态文件上传同步到CDN，这样在高并发的时候可以使数据的获取命中在CDN服务器上。CDN节点同步有一定的延迟性，所以找一个靠谱的CDN服务器商也很重要。</p>
<p><span class="img-wrap"><img data-src="/img/bVbiq0y?w=418&amp;h=47" src="https://static.alili.tech/img/bVbiq0y?w=418&amp;h=47" alt="clipboard.png" title="clipboard.png" style="cursor: pointer; display: inline;"></span></p>
<p>因资料太多，请加架构资源QQ群：897889510 领取免费的学习资源！里面会分享资深架构师录制的视频录像（有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化、分布式架构）更多分享Java高级资料视频等你来!</p>
<p>希望大家能成为一名更优秀的Java程序员,走向架构师的人生巅峰!</p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
Java高并发架构设计

## 原文链接
[https://segmentfault.com/a/1190000016747734](https://segmentfault.com/a/1190000016747734)

