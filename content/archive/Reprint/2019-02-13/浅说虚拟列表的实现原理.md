---
title: '浅说虚拟列表的实现原理' 
date: 2019-02-13 2:31:22
hidden: true
slug: mczzajylm8g
categories: [reprint]
---

{{< raw >}}

                    
<p>在 <a href="https://github.com/dwqs/blog/issues/63" rel="nofollow noreferrer" target="_blank">列表数据的展示优化</a> 一文中，提到了对于列表形态的数据展示的按需渲染。这种方式是指根据容器元素的高度以及列表项元素的高度来显示长列表数据中的某一个部分，而不是去完整地渲染长列表，以提高无限滚动的性能。而按需显示方案的实现就是本文标题中说的虚拟列表。</p>
<blockquote>虚拟列表的实现有多种方案，本文以 <a href="https://github.com/dwqs/react-virtual-list" rel="nofollow noreferrer" target="_blank">react-virtual-list</a> 组件为基础进行分析。原文链接：<a href="https://github.com/dwqs/blog/issues/70" rel="nofollow noreferrer" target="_blank">https://github.com/dwqs/blog/...</a>
</blockquote>
<h2 id="articleHeader0">什么是虚拟列表？</h2>
<p>在正文之前，先对虚拟列表做个简单的定义。</p>
<p>根据上文，虚拟列表是按需显示思路的一种实现，即<strong>虚拟列表是一种根据滚动容器元素的可视区域来渲染长列表数据中某一个部分数据的技术。</strong></p>
<p>简而言之，虚拟列表指的就是「可视区域渲染」的列表。有三个概念需要了解一下：</p>
<ul>
<li>
<strong>滚动容器元素</strong>：一般情况下，滚动容器元素是 <code>window</code> 对象。然而，我们可以通过布局的方式，在某个页面中任意指定一个或者多个滚动容器元素。只要某个元素能在内部产生横向或者纵向的滚动，那这个元素就是滚动容器元素考虑每个列表项只是渲染一些纯文本。在本文中，只讨论元素的纵向滚动。</li>
<li>
<strong>可滚动区域</strong>：滚动容器元素的内部内容区域。假设有 100 条数据，每个列表项的高度是 50，那么可滚动的区域的高度就是 100 * 50。可滚动区域当前的具体高度值一般可以通过(滚动容器)元素的 <code>scrollHeight</code> 属性获取。用户可以通过滚动来改变列表在可视区域的显示部分。</li>
<li>
<strong>可视区域</strong>：滚动容器元素的视觉可见区域。如果容器元素是 <code>window</code> 对象，可视区域就是浏览器的视口大小(即<a href="https://user-images.githubusercontent.com/7871813/43363609-26e0d164-933b-11e8-85e5-1ec21d5ba398.png" rel="nofollow noreferrer" target="_blank">视觉视口</a>)；如果容器元素是某个 <code>div</code> 元素，其高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可视区域。</li>
</ul>
<p>实现虚拟列表就是在处理用户滚动时，要改变列表在可视区域的渲染部分，其具体步骤如下：</p>
<ul>
<li>计算当前可见区域起始数据的 startIndex</li>
<li>计算当前可见区域结束数据的 endIndex</li>
<li>计算当前可见区域的数据，并渲染到页面中</li>
<li>计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上</li>
<li>计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到列表上</li>
</ul>
<p>建议参考下图理解一下上面的步骤：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000016734600?w=549&amp;h=609" src="https://static.alili.tech/img/remote/1460000016734600?w=549&amp;h=609" alt="步骤图" title="步骤图" style="cursor: pointer;"></span></p>
<blockquote>元素 L 代指当前列表中的最后一个元素</blockquote>
<p>从上图可以看出，<code>startOffset</code> 和 <code>endOffset</code> 会撑开容器元素的内容高度，让其可持续的滚动；此外，还能保持滚动条处于一个正确的位置。</p>
<h2 id="articleHeader1">为什么需要虚拟列表？</h2>
<p>虚拟列表是对长列表的一种优化方案。在前端开发中，会碰到一些不能使用分页方式来加载列表数据的业务形态，我们称这种列表叫做长列表。比如，在一些外汇交易系统中，前端会准实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。</p>
<p>在本篇文章中，我们把长列表定义成数据长度大于 999，并且不能使用分页的形式来展示的列表。</p>
<p>如果对长列表不作优化，完整地渲染一个长列表，到底需要多长时间呢？接下来会写一个简单的 demo 来测试以下。</p>
<blockquote>本文 demo 的测试环境：Macbook Pro(Core i7 2.2G, 16G), Chrome 69，React 16.4.1</blockquote>
<p>在 demo 中，我们先测一下浏览器渲染 10000 个简单的节点需要多长时间：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="import React from 'react'

const count = 10000

function createMarkup (doms) {
  return doms.length ? { __html: doms.join(' ') } : { __html: '' }
}

export default class DOM extends React.Component {
  constructor (props) {
    super(props)
    this.state = {
      simpleDOMs: []
    }

    this.onCreateSimpleDOMs = this.onCreateSimpleDOMs.bind(this)
  }

  onCreateSimpleDOMs () {
    const array = []

    for (var i = 0; i < count; i++) {
      array.push('<div>' + i + '</div>')
    }

    this.setState({
      simpleDOMs: array
    })
  }

  render () {
    return (
      <div style="{{" marginLeft: '10px' "}}">
        <h3>Creat large of DOMs：</h3>
        <button onClick={this.onCreateSimpleDOMs}>Create Simple DOMs</button>
        <div dangerouslySetInnerHTML={createMarkup(this.state.simpleDOMs)} />
      </div>
    )
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">const</span> count = <span class="hljs-number">10000</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMarkup</span> (<span class="hljs-params">doms</span>) </span>{
  <span class="hljs-keyword">return</span> doms.length ? { <span class="hljs-attr">__html</span>: doms.join(<span class="hljs-string">' '</span>) } : { <span class="hljs-attr">__html</span>: <span class="hljs-string">''</span> }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DOM</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span> (props) {
    <span class="hljs-keyword">super</span>(props)
    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">simpleDOMs</span>: []
    }

    <span class="hljs-keyword">this</span>.onCreateSimpleDOMs = <span class="hljs-keyword">this</span>.onCreateSimpleDOMs.bind(<span class="hljs-keyword">this</span>)
  }

  onCreateSimpleDOMs () {
    <span class="hljs-keyword">const</span> array = []

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
      array.push(<span class="hljs-string">'&lt;div&gt;'</span> + i + <span class="hljs-string">'&lt;/div&gt;'</span>)
    }

    <span class="hljs-keyword">this</span>.setState({
      <span class="hljs-attr">simpleDOMs</span>: array
    })
  }

  render () {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"{{"</span> <span class="hljs-attr">marginLeft:</span> '<span class="hljs-attr">10px</span>' "}}"&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Creat large of DOMs：<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.onCreateSimpleDOMs}</span>&gt;</span>Create Simple DOMs<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{createMarkup(this.state.simpleDOMs)}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    )
  }
}</span></code></pre>
<p>当点击 Button 时，会调用 <code>onCreateSimpleDOMs</code> 创建 10000 个简单节点。从 Chrome 的 Performance 标签页看到的数据如下：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000016734601?w=1406&amp;h=608" src="https://static.alili.tech/img/remote/1460000016734601?w=1406&amp;h=608" alt="simple doms" title="simple doms" style="cursor: pointer; display: inline;"></span></p>
<p>从上图可以看到，从 Event Click 到 Paint，总共用了大约 693ms，渲染时的主要时间消耗情况如下：</p>
<ul>
<li>Recalculate Style：40.80ms</li>
<li>Layout：518.55ms</li>
<li>Update Layer Tree：11.84ms</li>
</ul>
<blockquote>在 Recalculate Style 和 Layout 阶段，ReactDOM 调用了 <code>setInnerHTML</code> 方法，其内部主要通过 <code>innerHTML</code> 方法，将创建好的 html 片段添加到对应节点</blockquote>
<p>然后，我们创建 10000 个稍微复杂点的节点。修改组件如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="import React from 'react'

function createMarkup (doms) {
  return doms.length ? { __html: doms.join(' ') } : { __html: '' }
}

export default class DOM extends React.Component {
  constructor (props) {
    super(props)
    this.state = {
      complexDOMs: []
    }

    this.onCreateComplexDOMs = this.onCreateComplexDOMs.bind(this)
  }

  onCreateComplexDOMs () {
    const array = []
    for (var i = 0; i < 5000; i++) {
      array.push(`
        <div class='list-item'>
          <p>#${i} eligendi voluptatem quisquam</p>
          <p>Modi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.</p>
        </div>
      `)
    }

    this.setState({
      complexDOMs: array
    })
  }

  render () {
    return (
      <div style="{{" marginLeft: '10px' "}}">
        <h3>Creat large of DOMs：</h3>
        <button onClick={this.onCreateComplexDOMs}>Create Complex DOMs</button>
        <div dangerouslySetInnerHTML={createMarkup(this.state.complexDOMs)} />
      </div>
    )
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMarkup</span> (<span class="hljs-params">doms</span>) </span>{
  <span class="hljs-keyword">return</span> doms.length ? { <span class="hljs-attr">__html</span>: doms.join(<span class="hljs-string">' '</span>) } : { <span class="hljs-attr">__html</span>: <span class="hljs-string">''</span> }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DOM</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span> (props) {
    <span class="hljs-keyword">super</span>(props)
    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">complexDOMs</span>: []
    }

    <span class="hljs-keyword">this</span>.onCreateComplexDOMs = <span class="hljs-keyword">this</span>.onCreateComplexDOMs.bind(<span class="hljs-keyword">this</span>)
  }

  onCreateComplexDOMs () {
    <span class="hljs-keyword">const</span> array = []
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) {
      array.push(<span class="hljs-string">`
        &lt;div class='list-item'&gt;
          &lt;p&gt;#<span class="hljs-subst">${i}</span> eligendi voluptatem quisquam&lt;/p&gt;
          &lt;p&gt;Modi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.&lt;/p&gt;
        &lt;/div&gt;
      `</span>)
    }

    <span class="hljs-keyword">this</span>.setState({
      <span class="hljs-attr">complexDOMs</span>: array
    })
  }

  render () {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"{{"</span> <span class="hljs-attr">marginLeft:</span> '<span class="hljs-attr">10px</span>' "}}"&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Creat large of DOMs：<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.onCreateComplexDOMs}</span>&gt;</span>Create Complex DOMs<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{createMarkup(this.state.complexDOMs)}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    )
  }
}</span></code></pre>
<p>当点击 Button 时，会调用 <code>onCreateComplexDOMs</code>。从 Chrome 的 Performance 标签页看到的数据如下：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000016734602" src="https://static.alili.tech/img/remote/1460000016734602" alt="complex doms" title="complex doms" style="cursor: pointer;"></span></p>
<p>从上图可以看到，从 Event Click 到 Paint，总共用了大约 964.2ms，渲染时的主要时间消耗情况如下：</p>
<ul>
<li>Recalculate Style：117.07ms</li>
<li>Layout：538.00ms</li>
<li>Update Layer Tree：31.15ms</li>
</ul>
<p>对于上述测试各进行 5 次，然后取各指标的平均值，统计结果如下：</p>
<table>
<thead><tr>
<th align="center">-</th>
<th align="center">Recalculate Style</th>
<th align="center">Layout</th>
<th align="center">Update Layer Tree</th>
<th align="center">Total</th>
</tr></thead>
<tbody>
<tr>
<td align="center">渲染简单节点</td>
<td align="center">199.66ms</td>
<td align="center">523.72ms</td>
<td align="center">12.572ms</td>
<td align="center">735.952ms</td>
</tr>
<tr>
<td align="center">渲染复杂节点</td>
<td align="center">114.684ms</td>
<td align="center">806.05ms</td>
<td align="center">31.328ms</td>
<td align="center">952.512ms</td>
</tr>
</tbody>
</table>
<blockquote><ol>
<li>Total = Recalculate Style + Layout + Update Layer Tree</li>
<li>demo 的测试代码：<a href="https://github.com/dwqs/react-demos/tree/master/src/general/dom" rel="nofollow noreferrer" target="_blank">test code</a>
</li>
</ol></blockquote>
<p>从上面的测试结果中可以看到，渲染 10000 个节点就需要 700ms+，实际业务中的列表每个节点都需要 20 个左右的节点，布局也会复杂很多，在 Recalculate Style 和 Layout 阶段也会耗费更长的时间。那么，700ms 也仅能渲染 300 ~ 500 个左右的列表项，所以完整的长列表渲染基本上很难达到业务上的要求的。而非完整的长列表渲染一般有两种方式：按需渲染和延迟渲染(即懒渲染)。常见的无限滚动便是延迟渲染的一种实现，而虚拟列表则是按需渲染的一种实现。</p>
<p>延迟渲染不在本文讨论范围。接下来，本文会简单介绍虚拟列表的一种实现方案。</p>
<h2 id="articleHeader2">实现</h2>
<p>本章节将会创建一个 <code>VirtualizedList</code> 组件，并结合代码，慢慢梳理虚拟列表的实现。</p>
<p>为了简化，我们设定 <code>window</code> 为滚动容器元素，给 <code>html</code> 和 <code>body</code> 元素均添加样式规则 <code>height: 100%</code>，设定可视区域为浏览器的窗口大小。<code>VirtualizedList</code> 在 DOM 元素的布局上将参考<a href="https://mobile.twitter.com/home" rel="nofollow noreferrer" target="_blank">Twitter 的移动端</a>：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="class VirtualizedList extends Component {
  constructor (props) {
    super(props)
    
    this.state = {
      startOffset: 0,
      endOffset: 0,
      visibleData: []
    }
    
    this.data = new Array(1000).fill(true)
    this.startIndex = 0
    this.endIndex = 0
    this.scrollTop = 0
  }
  
  render () {
    const {startOffset, endOffset} = this.state
    
    return (
      <div className='wrapper'>
        <div style="{{" paddingTop: `${startOffset}px`, paddingBottom: `${endOffset}px` "}}">
          {
            // render list
          }
        </div>
      </div>
    )
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualizedList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span> (props) {
    <span class="hljs-keyword">super</span>(props)
    
    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">startOffset</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">endOffset</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">visibleData</span>: []
    }
    
    <span class="hljs-keyword">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>).fill(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">this</span>.startIndex = <span class="hljs-number">0</span>
    <span class="hljs-keyword">this</span>.endIndex = <span class="hljs-number">0</span>
    <span class="hljs-keyword">this</span>.scrollTop = <span class="hljs-number">0</span>
  }
  
  render () {
    <span class="hljs-keyword">const</span> {startOffset, endOffset} = <span class="hljs-keyword">this</span>.state
    
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'wrapper'</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"{{"</span> <span class="hljs-attr">paddingTop:</span> `${<span class="hljs-attr">startOffset</span>}<span class="hljs-attr">px</span>`, <span class="hljs-attr">paddingBottom:</span> `${<span class="hljs-attr">endOffset</span>}<span class="hljs-attr">px</span>` "}}"&gt;</span>
          {
            // render list
          }
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}</code></pre>
<p>在虚拟列表上的实现上，也分为两种情形：列表项是固定高度的和列表项是动态高度的。</p>
<h3 id="articleHeader3">列表项是固定高度的</h3>
<p>既然列表项是固定高度的，那约定没个列表项的高度为 60，列表数据的长度为 1000。</p>
<p>首先，我们根据可视区域的高度估算可视区域能渲染的元素个数：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const height = 60
const bufferSize = 5
// ...

this.visibleCount = Math.ceil(window.clientHeight / height)" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-keyword">const</span> height = <span class="hljs-number">60</span>
<span class="hljs-keyword">const</span> bufferSize = <span class="hljs-number">5</span>
<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">this</span>.visibleCount = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">window</span>.clientHeight / height)</code></pre>
<p>然后，计算 <code>startIndex</code> 和 <code>endIndex</code>，并先初始化初次需要渲染的数据：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// ...

updateVisibleData (scrollTop) {
  const visibleData = this.data.slice(this.startIndex, this.endIndex)
  const endOffset = (this.data.length - this.endIndex) * height
    
  this.setState({
    startOffset: 0,
    endOffset,
    visibleData
  })
}

componentDidMount () {
  // 计算可渲染的元素个数
  this.visibleCount = Math.ceil(window.innerHeight / height) + bufferSize
  this.endIndex = this.startIndex + this.visibleCount
  this.updateVisibleData()
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-comment">// ...</span>

updateVisibleData (scrollTop) {
  <span class="hljs-keyword">const</span> visibleData = <span class="hljs-keyword">this</span>.data.slice(<span class="hljs-keyword">this</span>.startIndex, <span class="hljs-keyword">this</span>.endIndex)
  <span class="hljs-keyword">const</span> endOffset = (<span class="hljs-keyword">this</span>.data.length - <span class="hljs-keyword">this</span>.endIndex) * height
    
  <span class="hljs-keyword">this</span>.setState({
    <span class="hljs-attr">startOffset</span>: <span class="hljs-number">0</span>,
    endOffset,
    visibleData
  })
}

componentDidMount () {
  <span class="hljs-comment">// 计算可渲染的元素个数</span>
  <span class="hljs-keyword">this</span>.visibleCount = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">window</span>.innerHeight / height) + bufferSize
  <span class="hljs-keyword">this</span>.endIndex = <span class="hljs-keyword">this</span>.startIndex + <span class="hljs-keyword">this</span>.visibleCount
  <span class="hljs-keyword">this</span>.updateVisibleData()
}</code></pre>
<p>如上文所说，<code>endOffset</code> 是计算 <code>endIndex</code> 对应的数据相对于可滚动区域底部的偏移位置。在本 demo 中，可滚动区域的高度就是 1000 <em> 60，因而 <code>endIndex</code> 对应的数据相距底部的偏移就是 (1000 - endIndex) </em> 60。</p>
<p>由于是初始化初次需要渲染的数据，因而 <code>startOffset</code> 的初始值是 0。</p>
<p>根据上述代码，可以得知，要计算可见区域需要渲染的数据，只要计算出 <code>startIndex</code> 就行，因为 <code>visibleCount</code> 是一个定值，<code>bufferSize</code> 是一个缓冲值，用来增加一定的缓存区域，让正常滑动速度的时候不会显得那么突兀。而 <code>endIndex</code> 的值就等于 <code>startIndex</code> 加上 <code>visibleCount</code>；同时，当用户滚动改变可见区域的数据时，还需要计算 <code>startOffset</code> 的值，以保证新的数据会出现在用户浏览器的视口中：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000016734603" src="https://static.alili.tech/img/remote/1460000016734603" alt="startOffset" title="startOffset" style="cursor: pointer;"></span></p>
<p>如果不计算 <code>startOffset</code> 的值，那本应该渲染在可视区域内的元素会渲染到可视区域之外。从上图可以看到，<code>startOffset</code> 的值就是元素8的上边框 <strong>(可视区域内最上面一个元素)</strong> 到元素1的上边框的偏移量。元素8称为 <strong>锚点元素，即可视区域内的第一个元素。</strong> 因而，我们需要定义一个变量来缓存锚点元素的一些位置信息，同时也要缓存已渲染的元素的位置信息：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// ...
// 缓存已渲染元素的位置信息
this.cache = []
// 缓存锚点元素的位置信息
this.anchorItem = {
  index: 0, // 锚点元素的索引值
  top: 0, // 锚点元素的顶部距离第一个元素的顶部的偏移量(即 startOffset)
  bottom: 0 // 锚点元素的底部距离第一个元素的顶部的偏移量
}
// ...

cachePosition (node, index) {
  const rect = node.getBoundingClientRect()
  const top = rect.top + window.pageYOffset
  
  this.cache.push({
    index,
    top,
    bottom: top + height
  })
}

// ..." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-comment">// ...</span>
<span class="hljs-comment">// 缓存已渲染元素的位置信息</span>
<span class="hljs-keyword">this</span>.cache = []
<span class="hljs-comment">// 缓存锚点元素的位置信息</span>
<span class="hljs-keyword">this</span>.anchorItem = {
  <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 锚点元素的索引值</span>
  top: <span class="hljs-number">0</span>, <span class="hljs-comment">// 锚点元素的顶部距离第一个元素的顶部的偏移量(即 startOffset)</span>
  bottom: <span class="hljs-number">0</span> <span class="hljs-comment">// 锚点元素的底部距离第一个元素的顶部的偏移量</span>
}
<span class="hljs-comment">// ...</span>

cachePosition (node, index) {
  <span class="hljs-keyword">const</span> rect = node.getBoundingClientRect()
  <span class="hljs-keyword">const</span> top = rect.top + <span class="hljs-built_in">window</span>.pageYOffset
  
  <span class="hljs-keyword">this</span>.cache.push({
    index,
    top,
    <span class="hljs-attr">bottom</span>: top + height
  })
}

<span class="hljs-comment">// ...</span></code></pre>
<p>方法 <code>cachePosition</code> 会在每个列表项组件渲染完后(<code>componentDidMount</code>)进行调用，<code>node</code> 是对应的列表项节点元素，<code>index</code> 是节点的索引值：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// Item.jsx

// ...
componentDidMount () {
  this.props.cachePosition(this.node, this.props.index)
}

render () {
  /* eslint-disable-next-line */
  const {index} = this.props

  return (
    <div className='list-item' ref={node => { this.node = node "}}">
      <p>#${index} eligendi voluptatem quisquam</p>
      <p>Modi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.</p>
    </div>
  )
}
// ..." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-comment">// Item.jsx</span>

<span class="hljs-comment">// ...</span>
componentDidMount () {
  <span class="hljs-keyword">this</span>.props.cachePosition(<span class="hljs-keyword">this</span>.node, <span class="hljs-keyword">this</span>.props.index)
}

render () {
  <span class="hljs-comment">/* eslint-disable-next-line */</span>
  <span class="hljs-keyword">const</span> {index} = <span class="hljs-keyword">this</span>.props

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'list-item'</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{node</span> =&gt;</span> { this.node = node "}}"&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>#${index} eligendi voluptatem quisquam<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Modi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
<span class="hljs-comment">// ...</span></code></pre>
<p>缓存了锚点元素和已渲染元素的位置信息之后，接下来就可以处理用户的滚动行为了。以用户向下滚动(<code>scrollTop</code> 值增大的方向)为例：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// ...
// 计算 startIndex 和 endIndex
updateBoundaryIndex (scrollTop) {
  scrollTop = scrollTop || 0
  //用户正常滚动下，根据 scrollTop 找到新的锚点元素位置
  const anchorItem = this.cache.find(item => item.bottom >= scrollTop)

  this.anchorItem = {
    ...anchorItem
  }

  this.startIndex = this.anchorItem.index
  this.endIndex = this.startIndex + this.visibleCount
}

// 滚动事件处理函数
handleScroll (e) {
  if (!this.doc) {
    // 兼容 iOS Safari/Webview
    this.doc = window.document.body.scrollTop ? window.document.body : window.document.documentElement
  }

  const scrollTop = this.doc.scrollTop
  if (scrollTop > this.scrollTop) {
    if (scrollTop > this.anchorItem.bottom) {
      this.updateBoundaryIndex(scrollTop)
      this.updateVisibleData()
    }
  } else if (scrollTop < this.scrollTop) {
    // 向上滚动(`scrollTop` 值减小的方向)
  }

  this.scrollTop = scrollTop
}
// ..." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-comment">// ...</span>
<span class="hljs-comment">// 计算 startIndex 和 endIndex</span>
updateBoundaryIndex (scrollTop) {
  scrollTop = scrollTop || <span class="hljs-number">0</span>
  <span class="hljs-comment">//用户正常滚动下，根据 scrollTop 找到新的锚点元素位置</span>
  <span class="hljs-keyword">const</span> anchorItem = <span class="hljs-keyword">this</span>.cache.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.bottom &gt;= scrollTop)

  <span class="hljs-keyword">this</span>.anchorItem = {
    ...anchorItem
  }

  <span class="hljs-keyword">this</span>.startIndex = <span class="hljs-keyword">this</span>.anchorItem.index
  <span class="hljs-keyword">this</span>.endIndex = <span class="hljs-keyword">this</span>.startIndex + <span class="hljs-keyword">this</span>.visibleCount
}

<span class="hljs-comment">// 滚动事件处理函数</span>
handleScroll (e) {
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.doc) {
    <span class="hljs-comment">// 兼容 iOS Safari/Webview</span>
    <span class="hljs-keyword">this</span>.doc = <span class="hljs-built_in">window</span>.document.body.scrollTop ? <span class="hljs-built_in">window</span>.document.body : <span class="hljs-built_in">window</span>.document.documentElement
  }

  <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-keyword">this</span>.doc.scrollTop
  <span class="hljs-keyword">if</span> (scrollTop &gt; <span class="hljs-keyword">this</span>.scrollTop) {
    <span class="hljs-keyword">if</span> (scrollTop &gt; <span class="hljs-keyword">this</span>.anchorItem.bottom) {
      <span class="hljs-keyword">this</span>.updateBoundaryIndex(scrollTop)
      <span class="hljs-keyword">this</span>.updateVisibleData()
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scrollTop &lt; <span class="hljs-keyword">this</span>.scrollTop) {
    <span class="hljs-comment">// 向上滚动(`scrollTop` 值减小的方向)</span>
  }

  <span class="hljs-keyword">this</span>.scrollTop = scrollTop
}
<span class="hljs-comment">// ...</span></code></pre>
<p>在滚动事件处理函数中，会去更新 <code>startIndex</code>、<code>endIndex</code> 以及新的锚点元素的位置信息(即更新 <code>startOffset</code>)，然后就可以动态的去更新可视区域的渲染数据了：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000016734604?w=1172&amp;h=599" src="https://static.alili.tech/img/remote/1460000016734604?w=1172&amp;h=599" alt="demo.gif" title="demo.gif" style="cursor: pointer;"></span></p>
<blockquote>完整的代码在可以戳：<a href="https://github.com/dwqs/react-demos/tree/master/src/general/virtual-list" rel="nofollow noreferrer" target="_blank">固定高度的虚拟列表实现</a>
</blockquote>
<h3 id="articleHeader4">列表项是动态高度的</h3>
<p>这种情形下，实现的思路和列表项固高大同小异。而小异之处就在于缓存列表项的位置信息时，怎么拿到列表项的精确高度？首先要更改 <code>cachePosition</code> 的部分逻辑：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// ...
cachePosition (node, index) {
  const rect = node.getBoundingClientRect()
  const top = rect.top + window.pageYOffset

  this.cache.push({
    index,
    top,
    bottom: top + rect.height // 将 height 更为 rect.height
  })
}
// ..." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-comment">// ...</span>
cachePosition (node, index) {
  <span class="hljs-keyword">const</span> rect = node.getBoundingClientRect()
  <span class="hljs-keyword">const</span> top = rect.top + <span class="hljs-built_in">window</span>.pageYOffset

  <span class="hljs-keyword">this</span>.cache.push({
    index,
    top,
    <span class="hljs-attr">bottom</span>: top + rect.height <span class="hljs-comment">// 将 height 更为 rect.height</span>
  })
}
<span class="hljs-comment">// ...</span></code></pre>
<p>由于列表项的高度不固定，那要怎么计算 <code>visibleCount</code> 呢？我们先<strong>考虑每个列表项只是渲染一些纯文本</strong>。在实际项目中，有的列表项可能只有一行文本，有的列表项可能有多行文本，此时，我们要基于项目的实际情况，给列表项一个<strong>预估的高度</strong>：<code>estimatedItemHeight</code>。</p>
<p>比如，有一个长列表要渲染用户的文章摘要，并规定摘要显示不超过三行，那么我们取列表的前 10 个列表项的高度平均值作为预估高度。当然，为了预估高度更精确，我们是可以扩大取样样本的。</p>
<p>既然有了预估高度，那么将原先代码中的 <code>height</code> 替换成 <code>estimatedItemHeight</code>，就可以计算出 <code>visibleCount</code> 了：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// ...
const estimatedItemHeight = 80

// ...

// 计算可渲染的元素个数
this.visibleCount = Math.ceil(window.innerHeight / estimatedItemHeight) + bufferSize

// ..." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> estimatedItemHeight = <span class="hljs-number">80</span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// 计算可渲染的元素个数</span>
<span class="hljs-keyword">this</span>.visibleCount = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">window</span>.innerHeight / estimatedItemHeight) + bufferSize

<span class="hljs-comment">// ...</span></code></pre>
<p>我们通过 <a href="https://github.com/marak/Faker.js/" rel="nofollow noreferrer" target="_blank">faker.js</a> 来创建一些随机数据，并赋值给 <code>data</code>：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// ...
function fakerData () {
  const a = []
  for (let i = 0; i < 1000; i++) {
    a.push({
      id: i,
      words: faker.lorem.words(),
      paragraphs: faker.lorem.sentences()
    })
  }

  return a
}
// ...

this.data = fakerData()

// ..." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-comment">// ...</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakerData</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> a = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
    a.push({
      <span class="hljs-attr">id</span>: i,
      <span class="hljs-attr">words</span>: faker.lorem.words(),
      <span class="hljs-attr">paragraphs</span>: faker.lorem.sentences()
    })
  }

  <span class="hljs-keyword">return</span> a
}
<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">this</span>.data = fakerData()

<span class="hljs-comment">// ...</span></code></pre>
<p>修改一下列表项的 <code>render</code> 逻辑，其它不变：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// Item.jsx

// ...

render () {
  /* eslint-disable-next-line */
  const {index, item} = this.props

  return (
    <div className='list-item' style="{{" height: 'auto' "}}" ref={node => { this.node = node "}}">
      <p>#${index} {item.words}</p>
      <p>{item.paragraphs}</p>
    </div>
  )
}
// ..." title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="js"><span class="hljs-comment">// Item.jsx</span>

<span class="hljs-comment">// ...</span>

render () {
  <span class="hljs-comment">/* eslint-disable-next-line */</span>
  <span class="hljs-keyword">const</span> {index, item} = <span class="hljs-keyword">this</span>.props

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'list-item'</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"{{"</span> <span class="hljs-attr">height:</span> '<span class="hljs-attr">auto</span>' "}}" <span class="hljs-attr">ref</span>=<span class="hljs-string">{node</span> =&gt;</span> { this.node = node "}}"&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>#${index} {item.words}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{item.paragraphs}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
<span class="hljs-comment">// ...</span></code></pre>
<p>此时，列表项的高度已经是动态的了，根据渲染的实际情况，我们给的预估高度是 80：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000016734605" src="https://static.alili.tech/img/remote/1460000016734605" alt="demo2.gif" title="demo2.gif" style="cursor: pointer;"></span></p>
<blockquote>完整的代码在可以戳：<a href="https://github.com/dwqs/react-demos/tree/master/src/general/dynamic-virtual-list" rel="nofollow noreferrer" target="_blank">动态高度的虚拟列表实现</a>
</blockquote>
<p>那如果列表项渲染的不是纯文本呢？比如渲染的是图文，那在 Item 组件的 <code>componentDidMount</code> 去调用 <code>cachePosition</code> 方法时，能拿到对应节点的正确高度吗？在渲染图文的情况下，因为图片会发起网络请求，此时并不能保证在列表项组件挂载(执行  <code>componentDidMount</code>)的时候图片渲染好了，那此时对应节点的高度就是不准确的，因而在用户滚动改变可见区域渲染的数据时，就可能出现元素相互重叠的情况：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000016734606?w=1194&amp;h=866" src="https://static.alili.tech/img/remote/1460000016734606?w=1194&amp;h=866" alt="error" title="error" style="cursor: pointer; display: inline;"></span></p>
<p>在这种情况下，如果我们能监听 Item 组件节点的大小变化就能获取其正确的高度了。ResizeObserver 或许就可以满足我们的需求，其提供了监听 DOM 元素大小变化的能力，但在撰写本文时，仅 Chrome 67 及以上版本支持，其它主流浏览器均为提供支持。以下是我搜集的一些资料，供你参考(自备梯子)：</p>
<ul>
<li><a href="https://developers.google.com/web/updates/2016/10/resizeobserver" rel="nofollow noreferrer" target="_blank">ResizeObserver: It’s Like document.onresize for Elements</a></li>
<li><a href="https://github.com/WICG/ResizeObserver" rel="nofollow noreferrer" target="_blank">ResizeObserver</a></li>
<li><a href="https://caniuse.com/#feat=resizeobserver" rel="nofollow noreferrer" target="_blank">caniuse#resizeobserver</a></li>
</ul>
<h2 id="articleHeader5">总结</h2>
<p>在本文中，首先对虚拟列表进行了简单的定义，然后从长列表的角度分析了为什么需要虚拟列表，最后就列表项固高和不固高两个场景下以一个简单的 demo 详细讲述了虚拟列表的实现思路。</p>
<p>在列表项是动态高度的场景下，分析了渲染纯文本和图文混合的场景。前者给出了一个具体的 demo，针对后者对于怎么监听元素大小的变化提供了参考的 ResizeObserver 方案。基于 ResizeObserver 的方案呢，我也实现了一个支持渲染图文混合(当然也支持纯文本)的虚拟列表组件 <a href="https://github.com/dwqs/react-virtual-list" rel="nofollow noreferrer" target="_blank">react-virtual-list</a>，供你参考。</p>
<p>当然，这并不是唯一一种实现虚拟列表的方案。在组件 <a href="https://github.com/dwqs/react-virtual-list" rel="nofollow noreferrer" target="_blank">react-virtual-list</a> 的实现过程中，也阅读了不同虚拟列表组件的源码，如: react-tiny-virtual-list、react-window、react-virtualized 等，后续的系列文章我会从源码的角度逐一分析。</p>
<p>原文：<a href="https://github.com/dwqs/blog/issues/70" rel="nofollow noreferrer" target="_blank">https://github.com/dwqs/blog/...</a></p>
<h2 id="articleHeader6">参考</h2>
<ul>
<li><a href="https://developers.google.com/web/updates/2016/07/infinite-scroller" rel="nofollow noreferrer" target="_blank">Complexities of an Infinite Scroller</a></li>
<li><a href="http://itsze.ro/blog/2017/04/09/infinite-list-and-react.html" rel="nofollow noreferrer" target="_blank">Infinite List and React</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26022258" rel="nofollow noreferrer" target="_blank">聊聊前端开发中的长列表</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34585166" rel="nofollow noreferrer" target="_blank">再谈前端虚拟列表的实现</a></li>
</ul>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
浅说虚拟列表的实现原理

## 原文链接
[https://segmentfault.com/a/1190000016734597](https://segmentfault.com/a/1190000016734597)

