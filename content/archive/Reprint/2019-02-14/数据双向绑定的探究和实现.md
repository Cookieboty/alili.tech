---
title: '数据双向绑定的探究和实现' 
date: 2019-02-14 2:30:37
hidden: true
slug: 5bdthvcst4n
categories: [reprint]
---

{{< raw >}}

                    
<h1 id="articleHeader0">data-binding</h1>
<p>简单版vue的双向绑定实现</p>
<h2 id="articleHeader1">成果图</h2>
<p><span class="img-wrap"><img data-src="/img/bVbiVrr?w=736&amp;h=500" src="https://static.alili.tech/img/bVbiVrr?w=736&amp;h=500" alt="clipboard.png" title="clipboard.png" style="cursor: pointer; display: inline;"></span></p>
<h2 id="articleHeader2">vue实现</h2>
<p>上诉成果用vue来实现其实很简单，我们先创建一个文件夹v0，在v0文件夹内见一个index.html:</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <title>data-binding</title>
</head>
<style>
    #app {
        text-align: center;
    }
</style>
<body>
    <div id=&quot;app&quot;>
        <h2>"{{"title"}}"</h2>
        <input v-model=&quot;name&quot;>
        <h1>"{{"name"}}"</h1>
        <button v-on:click=&quot;clickMe&quot;>click me!</button>
    </div>
</body>
<!-- vue源码cdn地址  https://cn.vuejs.org/v2/guide/ -->
<script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;></script>
<script type=&quot;text/javascript&quot;>

     new Vue({
        el: '#app',
        data: {
            title: 'hello world',
            name: 'yujiyang'
        },
        methods: {
            clickMe: function () {
                this.title = 'hello world';
            }
        },
        mounted: function () {
            window.setTimeout(() => {
                this.title = '你好';
            }, 1000);
        }
    });

</script>
</html>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="xml hljs"><code class="html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>data-binding<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-selector-id">#app</span> {
        <span class="hljs-attribute">text-align</span>: center;
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>"{{"title"}}"<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"name"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>"{{"name"}}"<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"clickMe"</span>&gt;</span>click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-comment">&lt;!-- vue源码cdn地址  https://cn.vuejs.org/v2/guide/ --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">

     <span class="hljs-keyword">new</span> Vue({
        <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
        <span class="hljs-attr">data</span>: {
            <span class="hljs-attr">title</span>: <span class="hljs-string">'hello world'</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'yujiyang'</span>
        },
        <span class="hljs-attr">methods</span>: {
            <span class="hljs-attr">clickMe</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.title = <span class="hljs-string">'hello world'</span>;
            }
        },
        <span class="hljs-attr">mounted</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                <span class="hljs-keyword">this</span>.title = <span class="hljs-string">'你好'</span>;
            }, <span class="hljs-number">1000</span>);
        }
    });

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>那么vue是怎么实现的呢？</p>
<ul>
<li>数据双向绑定</li>
<li>"{{" "}}"双括号变量解析</li>
<li>v-model和事件指令解析</li>
</ul>
<p>现在从简到难一步一步来实现这个'vue'。<br>ps：由于本文只是为了学习和分享，所以只是简单实现下原理，并没有考虑太多情况和设计，如果大家有什么建议，欢迎提出来。</p>
<h3 id="articleHeader3">vue数据双向绑定原理</h3>
<p>看过vue的源码的同学都知道，vue是通过<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式来实现的～</p>
<p>首先来看下vue是如何进行数据劫持的？</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="new Vue({
    el: '#app',
    data: {
        message: {
            name:'yjy',
        }
    },
    created: function () {
        console.log(this.message);
    }
});" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">new</span> Vue({
    <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
    <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">message</span>: {
            <span class="hljs-attr">name</span>:<span class="hljs-string">'yjy'</span>,
        }
    },
    <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.message);
    }
});</code></pre>
<p>结果：</p>
<p><span class="img-wrap"><img data-src="/img/bVbiVrx?w=1122&amp;h=358" src="https://static.alili.tech/img/bVbiVrx?w=1122&amp;h=358" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>我们可以看到属性name有两个相对应的get和set方法，为什么会多出这两个方法呢？因为vue是通过<strong>Object.defineProperty()</strong>来实现数据劫持的。</p>
<p>Object.defineProperty( )是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性get和set，如果还不熟悉其用法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="nofollow noreferrer" target="_blank">请点击这里阅读更多用法</a>。</p>
<p>举个例子：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var People = {
  name: 'jiyang'
};
console.log(People.name);  // yjy" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> People = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'jiyang'</span>
};
<span class="hljs-built_in">console</span>.log(People.name);  <span class="hljs-comment">// yjy</span></code></pre>
<p>如果我们想要在执行console.log(People.name)的同时，直接给名字加个姓，那要怎么处理呢？或者说要通过什么监听对象People的属性值。这时候Object.defineProperty( )就派上用场了，代码如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var People = {}
var name = '';
Object.defineProperty(People, 'name', {
  set: function (value) {
    name = value;
    console.log('你取了一个名叫做' + value);
  },
  get: function () {
    return 'yu' + name 
  }
})
 
People.name = 'jiyang';  // 你取了一个名叫做jiyang
console.log(People.name);  // yujiyang" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> People = {}
<span class="hljs-keyword">var</span> name = <span class="hljs-string">''</span>;
<span class="hljs-built_in">Object</span>.defineProperty(People, <span class="hljs-string">'name'</span>, {
  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    name = value;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'你取了一个名叫做'</span> + value);
  },
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'yu'</span> + name 
  }
})
 
People.name = <span class="hljs-string">'jiyang'</span>;  <span class="hljs-comment">// 你取了一个名叫做jiyang</span>
<span class="hljs-built_in">console</span>.log(People.name);  <span class="hljs-comment">// yujiyang</span></code></pre>
<p>我们通过Object.defineProperty( )设置了对象People的name属性，对其get和set进行重写操作，顾名思义，get就是在读取name属性这个值触发的函数，set就是在设置name属性这个值触发的函数，所以当执行 People.name = 'jiyang' 这个语句时，控制台会打印出 "你取了一个名叫做jiyang"，紧接着，当读取这个属性时，就会输出 "yujiyang"，因为我们在get函数里面对该值做了加工了。如果这个时候我们执行下下面的语句，控制台会输出什么？</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="console.log(People)" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript" style="word-break: break-word; white-space: initial;"><span class="hljs-built_in">console</span>.log(People)</code></pre>
<p>结果：</p>
<p><span class="img-wrap"><img data-src="/img/bVbiVrA?w=974&amp;h=284" src="https://static.alili.tech/img/bVbiVrA?w=974&amp;h=284" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>是不是跟我们在上面打印vue数据长得有点类似，这也进一步验证vue确实是通过这种方法来进行数据劫持的。接下来我们通过其原理来实现一个简单版的mvvm双向绑定代码。</p>
<h3 id="articleHeader4">mvvm思路分析</h3>
<p>实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据：</p>
<p><span class="img-wrap"><img data-src="/img/bVbiVrC?w=894&amp;h=382" src="https://static.alili.tech/img/bVbiVrC?w=894&amp;h=382" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>view更新data其实可以通过事件监听即可，比如input标签监听 'input' 事件就可以实现了。所以我们着重来分析下，当数据改变，如何更新视图的？</p>
<p>其实上文我们已经给出答案了，就是通过Object.defineProperty()对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。</p>
<p><span class="img-wrap"><img data-src="/img/bVbiVrE?w=1276&amp;h=708" src="https://static.alili.tech/img/bVbiVrE?w=1276&amp;h=708" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>现在思路有了，接下去就是实现过程了。</p>
<h3 id="articleHeader5">实现过程</h3>
<h4>监听器Observer</h4>
<p>首先我们需要实现一个数据监听器Observer，用来监听所有属性，如果属性发上变化了，就执行相应方法。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function defineReactive(data, key, val) {
    observe(val); // 递归遍历所有子属性
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            return val;
        },
        set: function(newVal) {
            val = newVal;
            console.log('属性' + key + '已经被监听了，现在值为：“' + newVal.toString() + '”');
        }
    });
}
 
function observe(data) {
    if (!data || typeof data !== 'object') {
        return;
    }
    Object.keys(data).forEach(function(key) {
        defineReactive(data, key, data[key]);
    });
};
 
var people = {
    person1: {
        name: ''
    },
    person2: ''
};
observe(people);
people.person1.name = 'yjy'; // 属性name已经被监听了，现在值为：“yjy”
people.person2 = '没有此人';  // 属性person2已经被监听了，现在值为：“没有此人”" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">data, key, val</span>) </span>{
    observe(val); <span class="hljs-comment">// 递归遍历所有子属性</span>
    <span class="hljs-built_in">Object</span>.defineProperty(data, key, {
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> val;
        },
        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) </span>{
            val = newVal;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'属性'</span> + key + <span class="hljs-string">'已经被监听了，现在值为：“'</span> + newVal.toString() + <span class="hljs-string">'”'</span>);
        }
    });
}
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">if</span> (!data || <span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
        defineReactive(data, key, data[key]);
    });
};
 
<span class="hljs-keyword">var</span> people = {
    <span class="hljs-attr">person1</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>
    },
    <span class="hljs-attr">person2</span>: <span class="hljs-string">''</span>
};
observe(people);
people.person1.name = <span class="hljs-string">'yjy'</span>; <span class="hljs-comment">// 属性name已经被监听了，现在值为：“yjy”</span>
people.person2 = <span class="hljs-string">'没有此人'</span>;  <span class="hljs-comment">// 属性person2已经被监听了，现在值为：“没有此人”</span></code></pre>
<h4>订阅器Dep与订阅者Watcher</h4>
<p>由于一个属性的getter可能在多处触发（也就是被多个dom使用），所以属性setter的时候需要执行多个改变view的方法，我们把通知执行一个改变view的方法抽象成一个订阅者Watcher。有一个容器来专门收集Watcher，叫做订阅器Dep。</p>
<p>Watcher初始化的时候，添加一个Watcher到Dep。<br>属性每次setter的时候，执行Dep中所有Watcher。</p>
<p><span class="img-wrap"><img data-src="/img/bVbiVrT?w=1648&amp;h=1024" src="https://static.alili.tech/img/bVbiVrT?w=1648&amp;h=1024" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>有了这个思路我们结合observer，来实现一下Dep和Watcher</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// observer.js
// observer+dep
function Observer(data) {
    this.data = data;
    this.walk(data);
}
Observer.prototype = {
    walk: function(data) {
        var self = this;
        Object.keys(data).forEach(function(key) {
            self.defineReactive(data, key, data[key]);
        });
    },
    defineReactive: function(data, key, val) {
        var dep = new Dep();
        var childObj = observe(val);
        Object.defineProperty(data, key, {
            enumerable: true,
            configurable: true,
            get: function() {
                if (Dep.target) {
                    dep.addSub(Dep.target);
                }
                return val;
            },
            set: function(newVal) {
                if (newVal === val) {
                    return;
                }
                val = newVal;
                dep.notify();
            }
        });
    }
};

function observe(value, vm) {
    if (!value || typeof value !== 'object') {
        return;
    }
    return new Observer(value);
};

function Dep () {
    this.subs = [];
}
Dep.prototype = {
    addSub: function(sub) {
        this.subs.push(sub);
    },
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update();
        });
    }
};
Dep.target = null;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">// observer.js</span>
<span class="hljs-comment">// observer+dep</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Observer</span>(<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.walk(data);
}
Observer.prototype = {
    <span class="hljs-attr">walk</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
            self.defineReactive(data, key, data[key]);
        });
    },
    <span class="hljs-attr">defineReactive</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, key, val</span>) </span>{
        <span class="hljs-keyword">var</span> dep = <span class="hljs-keyword">new</span> Dep();
        <span class="hljs-keyword">var</span> childObj = observe(val);
        <span class="hljs-built_in">Object</span>.defineProperty(data, key, {
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (Dep.target) {
                    dep.addSub(Dep.target);
                }
                <span class="hljs-keyword">return</span> val;
            },
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) </span>{
                <span class="hljs-keyword">if</span> (newVal === val) {
                    <span class="hljs-keyword">return</span>;
                }
                val = newVal;
                dep.notify();
            }
        });
    }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">value, vm</span>) </span>{
    <span class="hljs-keyword">if</span> (!value || <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observer(value);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dep</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.subs = [];
}
Dep.prototype = {
    <span class="hljs-attr">addSub</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sub</span>) </span>{
        <span class="hljs-keyword">this</span>.subs.push(sub);
    },
    <span class="hljs-attr">notify</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.subs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sub</span>) </span>{
            sub.update();
        });
    }
};
Dep.target = <span class="hljs-literal">null</span>;</code></pre>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// watcher.js
function Watcher(vm, exp, cb) {
    this.cb = cb;
    this.vm = vm;
    this.exp = exp;
    this.value = this.get();  // 将自己添加到订阅器的操作
}

Watcher.prototype = {
    update: function() {
        this.run();
    },
    run: function() {
        var value = this.vm.data[this.exp];
        var oldVal = this.value;
        if (value !== oldVal) {
            this.value = value;
            this.cb.call(this.vm, value, oldVal);
        }
    },
    get: function() {
        Dep.target = this;  // 缓存自己
        var value = this.vm.data[this.exp]  // 强制执行监听器里的get函数
        Dep.target = null;  // 释放自己
        return value;
    }
};" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">// watcher.js</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Watcher</span>(<span class="hljs-params">vm, exp, cb</span>) </span>{
    <span class="hljs-keyword">this</span>.cb = cb;
    <span class="hljs-keyword">this</span>.vm = vm;
    <span class="hljs-keyword">this</span>.exp = exp;
    <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.get();  <span class="hljs-comment">// 将自己添加到订阅器的操作</span>
}

Watcher.prototype = {
    <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.run();
    },
    <span class="hljs-attr">run</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.vm.data[<span class="hljs-keyword">this</span>.exp];
        <span class="hljs-keyword">var</span> oldVal = <span class="hljs-keyword">this</span>.value;
        <span class="hljs-keyword">if</span> (value !== oldVal) {
            <span class="hljs-keyword">this</span>.value = value;
            <span class="hljs-keyword">this</span>.cb.call(<span class="hljs-keyword">this</span>.vm, value, oldVal);
        }
    },
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        Dep.target = <span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 缓存自己</span>
        <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.vm.data[<span class="hljs-keyword">this</span>.exp]  <span class="hljs-comment">// 强制执行监听器里的get函数</span>
        Dep.target = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 释放自己</span>
        <span class="hljs-keyword">return</span> value;
    }
};</code></pre>
<h4>‘vue’的v1版本</h4>
<p>了解了Observer、Dep、Watcher后，我们只要将Observer和Watcher关联起来，就可以实现一个简单的数据双向绑定了。因为这里没有还没有设计解析器Compile，所以对于模板绑定的属性数据,我们都进行写死处理，假设模板上有一个节点，且id号为'name'，并且双向绑定的绑定的变量也为'name'，且是通过两个大双括号包起来（这里只是为了掩饰，暂时没什么用处）。</p>
<p>先建立一个文件夹v1，目录结构如下：</p>
<p><span class="img-wrap"><img data-src="/img/bVbiVr0?w=512&amp;h=266" src="https://static.alili.tech/img/bVbiVr0?w=512&amp;h=266" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>observer和watcher我们已经实现，还需要实现一个关联Observer和Watcher的index.js和模板index.html</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<!--index.html-->
<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <title>self-vue</title>
</head>
<style>
    #name {
        text-align: center;
    }
</style>
<body>
    <h1 id=&quot;name&quot;></h1>
</body>
<script src=&quot;js/observer.js&quot;></script>
<script src=&quot;js/watcher.js&quot;></script>
<script src=&quot;js/index.js&quot;></script>
<script type=&quot;text/javascript&quot;>

    var ele = document.querySelector('#name');
    var vue = new Vue({
        name: 'hello world'
    }, ele, 'name');

    window.setTimeout(function () {
        console.log('name值改变了');
        vue.name = 'yjy';
    }, 2000);

</script>
</html>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="xml hljs"><code class="html"><span class="hljs-comment">&lt;!--index.html--&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>self-vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-selector-id">#name</span> {
        <span class="hljs-attribute">text-align</span>: center;
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/observer.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/watcher.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/index.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">

    <span class="hljs-keyword">var</span> ele = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#name'</span>);
    <span class="hljs-keyword">var</span> vue = <span class="hljs-keyword">new</span> Vue({
        <span class="hljs-attr">name</span>: <span class="hljs-string">'hello world'</span>
    }, ele, <span class="hljs-string">'name'</span>);

    <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'name值改变了'</span>);
        vue.name = <span class="hljs-string">'yjy'</span>;
    }, <span class="hljs-number">2000</span>);

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// index.js
function Vue (data, el, exp) {
    var self = this;
    this.data = data;

    // 知道为什么还要这个操作？？？
    Object.keys(data).forEach(function(key) {
        self.proxyKeys(key);
    });

    observe(data);
    el.innerHTML = this.data[exp];  // 初始化模板数据的值
    new Watcher(this, exp, function (value) {
        el.innerHTML = value;
    });
    return this;
}

Vue.prototype = {
    proxyKeys: function (key) {
        var self = this;
        Object.defineProperty(this, key, {
            enumerable: false,
            configurable: true,
            get: function proxyGetter() {
                return self.data[key];
            },
            set: function proxySetter(newVal) {
                self.data[key] = newVal;
            }
        });
    }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">// index.js</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span> (<span class="hljs-params">data, el, exp</span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.data = data;

    <span class="hljs-comment">// 知道为什么还要这个操作？？？</span>
    <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
        self.proxyKeys(key);
    });

    observe(data);
    el.innerHTML = <span class="hljs-keyword">this</span>.data[exp];  <span class="hljs-comment">// 初始化模板数据的值</span>
    <span class="hljs-keyword">new</span> Watcher(<span class="hljs-keyword">this</span>, exp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        el.innerHTML = value;
    });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

Vue.prototype = {
    <span class="hljs-attr">proxyKeys</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, key, {
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyGetter</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> self.data[key];
            },
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxySetter</span>(<span class="hljs-params">newVal</span>) </span>{
                self.data[key] = newVal;
            }
        });
    }
}</code></pre>
<h4>解析器Compile</h4>
<p>虽然上面已经实现了一个双向数据绑定的例子，但是整个过程都没有去解析dom节点，而是直接固定某个节点进行替换数据的，所以接下来需要实现一个解析器Compile来做解析和绑定工作。</p>
<p>解析器Compile实现步骤：</p>
<ol>
<li>解析模板指令，并替换模板数据，初始化视图</li>
<li>将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器</li>
</ol>
<p><span class="img-wrap"><img data-src="/img/bVbiVr9?w=2154&amp;h=1126" src="https://static.alili.tech/img/bVbiVr9?w=2154&amp;h=1126" alt="clipboard.png" title="clipboard.png" style="cursor: pointer;"></span></p>
<p>为了解析模板，首先需要获取到dom元素，然后对含有dom元素上<strong>含有指令</strong>的节点进行处理，因此这个环节需要对dom操作比较频繁，所有可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里再进行处理：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function nodeToFragment (el) {
    var fragment = document.createDocumentFragment();
    var child = el.firstChild;
    while (child) {
        // 将Dom元素移入fragment中
        fragment.appendChild(child);
        child = el.firstChild
    }
    return fragment;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nodeToFragment</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-keyword">var</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();
    <span class="hljs-keyword">var</span> child = el.firstChild;
    <span class="hljs-keyword">while</span> (child) {
        <span class="hljs-comment">// 将Dom元素移入fragment中</span>
        fragment.appendChild(child);
        child = el.firstChild
    }
    <span class="hljs-keyword">return</span> fragment;
}</code></pre>
<p>接下来需要遍历各个节点，对含有相关指定的节点进行特殊处理，这里咱们先处理最简单的情况，只对带有 '"{{"变量"}}"' 这种形式的指令进行处理，后面再考虑更多指令情况：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function compileElement (el) {
    var childNodes = el.childNodes;
    var self = this;
    [].slice.call(childNodes).forEach(function(node) {
        var reg = /\{\{(.*)\}\}/;
        var text = node.textContent; //获取该节点以及其子节点所包含文本内容
 
        if (self.isTextNode(node) &amp;&amp; reg.test(text)) {  // 判断是否是符合这种形式"{{""}}"的指令且节点类型是文本类型
            self.compileText(node, reg.exec(text)[1]);
        }
 
        if (node.childNodes &amp;&amp; node.childNodes.length) {
            self.compileElement(node);  // 继续递归遍历子节点
        }
    });
},
function compileText (node, exp) {
    var self = this;
    var initText = this.vm[exp];
    this.updateText(node, initText);  // 将初始化的数据初始化到视图中
    new Watcher(this.vm, exp, function (value) {  // 生成订阅器并绑定更新函数
        self.updateText(node, value);
    });
},
function updateText (node, value) {
    node.textContent = typeof value == 'undefined' ? '' : value;
},
function isTextNode (node) {
    return node.nodeType == 3;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileElement</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-keyword">var</span> childNodes = el.childNodes;
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    [].slice.call(childNodes).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\{\{(.*)\}\}/</span>;
        <span class="hljs-keyword">var</span> text = node.textContent; <span class="hljs-comment">//获取该节点以及其子节点所包含文本内容</span>
 
        <span class="hljs-keyword">if</span> (self.isTextNode(node) &amp;&amp; reg.test(text)) {  <span class="hljs-comment">// 判断是否是符合这种形式"{{""}}"的指令且节点类型是文本类型</span>
            self.compileText(node, reg.exec(text)[<span class="hljs-number">1</span>]);
        }
 
        <span class="hljs-keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) {
            self.compileElement(node);  <span class="hljs-comment">// 继续递归遍历子节点</span>
        }
    });
},
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileText</span> (<span class="hljs-params">node, exp</span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> initText = <span class="hljs-keyword">this</span>.vm[exp];
    <span class="hljs-keyword">this</span>.updateText(node, initText);  <span class="hljs-comment">// 将初始化的数据初始化到视图中</span>
    <span class="hljs-keyword">new</span> Watcher(<span class="hljs-keyword">this</span>.vm, exp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{  <span class="hljs-comment">// 生成订阅器并绑定更新函数</span>
        self.updateText(node, value);
    });
},
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateText</span> (<span class="hljs-params">node, value</span>) </span>{
    node.textContent = <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span> ? <span class="hljs-string">''</span> : value;
},
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTextNode</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> node.nodeType == <span class="hljs-number">3</span>;
}</code></pre>
<p>获取到最外层节点后，调用compileElement函数，对所有子节点进行判断，如果节点是文本节点且匹配"{{""}}"这种形式指令的节点就开始进行编译处理，编译处理首先需要初始化视图数据，对应上面所说的步骤1，接下去需要生成一个并绑定更新函数的订阅器，对应上面所说的步骤2。这样就完成指令的解析、初始化、编译三个过程，一个解析器Compile也就可以正常的工作了。为了将解析器Compile与监听器Observer和订阅者Watcher关联起来，我们需要再修改一下‘Vue类’：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// index.js
function Vue (options) {
    var self = this;
    this.vm = this;
    this.data = options.data;

    Object.keys(this.data).forEach(function(key) {
        self.proxyKeys(key);
    });

    observe(this.data);
    new Compile(options.el, this.vm); // 初始化视图和watcher初始化都封装在compile里面
    return this;
}

Vue.prototype = {
    proxyKeys: function (key) {
        var self = this;
        Object.defineProperty(this, key, {
            enumerable: false,
            configurable: true,
            get: function proxyGetter() {
                return self.data[key];
            },
            set: function proxySetter(newVal) {
                self.data[key] = newVal;
            }
        });
    }
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">// index.js</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span> (<span class="hljs-params">options</span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.vm = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.data = options.data;

    <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.data).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
        self.proxyKeys(key);
    });

    observe(<span class="hljs-keyword">this</span>.data);
    <span class="hljs-keyword">new</span> Compile(options.el, <span class="hljs-keyword">this</span>.vm); <span class="hljs-comment">// 初始化视图和watcher初始化都封装在compile里面</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

Vue.prototype = {
    <span class="hljs-attr">proxyKeys</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, key, {
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyGetter</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> self.data[key];
            },
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxySetter</span>(<span class="hljs-params">newVal</span>) </span>{
                self.data[key] = newVal;
            }
        });
    }
}
</code></pre>
<p>更改后，我们就不要像之前通过传入固定的元素值进行双向绑定了，只要传入一个根节点就可以对所有子节点进行双向绑定了：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<body>
    <div id=&quot;app&quot;>
        <h2>"{{"title"}}"</h2>
        <h1>"{{"name"}}"</h1>
    </div>
</body>
<script src=&quot;js/observer.js&quot;></script>
<script src=&quot;js/watcher.js&quot;></script>
<script src=&quot;js/compile.js&quot;></script>
<script src=&quot;js/index.js&quot;></script>
<script type=&quot;text/javascript&quot;>
 
    var Vue = new Vue({
        el: '#app',
        data: {
            title: 'hello world',
            name: 'ddvdd'
        }
    });
 
    window.setTimeout(function () {
        Vue.title = '你好';
    }, 2000);
 
    window.setTimeout(function () {
        Vue.name = 'yjy';
    }, 2500);
 
</script>" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="xml hljs"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>"{{"title"}}"<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>"{{"name"}}"<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/observer.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/watcher.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/compile.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/index.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
 
    <span class="hljs-keyword">var</span> Vue = <span class="hljs-keyword">new</span> Vue({
        <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
        <span class="hljs-attr">data</span>: {
            <span class="hljs-attr">title</span>: <span class="hljs-string">'hello world'</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'ddvdd'</span>
        }
    });
 
    <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        Vue.title = <span class="hljs-string">'你好'</span>;
    }, <span class="hljs-number">2000</span>);
 
    <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        Vue.name = <span class="hljs-string">'yjy'</span>;
    }, <span class="hljs-number">2500</span>);
 
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>完整的Compile.js代码如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Compile(el, vm) {
    this.vm = vm;
    this.el = document.querySelector(el);
    this.fragment = null;
    this.init();
}

Compile.prototype = {
    init: function () {
        if (this.el) {
            this.fragment = this.nodeToFragment(this.el);
            this.compileElement(this.fragment);
            this.el.appendChild(this.fragment);
        } else {
            console.log('Dom元素不存在');
        }
    },
    nodeToFragment: function (el) {
        var fragment = document.createDocumentFragment();
        var child = el.firstChild;
        while (child) {
            // 将Dom元素移入fragment中
            fragment.appendChild(child);
            child = el.firstChild
        }
        return fragment;
    },
    compileElement: function (el) {
        var childNodes = el.childNodes;
        var self = this;
        [].slice.call(childNodes).forEach(function(node) {
            var reg = /\{\{(.*)\}\}/;
            var text = node.textContent;

            if (self.isTextNode(node) &amp;&amp; reg.test(text)) {  // 判断是否是符合这种形式"{{""}}"的指令
                self.compileText(node, reg.exec(text)[1]);
            }

            if (node.childNodes &amp;&amp; node.childNodes.length) {
                self.compileElement(node);  // 继续递归遍历子节点
            }
        });
    },
    compileText: function(node, exp) {
        var self = this;
        var initText = this.vm[exp];
        this.updateText(node, initText);  // 将初始化的数据初始化到视图中
        new Watcher(this.vm, exp, function (value) { // 生成订阅器并绑定更新函数
            self.updateText(node, value);
        });
    },
    updateText: function (node, value) {
        node.textContent = typeof value == 'undefined' ? '' : value;
    },
    isTextNode: function(node) {
        return node.nodeType == 3;
    }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Compile</span>(<span class="hljs-params">el, vm</span>) </span>{
    <span class="hljs-keyword">this</span>.vm = vm;
    <span class="hljs-keyword">this</span>.el = <span class="hljs-built_in">document</span>.querySelector(el);
    <span class="hljs-keyword">this</span>.fragment = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.init();
}

Compile.prototype = {
    <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.el) {
            <span class="hljs-keyword">this</span>.fragment = <span class="hljs-keyword">this</span>.nodeToFragment(<span class="hljs-keyword">this</span>.el);
            <span class="hljs-keyword">this</span>.compileElement(<span class="hljs-keyword">this</span>.fragment);
            <span class="hljs-keyword">this</span>.el.appendChild(<span class="hljs-keyword">this</span>.fragment);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Dom元素不存在'</span>);
        }
    },
    <span class="hljs-attr">nodeToFragment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{
        <span class="hljs-keyword">var</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();
        <span class="hljs-keyword">var</span> child = el.firstChild;
        <span class="hljs-keyword">while</span> (child) {
            <span class="hljs-comment">// 将Dom元素移入fragment中</span>
            fragment.appendChild(child);
            child = el.firstChild
        }
        <span class="hljs-keyword">return</span> fragment;
    },
    <span class="hljs-attr">compileElement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{
        <span class="hljs-keyword">var</span> childNodes = el.childNodes;
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        [].slice.call(childNodes).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\{\{(.*)\}\}/</span>;
            <span class="hljs-keyword">var</span> text = node.textContent;

            <span class="hljs-keyword">if</span> (self.isTextNode(node) &amp;&amp; reg.test(text)) {  <span class="hljs-comment">// 判断是否是符合这种形式"{{""}}"的指令</span>
                self.compileText(node, reg.exec(text)[<span class="hljs-number">1</span>]);
            }

            <span class="hljs-keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) {
                self.compileElement(node);  <span class="hljs-comment">// 继续递归遍历子节点</span>
            }
        });
    },
    <span class="hljs-attr">compileText</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, exp</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">var</span> initText = <span class="hljs-keyword">this</span>.vm[exp];
        <span class="hljs-keyword">this</span>.updateText(node, initText);  <span class="hljs-comment">// 将初始化的数据初始化到视图中</span>
        <span class="hljs-keyword">new</span> Watcher(<span class="hljs-keyword">this</span>.vm, exp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{ <span class="hljs-comment">// 生成订阅器并绑定更新函数</span>
            self.updateText(node, value);
        });
    },
    <span class="hljs-attr">updateText</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, value</span>) </span>{
        node.textContent = <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span> ? <span class="hljs-string">''</span> : value;
    },
    <span class="hljs-attr">isTextNode</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node.nodeType == <span class="hljs-number">3</span>;
    }
}</code></pre>
<h3 id="articleHeader6">思考</h3>
<p>到这里，一个数据双向绑定功能已经基本完成了，接下去就是需要完善更多指令的解析编译，在哪里进行更多指令的处理呢？</p>
<p>如何添加一个v-model指令和事件指令v-on:click的解析编译?</p>
<h2 id="articleHeader7">所有例子和最终思考答案</h2>
<p><a href="https://github.com/ddvdd008/data-binding" rel="nofollow noreferrer" target="_blank">源码地址</a><br>如果对你有帮助，麻烦star下～</p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
数据双向绑定的探究和实现

## 原文链接
[https://segmentfault.com/a/1190000016864782](https://segmentfault.com/a/1190000016864782)

