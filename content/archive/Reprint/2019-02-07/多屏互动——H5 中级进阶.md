---
title: '多屏互动——H5 中级进阶' 
date: 2019-02-07 2:30:15
hidden: true
slug: c2ekhqxwtcj
categories: [reprint]
---

{{< raw >}}

                    
<h2 id="articleHeader0">前言</h2>
<p>随着智能硬件的普及，手机，平板，PC甚至路边的电子广告牌，现代浏览器已经无处不在。在浏览器里编织出我们自己的一片天地已经轻车熟路，但是这还不够，H5赋予了浏览器太多的新特性，等待我们去使用。这篇文章介绍利用手机浏览器的罗盘API，在PC的浏览器实时地绘制一个3D盒模型。</p>
<p>这种炫酷的玩法叫做“多屏互动”，就像是把手机当做游戏手柄，PC显示器当做电视机，不过这些都是在浏览器里实现的。</p>
<p><strong>先上效果图</strong><br><span class="img-wrap"><img data-src="/img/remote/1460000006760584?w=483&amp;h=272" src="https://static.alili.tech/img/remote/1460000006760584?w=483&amp;h=272" alt="这里写图片描述" title="这里写图片描述" style="cursor: pointer; display: inline;"></span></p>
<p>(测试机是刷了小米系统的裂了屏幕的HTC霹雳2+Chrome浏览器)</p>
<p><strong>源码请戳这里</strong>：<a href="https://coding.net/u/OverTree/p/webSocketDemo/git" rel="nofollow noreferrer" target="_blank">https://coding.net/u/OverTree...</a></p>
<p><strong>本地测试过程：</strong></p>
<ol>
<li><p>在PC上，使用命令 node index.js，自动打开项目主页。（请关闭ADsafe，如有虚拟机，请停用虚拟网卡）</p></li>
<li><p>创建一个“房间”并自动进入“房间”。</p></li>
<li><p>用手机扫描“房间”内任意位置的二维码。</p></li>
<li><p>确保手机和PC可以相互PING通</p></li>
</ol>
<blockquote><p>ADsafe是个很好用的去广告软件，但是会阻止本机IP访问，可能造成项目首页打不开，所以请先暂时关闭<br>本程序会自动获取本机IP，如果有虚拟网卡，IP地址可能获取不正确</p></blockquote>
<hr>
<h2 id="articleHeader1">客户端（浏览器）</h2>
<h3 id="articleHeader2"><strong>1. 手机浏览器端</strong></h3>
<p>一个物体在空间内的旋转体位，都可以用一个方向向量（x,y,z）和旋转角度（angle）来表示。也就是CSS3<code>transform</code>的<code>rotate3d(x,y,z,angle)</code>这个函数的4个参数。</p>
<p>想要在浏览器里方便的绘制一个立体模型的的旋转，重点就是利用手机浏览器的H5新特性去获取手机旋转状态的数据，然后转化成这4个参数。</p>
<h3 id="articleHeader3"><strong>1.1 重力感应API</strong></h3>
<p><code>devicemotion</code> 顾名思义设备运动<br>其实不仅仅有重力感应的数据，还有移动加速度，摆动角度。<br>不过这个接口倾向于<strong>运动时瞬间</strong>的数据展示，静止时，除了重力加速度，其他数据（移动加速度，摆动角度）基本为0。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="window.addEventListener('devicemotion', deviceMotionHandler, true);
function deviceMotionHandler(evt){
   if(evt.accelerationIncludingGravity){
       document.body.innerHTML = 
          &quot;x轴加速度: &quot; + evt.accelerationIncludingGravity.x + &quot;<br>&quot;
        + &quot;y轴加速度: &quot; + evt.accelerationIncludingGravity.y + &quot;<br>&quot;
        + &quot;z轴加速度: &quot; + evt.accelerationIncludingGravity.z + &quot;<br>&quot;
    }
    if(evt.rotationRate ){
       document.body.innerHTML +=  
         &quot;x轴扭转: &quot; + evt.rotationRate.beta + &quot;<br>&quot; 
       + &quot;y轴扭转: &quot; + evt.rotationRate.gamma + &quot;<br>&quot;
       + &quot;z轴扭转: &quot; + evt.rotationRate.alpha + &quot;<br>&quot;
    }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="xml hljs"><code class="html5">window.addEventListener('devicemotion', deviceMotionHandler, true);
function deviceMotionHandler(evt){
   if(evt.accelerationIncludingGravity){
       document.body.innerHTML = 
          "x轴加速度: " + evt.accelerationIncludingGravity.x + "<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>"
        + "y轴加速度: " + evt.accelerationIncludingGravity.y + "<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>"
        + "z轴加速度: " + evt.accelerationIncludingGravity.z + "<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>"
    }
    if(evt.rotationRate ){
       document.body.innerHTML +=  
         "x轴扭转: " + evt.rotationRate.beta + "<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>" 
       + "y轴扭转: " + evt.rotationRate.gamma + "<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>"
       + "z轴扭转: " + evt.rotationRate.alpha + "<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>"
    }
}</code></pre>
<p><strong>（魅族老机型，安卓4.4.4的自带浏览器对此API支持不完全，请另外安装QQ浏览器）</strong><br>在手机浏览器里运行以上代码，并稍微晃动，会看到打印数据狂跳。<br>拿到了数据，接下来开始观察规律。<br>手机屏幕朝上，水平静止放置，Z轴重力加速度为9.8，Y,X为0。<br>手机屏幕朝下，水平静止放置，Z轴重力加速度为-9.8，Y,X为0。<br>手机话筒朝下，竖直静止放置，Y重力加速度为9.8, X,Z为0。<br>手机话筒朝上，竖直静止放置，Y重力加速度为-9.8, X,Z为0。<br>手机右侧朝上，竖直静止放置，X重力加速度为9.8, Y,Z为0。<br>手机左侧朝下，竖直静止放置，X重力加速度为-9.8, Y,Z为0。</p>
<p>那么手机的空间坐标如下图：<br><span class="img-wrap"><img data-src="/img/remote/1460000006760585?w=450&amp;h=450" src="https://static.alili.tech/img/remote/1460000006760585?w=450&amp;h=450" alt="这里写图片描述" title="这里写图片描述" style="cursor: pointer;"></span><br>箭头指向都是坐标正方向。</p>
<p>当手机开始倾斜，X,Y,Z轴的加速度分量都有值，且绝对值都小于9.8。根据分量的数值，是可以算出手机在三维空间的倾斜状态，只不过这个计算过程复杂，而且在手机运动时，重力加速度的值并不准确表达当前倾斜。一般不用这个数据去计算手机在三维空间的倾斜。</p>
<p>当手机水平放置，拨动手机，使其慢慢旋转，重力加速度的数据并没有变化。<br>所以，<strong>重力感应的这个API，只能获取设备当前的倾斜状态，而无法获取设备的旋转方向</strong>。而一些简单的功能，比如摇一摇，晃一晃，就可以用这个接口去实现。</p>
<p>利用重力感应的API，可以轻松利用高中数学的<strong>反三角函数</strong>，实现XY二维平面的旋转，效果如下：</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000005990687" src="https://static.alili.tech/img/remote/1460000005990687" alt="这里写图片描述" title="这里写图片描述" style="cursor: pointer; display: inline;"></span></p>
<p>代码如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function deviceMotionHandler(evt){
    var angle = 
    Math.atan2(
            0 - evt.accelerationIncludingGravity.x ,     　　　
            evt.accelerationIncludingGravity.y
        ).toFixed(2) / Math.PI * 180 ; 
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deviceMotionHandler</span>(<span class="hljs-params">evt</span>)</span>{
    <span class="hljs-keyword">var</span> angle = 
    <span class="hljs-built_in">Math</span>.atan2(
            <span class="hljs-number">0</span> - evt.accelerationIncludingGravity.x ,     　　　
            evt.accelerationIncludingGravity.y
        ).toFixed(<span class="hljs-number">2</span>) / <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">180</span> ; 
}</code></pre>
<p>这个 angle 就可以直接应用在DOM的CSS属性<code>transform:rotate(angle deg)</code>上。</p>
<h3 id="articleHeader4"><strong>1.2 罗盘API</strong></h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="window.addEventListener('deviceorientation', deviceOrientationHandler, true);
function deviceMotionHandler(evt){
     document.body.innerHTML = 
          &quot;z轴旋转(罗盘方向) alpha: 　&quot; + event.alpha + &quot;<br>&quot;
        + &quot;y轴旋转 gamma: 　&quot; + event.gamma + &quot;<br>&quot;
        + &quot;x轴旋转 beta: 　&quot; + event.beta

}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="xml hljs"><code class="html5">window.addEventListener('deviceorientation', deviceOrientationHandler, true);
function deviceMotionHandler(evt){
     document.body.innerHTML = 
          "z轴旋转(罗盘方向) alpha: 　" + event.alpha + "<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>"
        + "y轴旋转 gamma: 　" + event.gamma + "<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>"
        + "x轴旋转 beta: 　" + event.beta

}</code></pre>
<p>重点来了，<code>deviceorientation</code>能够很好的表现物体在空间中的状态，旋转方向，倾斜角度，无论是静止还是运动或者加速运动。</p>
<p>这里要和<code>devicemotion</code> 的 <code>evt.rotationRate</code>区分一下，虽然都有alpha，gamma，beta 但是 <code>devicemotion</code> 描述的是旋转变化了的角度值，物体角度变化才会有数据，静止了之后就变为0，而 <code>deviceorientation</code> 的是描述是静止时的角度值。</p>
<p>这三个数值的单位都是deg，如何转化为CSS3 <code>transform:rotate3d(x,y,z,angle)</code> 的4个参数，对于没有任何3D知识的前端狗来说是个挺麻烦的问题。</p>
<p>现在要引入一个概念：<strong>四元数</strong></p>
<blockquote><p>四元数是个高阶复数 q = [w,x,y,z]。<br>四元数的基本数学方程为 :<br>q = cos (a/2) + i(x <em> sin(a/2)) + j(y </em> sin(a/2)) + k(z * sin(a/2)) 其中a表示旋转角度，(x,y,z)表示旋转轴。<br>四元数表示一个完整的旋转。<br>四元数可以由各轴旋转角(alpha,beta,gamma)求得。<br>四元数可以转换旋转轴(x,y,z)和旋转角度(angle)。</p></blockquote>
<p>作为初试，本篇并不深入讨论四元数的具体定义，难点是获取四元数[w,x,y,z]。<br>好在官方提供了旋转角(alpha,beta,gamma)转换成四元数的方法<br><a href="https://w3c.github.io/deviceorientation/spec-source-orientation.html" rel="nofollow noreferrer" target="_blank">https://w3c.github.io/deviceo...</a><br>在这个页面内搜索 <em>getQuaternion</em></p>
<p>另外我根据数学公式反求，写了一个四元数转(x,y,z,angle) 的函数 getAcQuaternion<br>代码如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var degtorad = Math.PI / 180;
function getQuaternion( alpha, beta, gamma ) {  //官方求四元数方法

  var _x = beta  ? beta  * degtorad : 0; // beta value
  var _y = gamma ? gamma * degtorad : 0; // gamma value
  var _z = alpha ? alpha * degtorad : 0; // alpha value

  var cX = Math.cos( _x/2 );
  var cY = Math.cos( _y/2 );
  var cZ = Math.cos( _z/2 );
  var sX = Math.sin( _x/2 );
  var sY = Math.sin( _y/2 );
  var sZ = Math.sin( _z/2 );

  var w = cX * cY * cZ - sX * sY * sZ;
  var x = sX * cY * cZ - cX * sY * sZ;
  var y = cX * sY * cZ + sX * cY * sZ;
  var z = cX * cY * sZ + sX * sY * cZ;

  return [ w, x, y, z ];

}

function getAcQuaternion( _w, _x, _y, _z ) {  //我的四元数转旋转轴和旋转角度方法

  var rotate = 2 * Math.acos(_w)/degtorad ;

  var x = _x / Math.sin(degtorad * rotate/2) || 0;
  var y = _y / Math.sin(degtorad * rotate/2) || 0;
  var z = _z / Math.sin(degtorad * rotate/2) || 0;

  return {x:x,y:y,z:z,rotate:rotate};

}

function deviceMotionHandler(evt){  // deviceorientation 事件处理函数
  var qu = getQuaternion(evt.alpha,evt.beta,evt.gamma);
  var rotate3d = getAcQuaternion(qu[0],qu[1],qu[2],qu[3]);
  // rotate3d的参数已经有了，随你处理咯。我是把他送给服务器，交给PC，在PC上显示旋转
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> degtorad = <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQuaternion</span>(<span class="hljs-params"> alpha, beta, gamma </span>) </span>{  <span class="hljs-comment">//官方求四元数方法</span>

  <span class="hljs-keyword">var</span> _x = beta  ? beta  * degtorad : <span class="hljs-number">0</span>; <span class="hljs-comment">// beta value</span>
  <span class="hljs-keyword">var</span> _y = gamma ? gamma * degtorad : <span class="hljs-number">0</span>; <span class="hljs-comment">// gamma value</span>
  <span class="hljs-keyword">var</span> _z = alpha ? alpha * degtorad : <span class="hljs-number">0</span>; <span class="hljs-comment">// alpha value</span>

  <span class="hljs-keyword">var</span> cX = <span class="hljs-built_in">Math</span>.cos( _x/<span class="hljs-number">2</span> );
  <span class="hljs-keyword">var</span> cY = <span class="hljs-built_in">Math</span>.cos( _y/<span class="hljs-number">2</span> );
  <span class="hljs-keyword">var</span> cZ = <span class="hljs-built_in">Math</span>.cos( _z/<span class="hljs-number">2</span> );
  <span class="hljs-keyword">var</span> sX = <span class="hljs-built_in">Math</span>.sin( _x/<span class="hljs-number">2</span> );
  <span class="hljs-keyword">var</span> sY = <span class="hljs-built_in">Math</span>.sin( _y/<span class="hljs-number">2</span> );
  <span class="hljs-keyword">var</span> sZ = <span class="hljs-built_in">Math</span>.sin( _z/<span class="hljs-number">2</span> );

  <span class="hljs-keyword">var</span> w = cX * cY * cZ - sX * sY * sZ;
  <span class="hljs-keyword">var</span> x = sX * cY * cZ - cX * sY * sZ;
  <span class="hljs-keyword">var</span> y = cX * sY * cZ + sX * cY * sZ;
  <span class="hljs-keyword">var</span> z = cX * cY * sZ + sX * sY * cZ;

  <span class="hljs-keyword">return</span> [ w, x, y, z ];

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAcQuaternion</span>(<span class="hljs-params"> _w, _x, _y, _z </span>) </span>{  <span class="hljs-comment">//我的四元数转旋转轴和旋转角度方法</span>

  <span class="hljs-keyword">var</span> rotate = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.acos(_w)/degtorad ;

  <span class="hljs-keyword">var</span> x = _x / <span class="hljs-built_in">Math</span>.sin(degtorad * rotate/<span class="hljs-number">2</span>) || <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> y = _y / <span class="hljs-built_in">Math</span>.sin(degtorad * rotate/<span class="hljs-number">2</span>) || <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> z = _z / <span class="hljs-built_in">Math</span>.sin(degtorad * rotate/<span class="hljs-number">2</span>) || <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> {<span class="hljs-attr">x</span>:x,<span class="hljs-attr">y</span>:y,<span class="hljs-attr">z</span>:z,<span class="hljs-attr">rotate</span>:rotate};

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deviceMotionHandler</span>(<span class="hljs-params">evt</span>)</span>{  <span class="hljs-comment">// deviceorientation 事件处理函数</span>
  <span class="hljs-keyword">var</span> qu = getQuaternion(evt.alpha,evt.beta,evt.gamma);
  <span class="hljs-keyword">var</span> rotate3d = getAcQuaternion(qu[<span class="hljs-number">0</span>],qu[<span class="hljs-number">1</span>],qu[<span class="hljs-number">2</span>],qu[<span class="hljs-number">3</span>]);
  <span class="hljs-comment">// rotate3d的参数已经有了，随你处理咯。我是把他送给服务器，交给PC，在PC上显示旋转</span>
}
</code></pre>
<h3 id="articleHeader5"><strong>1.3 校准</strong></h3>
<p>这里有个3D里的概念，摄像机位置。我们的PC显示器就是一个摄像机。只能被动的从某一个角度展示拍摄的景象。正常情况下，手机所在平面应该和显示器所在平面平行，且垂直于地平面的角度。就好比是，摄像机正对着手机正面拍摄。<br>如果校准的时候手机并没有垂直于地平面，摄像机的位置就不一定是正前方了。这时候展示的画面并不是水平同步的了。<br>如下图所示，校准时，手机屏幕朝上。这时候摄像机位置就在天花板上了，你看到的成像就是俯视图。</p>
<p><span class="img-wrap"><img data-src="/img/remote/1460000005990689" src="https://static.alili.tech/img/remote/1460000005990689" alt="这里写图片描述" title="这里写图片描述" style="cursor: pointer;"></span></p>
<p>同理，校准时，手机屏幕朝下，这时候摄像机的位置就是在地上，往上拍摄，你看到的成像就是仰视图。</p>
<p>总结起来就是：<strong>校准时，手机屏幕朝着哪里，摄像机就在那里拍摄着屏幕，一动不动。</strong></p>
<h3 id="articleHeader6"><strong>1.4 兼容性</strong></h3>
<p>demo的兼容性测试并不理想<br>在iOS平台上测试良好，且流畅。</p>
<p>在安卓平台上，除了chrome浏览器之外的浏览器，会出现各种问题，主要表现在罗盘数据不准确。<br>而chrome浏览器并没有扫一扫功能，因为在国外并不流行这个玩意。所以在安卓平台上就很蛋疼，还要多装一个我查查，才能完整体验。<br>（如果出现旋转不准确的问题，可以尝试校准罗盘，大概就是拿着手机画8。百度一下方法有很多）</p>
<p><strong>代码如果有兼容写法，或者有其他兼容问题请赐教，可以在coding上私信我(OverTree )，不胜感激。</strong></p>
<h3 id="articleHeader7"><strong>2. PC浏览器端</strong></h3>
<p>PC浏览器的作用就是能够显示房间信息，创建房间。</p>
<p>显示房间，创建时间，参与人数，点击进入。<br>创建一个房间，成功后自动进入房间。</p>
<p>在房间内，接受服务器转发的手机端的消息，并作出相应动作，包括上线，校准，旋转，下线。</p>
<p>上线时，安排就坐（隐藏二维码，显示模型）<br>校准时，重新设置模型的显示角度。<br>旋转时，就旋转咯。<br>下线时，重新显示二维码（显示二维码，隐藏模型）</p>
<h3 id="articleHeader8"><strong>2.1初始化， 建立ws连接</strong></h3>
<p>重点是房间里的事情。所以这里就只介绍进入房间发生的事吧。<br>首先房间参数要正确，至少有房间编号。</p>
<p>房间路由:<br>/room/[roomNumber]<br>roomNumber是一串16位随机字符串。<br>座位路由:<br>/room/[roomNumber]/[seatNumber]</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var uri = win.location.pathname.split('/'),roomNumber;

function initUrlData(){
  if(uri.length>=3 &amp;&amp; uri[1] == &quot;room&quot;){
    roomNumber = uri[2];
    document.title = &quot;虚拟房间 &quot;+ roomNumber + &quot;号&quot;
    return 1;
  }else{
    window.location.href = &quot;/index&quot;;
    return 0;
  }
}

function initWebSocket(){
   var wsUri = &quot;ws://&quot;+ window.location.hostname +&quot;:<%= config.wsport %>&quot;+&quot;/ws/room&quot;; //这里用了一个ejs的占位符，已便在服务器更改websocket端口时可以及时使用正确端口。
   
   var websocket = new WebSocket(wsUri); 
   websocket.onopen = function(evt) { 
       websocket.send(JSON.stringify({room:roomNumber})); 
   }; //链接建立后，发送一个消息，表明在哪个房间

   websocket.onclose = function(evt) { 

   }; 

   websocket.onmessage = function(evt) { 
       parseMessage(evt.data) //解析数据
   }; 
   websocket.onerror = function(evt) { 

   }; 
   //绑定了这些处理函数之后，websocket开始建立链接，而不是 New 的时候开始建立
}


$(&quot;.room-place .qrcode&quot;).each(function(index,item){
    $(item).qrcode({
        &quot;size&quot;: 200,
        &quot;color&quot;: &quot;#3a3&quot;,
        &quot;text&quot;: window.location.origin + &quot;/room/&quot; + roomNumber + &quot;/&quot; + (index+1)
    });
    //这里用jQuery的插件，jquery-qrcode 按照座位路由初始化二维码
})

" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> uri = win.location.pathname.split(<span class="hljs-string">'/'</span>),roomNumber;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initUrlData</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">if</span>(uri.length&gt;=<span class="hljs-number">3</span> &amp;&amp; uri[<span class="hljs-number">1</span>] == <span class="hljs-string">"room"</span>){
    roomNumber = uri[<span class="hljs-number">2</span>];
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">"虚拟房间 "</span>+ roomNumber + <span class="hljs-string">"号"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }<span class="hljs-keyword">else</span>{
    <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">"/index"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initWebSocket</span>(<span class="hljs-params"></span>)</span>{
   <span class="hljs-keyword">var</span> wsUri = <span class="hljs-string">"ws://"</span>+ <span class="hljs-built_in">window</span>.location.hostname +<span class="hljs-string">":&lt;%= config.wsport %&gt;"</span>+<span class="hljs-string">"/ws/room"</span>; <span class="hljs-comment">//这里用了一个ejs的占位符，已便在服务器更改websocket端口时可以及时使用正确端口。</span>
   
   <span class="hljs-keyword">var</span> websocket = <span class="hljs-keyword">new</span> WebSocket(wsUri); 
   websocket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>{ 
       websocket.send(<span class="hljs-built_in">JSON</span>.stringify({<span class="hljs-attr">room</span>:roomNumber})); 
   }; <span class="hljs-comment">//链接建立后，发送一个消息，表明在哪个房间</span>

   websocket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>{ 

   }; 

   websocket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>{ 
       parseMessage(evt.data) <span class="hljs-comment">//解析数据</span>
   }; 
   websocket.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>{ 

   }; 
   <span class="hljs-comment">//绑定了这些处理函数之后，websocket开始建立链接，而不是 New 的时候开始建立</span>
}


$(<span class="hljs-string">".room-place .qrcode"</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index,item</span>)</span>{
    $(item).qrcode({
        <span class="hljs-string">"size"</span>: <span class="hljs-number">200</span>,
        <span class="hljs-string">"color"</span>: <span class="hljs-string">"#3a3"</span>,
        <span class="hljs-string">"text"</span>: <span class="hljs-built_in">window</span>.location.origin + <span class="hljs-string">"/room/"</span> + roomNumber + <span class="hljs-string">"/"</span> + (index+<span class="hljs-number">1</span>)
    });
    <span class="hljs-comment">//这里用jQuery的插件，jquery-qrcode 按照座位路由初始化二维码</span>
})

</code></pre>
<h3 id="articleHeader9"><strong>2.2 纯CSS3立体模型</strong></h3>
<p>做为一名普通的前端人员，想要画一个3D的模型，按照最熟悉的方法就是用CSS3了。<br>（如果是用Three.js的大神请跳过本节）<br>不过要很快画出一个六面体出来，还是需要想一想的，毕竟这个技能很少用。</p>
<p>画一个长方体</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<section class=&quot;container&quot;>
    <div id=&quot;box&quot; >
      <figure class=&quot;front&quot;><span>前</span></figure>
      <figure class=&quot;back&quot;><span>后</span></figure>
      <figure class=&quot;right&quot;><span>右</span></figure>
      <figure class=&quot;left&quot;><span>左</span></figure>
      <figure class=&quot;top&quot;><span>顶</span></figure>
      <figure class=&quot;bottom&quot;><span>底</span></figure>
    </div>
</section>
<style>
    *{
        margin: 0; /*不加会歪*/
    }
    .container {
      width: 300px;
      height: 200px;
      position: relative;
      perspective: 1200px;  /*摄像机距离，设置小的的话，立方体显示会变形*/
    }
    #box figure {
      display: block;
      position: absolute;
      border: 2px solid black;
      line-height: 200px;
      font-size: 40px;
      text-align: center;
      font-weight: bold;
      color: white;
      box-sizing: border-box; /*因为有2px宽的border，如果不设置为此值，那么每个面的宽高都要少设置4个像素，才能对齐*/
    }    
    #box {
      width: 100%;
      height: 100%;
      position: absolute;
      transform-style: preserve-3d;/*这个很重要，默认是平面变形flat*/
    }

    #box .front,
    #box .back {
      width: 300px;   
      height: 200px;
    }
    
    #box .right,
    #box .left {
      width: 100px;
      height: 200px;
      left:100px;     /*调整*/
    }
    
    #box .top,
    #box .bottom {
      width: 300px;
      height: 100px;
      top:50px;       /*调整*/
      line-height:100px;
    }

     /*给每个面上半透明的颜色*/
     #box .front  { background: hsla( 000, 100%, 50%, 0.7 ); }
     #box .back   { background: hsla( 160, 100%, 50%, 0.7 ); }
     #box .right  { background: hsla( 120, 100%, 50%, 0.7 ); }
     #box .left   { background: hsla( 180, 100%, 50%, 0.7 ); }
     #box .top    { background: hsla( 240, 100%, 50%, 0.7 ); }
     #box .bottom { background: hsla( 300, 100%, 50%, 0.7 ); }


     #box .front  { /*这个距离乘以2为前后面的距离*/
         transform: translateZ( 50px );
     }
     #box .back   { /*front面沿着x轴旋转180度，做后面*/
         transform: rotateX( -180deg ) translateZ(  50px );
     }
     #box .right {                 /*这个距离乘以2为左右面的距离*/
         transform: rotateY(   90deg ) translateZ( 150px );
     }
     #box .left {  /*front面沿着y轴旋转90度，做侧面*/
         transform: rotateY(  -90deg ) translateZ( 150px );
     }
     #box .top {                   /*这个距离乘以2为长方体高*/
         transform: rotateX(   90deg ) translateZ( 100px );
     }
     #box .bottom { /*front面沿着x轴旋转90度，做底面*/
         transform: rotateX(  -90deg ) translateZ( 100px );
     }
</style>
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="xml hljs"><code class="HTML"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box"</span> &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"front"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>前<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"back"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>后<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>右<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>左<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"top"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>顶<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bottom"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>底<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    *{
        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/*不加会歪*/</span>
    }
    <span class="hljs-selector-class">.container</span> {
      <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
      <span class="hljs-attribute">position</span>: relative;
      <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1200px</span>;  <span class="hljs-comment">/*摄像机距离，设置小的的话，立方体显示会变形*/</span>
    }
    <span class="hljs-selector-id">#box</span> <span class="hljs-selector-tag">figure</span> {
      <span class="hljs-attribute">display</span>: block;
      <span class="hljs-attribute">position</span>: absolute;
      <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;
      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;
      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;
      <span class="hljs-attribute">text-align</span>: center;
      <span class="hljs-attribute">font-weight</span>: bold;
      <span class="hljs-attribute">color</span>: white;
      <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/*因为有2px宽的border，如果不设置为此值，那么每个面的宽高都要少设置4个像素，才能对齐*/</span>
    }    
    <span class="hljs-selector-id">#box</span> {
      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
      <span class="hljs-attribute">position</span>: absolute;
      <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;<span class="hljs-comment">/*这个很重要，默认是平面变形flat*/</span>
    }

    <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.front</span>,
    <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.back</span> {
      <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;   
      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    }
    
    <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.right</span>,
    <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.left</span> {
      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
      <span class="hljs-attribute">left</span>:<span class="hljs-number">100px</span>;     <span class="hljs-comment">/*调整*/</span>
    }
    
    <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.top</span>,
    <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.bottom</span> {
      <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
      <span class="hljs-attribute">top</span>:<span class="hljs-number">50px</span>;       <span class="hljs-comment">/*调整*/</span>
      <span class="hljs-attribute">line-height</span>:<span class="hljs-number">100px</span>;
    }

     <span class="hljs-comment">/*给每个面上半透明的颜色*/</span>
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.front</span>  { <span class="hljs-attribute">background</span>: <span class="hljs-built_in">hsla</span>( 000, 100%, 50%, 0.7 ); }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.back</span>   { <span class="hljs-attribute">background</span>: <span class="hljs-built_in">hsla</span>( 160, 100%, 50%, 0.7 ); }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.right</span>  { <span class="hljs-attribute">background</span>: <span class="hljs-built_in">hsla</span>( 120, 100%, 50%, 0.7 ); }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.left</span>   { <span class="hljs-attribute">background</span>: <span class="hljs-built_in">hsla</span>( 180, 100%, 50%, 0.7 ); }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.top</span>    { <span class="hljs-attribute">background</span>: <span class="hljs-built_in">hsla</span>( 240, 100%, 50%, 0.7 ); }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.bottom</span> { <span class="hljs-attribute">background</span>: <span class="hljs-built_in">hsla</span>( 300, 100%, 50%, 0.7 ); }


     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.front</span>  { <span class="hljs-comment">/*这个距离乘以2为前后面的距离*/</span>
         <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>( 50px );
     }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.back</span>   { <span class="hljs-comment">/*front面沿着x轴旋转180度，做后面*/</span>
         <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>( -180deg ) <span class="hljs-built_in">translateZ</span>(  50px );
     }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.right</span> {                 <span class="hljs-comment">/*这个距离乘以2为左右面的距离*/</span>
         <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(   90deg ) <span class="hljs-built_in">translateZ</span>( 150px );
     }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.left</span> {  <span class="hljs-comment">/*front面沿着y轴旋转90度，做侧面*/</span>
         <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(  -90deg ) <span class="hljs-built_in">translateZ</span>( 150px );
     }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.top</span> {                   <span class="hljs-comment">/*这个距离乘以2为长方体高*/</span>
         <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(   90deg ) <span class="hljs-built_in">translateZ</span>( 100px );
     }
     <span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.bottom</span> { <span class="hljs-comment">/*front面沿着x轴旋转90度，做底面*/</span>
         <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(  -90deg ) <span class="hljs-built_in">translateZ</span>( 100px );
     }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p>对这样的css有什么要吐槽的么？</p>
<blockquote><p>这样的stylesheet简直是刀耕火种时期的</p></blockquote>
<p>如果用sass写法，那么只需要写一次#box和多层嵌套就可以了。</p>
<p>效果如下：<br><span class="img-wrap"><img data-src="/img/remote/1460000005990691" src="https://static.alili.tech/img/remote/1460000005990691" alt="这里写图片描述" title="这里写图片描述" style="cursor: pointer;"></span></p>
<p>如果我们使用webGL去绘制的话，导入一些现成的3D模型，无论物体还是人物，都可以360度无死角的玩弄于手掌了。<br>（如果有苍老师的模型，想想还有点小激动呢，VR的感觉说来就来啊 - -）</p>
<p>接下来就是等待来自手机端的旋转信息，x,y,z,angle，使#box进行transform旋转就是了。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="$seat.find(&quot;#box&quot;).
css(&quot;transform&quot;,&quot;rotate3d(&quot;
+ (-parseFloat(content.x))+&quot;,&quot;  //取反
+ (+parseFloat(content.y))+&quot;,&quot;
+ (-parseFloat(content.z))+&quot;,&quot;  //取反
+ content.rotate +&quot;deg)&quot;); 
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">$seat.find(<span class="hljs-string">"#box"</span>).
css(<span class="hljs-string">"transform"</span>,<span class="hljs-string">"rotate3d("</span>
+ (-<span class="hljs-built_in">parseFloat</span>(content.x))+<span class="hljs-string">","</span>  <span class="hljs-comment">//取反</span>
+ (+<span class="hljs-built_in">parseFloat</span>(content.y))+<span class="hljs-string">","</span>
+ (-<span class="hljs-built_in">parseFloat</span>(content.z))+<span class="hljs-string">","</span>  <span class="hljs-comment">//取反</span>
+ content.rotate +<span class="hljs-string">"deg)"</span>); 
</code></pre>
<p>不取反的话，旋转是错误的。我曾多次尝试给不同的坐标取反，最终得出这个取反方法，是唯一显示正常的组合。</p>
<p>无法理解这两个取反，猜测是因为css的x,y,z的坐标和物理设备x,y,z的坐标方向有差异吧。毕竟显示器是平面的，他的x,y,z的定义不能和手机传感器一致。</p>
<h3 id="articleHeader10"><strong>2.3 校准</strong></h3>
<p>PC端的校准就简单多了，在#box外套一层div.adjust。<br>当接受来自手机端的校准信息 x,y,z,angle，设置外套的 div.adjust 的旋转为 x,y,z,-angle 就好了。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="$seat.find(&quot;.adjust&quot;).
css(&quot;transform&quot;,&quot;rotate3d(&quot;
+ (-parseFloat(content.x))+&quot;,&quot;  
+ (+parseFloat(content.y))+&quot;,&quot;
+ (-parseFloat(content.z))+&quot;,&quot;  
+ (-parseFloat(content.rotate)) +&quot;deg)&quot;);  //取反
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">$seat.find(<span class="hljs-string">".adjust"</span>).
css(<span class="hljs-string">"transform"</span>,<span class="hljs-string">"rotate3d("</span>
+ (-<span class="hljs-built_in">parseFloat</span>(content.x))+<span class="hljs-string">","</span>  
+ (+<span class="hljs-built_in">parseFloat</span>(content.y))+<span class="hljs-string">","</span>
+ (-<span class="hljs-built_in">parseFloat</span>(content.z))+<span class="hljs-string">","</span>  
+ (-<span class="hljs-built_in">parseFloat</span>(content.rotate)) +<span class="hljs-string">"deg)"</span>);  <span class="hljs-comment">//取反</span>
</code></pre>
<p>当然，这个adjust的样式至少包含以下样式</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=".adjust{
  position: absolute;
  transform-style:preserve-3d;
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="css hljs"><code class="css"><span class="hljs-selector-class">.adjust</span>{
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">transform-style</span>:preserve-<span class="hljs-number">3</span>d;
}</code></pre>
<h3 id="articleHeader11"><strong>2.4 兼容性</strong></h3>
<p>PC端的兼容性就好多了，只要是现代H5浏览器基本上没有兼容性问题。</p>
<hr>
<h2 id="articleHeader12">服务端</h2>
<h3 id="articleHeader13">1.数据结构</h3>
<p>这个服务只做临时数据的保存和消息转发。<br>临时数据：比如，各端的webSocket连接句柄，房间信息等，我把它们放在global全局对象下，就好比是共享内存，访问方便，速度快。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="global.ShareMem = {
  rooms:{
       &quot;12345678&quot;:{          //房间号做为key，方便查找
         player:[{socket:connection,place:place}],          //手机端数组：连接句柄，座位号
         projector:[],       //PC端数组
         id:&quot;12345678&quot;,
         startTime:Date.now(),
         maxplayer:2,        //最多座位数
         type:&quot;ddd&quot;          //房间类型
       }
  }
};" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs dts"><code class="javascirpt">global.ShareMem = {
<span class="hljs-symbol">  rooms:</span>{
       <span class="hljs-string">"12345678"</span>:{          <span class="hljs-comment">//房间号做为key，方便查找</span>
<span class="hljs-symbol">         player:</span>[{socket:connection,place:place}],          <span class="hljs-comment">//手机端数组：连接句柄，座位号</span>
<span class="hljs-symbol">         projector:</span>[],       <span class="hljs-comment">//PC端数组</span>
<span class="hljs-symbol">         id:</span><span class="hljs-string">"12345678"</span>,
<span class="hljs-symbol">         startTime:</span>Date.now(),
<span class="hljs-symbol">         maxplayer:</span><span class="hljs-number">2</span>,        <span class="hljs-comment">//最多座位数</span>
<span class="hljs-symbol">         type:</span><span class="hljs-string">"ddd"</span>          <span class="hljs-comment">//房间类型</span>
       }
  }
};</code></pre>
<h3 id="articleHeader14">2.webServer</h3>
<p>如果您是nodejs的大神，或者在用koajs、express等nodejs框架，请跳过本大节。因为我用原生的nodejs写了一遍webServer，虽然重复造轮子不好，但是复习复习webServer的基本知识，还是不错的，本节适合新手入门。<br>包含知识点：header解析，静态文件查找，gzip，文件hash计算，状态码。</p>
<h3 id="articleHeader15">2.1 目录结构</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="/API
    /funMap.js            /*http功能函数集合*/
    /xxx.js
/socketAPI
    /funMap.js          /*webSocket功能函数集合*/
    /xxx.js
/Util                    /*工具目录，获取本地IP，打开默认浏览器*/
/webRoot
    /common             /*公共资源目录*/
        /js
            /lib
        /css
    /m                  /*移动端html,js,css等*/
    /p                  /*PC端html,js,css等*/
/index.js                  /*入口文件*/
/config.js                /*配置文件，端口号，ws最大数据包大小等*/
/socketServer.js        /*webSocket处理函数*/
/webServer.js           
    " title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code>/API
    /funMap<span class="hljs-selector-class">.js</span>            <span class="hljs-comment">/*http功能函数集合*/</span>
    /xxx<span class="hljs-selector-class">.js</span>
/socketAPI
    /funMap<span class="hljs-selector-class">.js</span>          <span class="hljs-comment">/*webSocket功能函数集合*/</span>
    /xxx<span class="hljs-selector-class">.js</span>
/Util                    <span class="hljs-comment">/*工具目录，获取本地IP，打开默认浏览器*/</span>
/webRoot
    /common             <span class="hljs-comment">/*公共资源目录*/</span>
        /js
            /lib
        /css
    /m                  <span class="hljs-comment">/*移动端html,js,css等*/</span>
    /<span class="hljs-selector-tag">p</span>                  <span class="hljs-comment">/*PC端html,js,css等*/</span>
/index<span class="hljs-selector-class">.js</span>                  <span class="hljs-comment">/*入口文件*/</span>
/config<span class="hljs-selector-class">.js</span>                <span class="hljs-comment">/*配置文件，端口号，ws最大数据包大小等*/</span>
/socketServer<span class="hljs-selector-class">.js</span>        <span class="hljs-comment">/*webSocket处理函数*/</span>
/webServer<span class="hljs-selector-class">.js</span>           
    </code></pre>
<h3 id="articleHeader16">2.2 webServer</h3>
<p>基本规则是这样的，搭建静态服务器，静态资源正常读取返回，html文件用ejs渲染后返回。</p>
<p>由于ejs的原因，html文件并没有被修改，但是渲染后的内容被修改，比如，更改了ws的端口，但是html文件没有修改。所以不能使用<code>Last-Modified</code>来判断是文件是否最新，而是要根据返回内容有没有被改变来判断，所以要用<code>Etag</code>。</p>
<p>Etag需要根据内容算出hash值，一般用md5计算。</p>
<p>返回内容之前，需要进行gzip压缩，用来节省带宽。90KB的jquery.min.js可以被gzip到30KB，压缩才是王道。</p>
<p>因为手机端和PC端执行的是完全不同的代码，所以要判断从客户端传过来的<code>user-agent</code>是否包含<code>Mobile</code>字符串，以来区分客户端是PC还是手机，以便返回正确的资源。</p>
<p>通过简单的约定，来区分静态文件和REST请求</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="    if (libPath.extname(pathName) == &quot;&quot;) {
      //如果路径没有扩展名 
      if(params.length<=2){
        pathName += &quot;/&quot;; //访问根目录 
      }else if(params[1]==&quot;api&quot;){   //访问以api开头
        parseAPI(params,req,res);  //功能函数
        return ;
      }else{
        pathName = params[1]+&quot;.html&quot;;
      }
    }" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs cs"><code class="javasciprt">    <span class="hljs-keyword">if</span> (libPath.extname(pathName) == <span class="hljs-string">""</span>) {
      <span class="hljs-comment">//如果路径没有扩展名 </span>
      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">params</span>.length&lt;=<span class="hljs-number">2</span>){
        pathName += <span class="hljs-string">"/"</span>; <span class="hljs-comment">//访问根目录 </span>
      }<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>[<span class="hljs-number">1</span>]==<span class="hljs-string">"api"</span></span>)</span>{   <span class="hljs-comment">//访问以api开头</span>
        parseAPI(<span class="hljs-keyword">params</span>,req,res);  <span class="hljs-comment">//功能函数</span>
        <span class="hljs-keyword">return</span> ;
      }<span class="hljs-keyword">else</span>{
        pathName = <span class="hljs-keyword">params</span>[<span class="hljs-number">1</span>]+<span class="hljs-string">".html"</span>;
      }
    }</code></pre>
<p>我在这里做了一个简单的框架，在API目录或者socketAPI目录下新增js文件，一个js文件对应一个处理函数，然后在funMap.js中聚合为一个Map，方便查找函数，也容易隔离和修改函数名。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var funMap = {
  &quot;room&quot;:require(&quot;./room&quot;),
  &quot;changeName&quot;:require(&quot;./xxx&quot;),
  &quot;changeName2&quot;:require(&quot;./xxxyyy&quot;)
};
module.exports = funMap;" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> funMap = {
  <span class="hljs-string">"room"</span>:<span class="hljs-built_in">require</span>(<span class="hljs-string">"./room"</span>),
  <span class="hljs-string">"changeName"</span>:<span class="hljs-built_in">require</span>(<span class="hljs-string">"./xxx"</span>),
  <span class="hljs-string">"changeName2"</span>:<span class="hljs-built_in">require</span>(<span class="hljs-string">"./xxxyyy"</span>)
};
<span class="hljs-built_in">module</span>.exports = funMap;</code></pre>
<p>客户端访问时就可以通过 /api/[functionName] 来访问想要的服务了。</p>
<h3 id="articleHeader17">3 webSocketServer</h3>
<p>nodejs本身并没有提供webSockerServer的模块，所以需要另外安装一个。</p>
<p>在npm install的时候会安装一个ws模块，require("ws") 就可以用了。用法与http模块相似，都用 <code>createServer({options},MainHandlerFunction)</code> 创建服务，只是ws多了几个参数。</p>
<p>主要是<code>port</code>，注意不要和webserver端口重复。<br>还有一个 <code>maxPayload</code> 就是单个ws数据包最大大小，单位是bytes，自己估计项目传输数据时候数据包大小。默认值是65535 即 64KB。一般webSocket用于小包传输，不用太大，我设置了1024 , 1KB。</p>
<p>主处理函数<code>MainHandlerFunction</code>，在有客户端连接进来时会传入一个参数<code>connection</code>,这个对象内容非常丰富，不看手册，可以打印出来也慢慢研究。<br>成功建立连接的方法就是要<code>connection</code>绑定<code>message</code>方法。</p>
<p>由于wsSocket访问是可以带着url的，所以我们可以用url隔离不同的功能函数，而不是去解析message主体。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var connectHandler = function(connection){
  // :4002/api/Function1 
  var URIarray = connection.upgradeReq.url.split(&quot;/&quot;)
  if(funMap[URIarray[2]]){
    funMap[URIarray[2]](connection);
  }else{
    connection.send(&quot;{err:Function Not Found!!}&quot;);
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> connectHandler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">connection</span>)</span>{
  <span class="hljs-comment">// :4002/api/Function1 </span>
  <span class="hljs-keyword">var</span> URIarray = connection.upgradeReq.url.split(<span class="hljs-string">"/"</span>)
  <span class="hljs-keyword">if</span>(funMap[URIarray[<span class="hljs-number">2</span>]]){
    funMap[URIarray[<span class="hljs-number">2</span>]](connection);
  }<span class="hljs-keyword">else</span>{
    connection.send(<span class="hljs-string">"{err:Function Not Found!!}"</span>);
  }
}</code></pre>
<h3 id="articleHeader18">3.1 消息，广播，保活</h3>
<p>每当有ws连接进来，都有类似文件描述符的id来区分每个不同的连接。<br><code>connection._ultron.id</code> 用它可以区分自己与别人的连接，很有用。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//消息格式
function msgPack(){
  return JSON.stringify({
    &quot;who&quot;:arguments[0],      // Mobile , PC
    &quot;place&quot;:arguments[1],    // 座位
    &quot;dowhat&quot;:arguments[2],   // &quot;connect&quot;,&quot;ready&quot;,&quot;message&quot;,&quot;lost&quot;
    &quot;content&quot;:arguments[3]||&quot;&quot; // 内容
  })
} 

//以room为单位广播，广播房间内所有角色
function boradCast(room,msg,ignore){
  room.projector.forEach(function(item,index){
    if(ignore&amp;&amp;ignore._ultron.id===item.socket._ultron.id){
      // console.log(&quot;ignore!!!&quot;)
      // 忽略自己不发送给自己
    }
    else{
      try{
        item.socket.send(msg);
      }catch(e){
        console.log(e);
      }
    }
  });
  room.player.forEach(function(item,index){
    if(ignore&amp;&amp;ignore._ultron.id===item.socket._ultron.id){
      // console.log(&quot;ignore!!!&quot;)
      // 忽略自己不发送给自己
    }
    else{
      try{
        item.socket.send(msg);
      }catch(e){
        console.log(e);
      }
    }
  });
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript"><span class="hljs-comment">//消息格式</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msgPack</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify({
    <span class="hljs-string">"who"</span>:<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>],      <span class="hljs-comment">// Mobile , PC</span>
    <span class="hljs-string">"place"</span>:<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>],    <span class="hljs-comment">// 座位</span>
    <span class="hljs-string">"dowhat"</span>:<span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>],   <span class="hljs-comment">// "connect","ready","message","lost"</span>
    <span class="hljs-string">"content"</span>:<span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>]||<span class="hljs-string">""</span> <span class="hljs-comment">// 内容</span>
  })
} 

<span class="hljs-comment">//以room为单位广播，广播房间内所有角色</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boradCast</span>(<span class="hljs-params">room,msg,ignore</span>)</span>{
  room.projector.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,index</span>)</span>{
    <span class="hljs-keyword">if</span>(ignore&amp;&amp;ignore._ultron.id===item.socket._ultron.id){
      <span class="hljs-comment">// console.log("ignore!!!")</span>
      <span class="hljs-comment">// 忽略自己不发送给自己</span>
    }
    <span class="hljs-keyword">else</span>{
      <span class="hljs-keyword">try</span>{
        item.socket.send(msg);
      }<span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e);
      }
    }
  });
  room.player.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,index</span>)</span>{
    <span class="hljs-keyword">if</span>(ignore&amp;&amp;ignore._ultron.id===item.socket._ultron.id){
      <span class="hljs-comment">// console.log("ignore!!!")</span>
      <span class="hljs-comment">// 忽略自己不发送给自己</span>
    }
    <span class="hljs-keyword">else</span>{
      <span class="hljs-keyword">try</span>{
        item.socket.send(msg);
      }<span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e);
      }
    }
  });
}</code></pre>
<p>为了检查客户端是否掉线，在建立连接时手动加入保活机制，方法很简单：<br>给客户端发送空消息时lastkeeplife为1，只要客户端返回任意消息，那么更新lastkeeplife为0，如果5秒之内，没有任何回复判定为掉线。<br>如果客户端掉线，那么关闭连接，从连接池中移除。并广播掉线消息给房间内其他角色。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  var keeplifeHandler = setInterval(function(){
    if(lastkeeplife == 0){
      connection.close();
      connection.emit(&quot;close&quot;);
      clearInterval(keeplifeHandler);
    }
    try{
      lastkeeplife = 0;
      connection.send(&quot;{}&quot;);
    }catch(e){
      console.log(&quot;keep live error! &quot;+ e +&quot;\n\n&quot;);
      connection.close();
      connection.emit(&quot;close&quot;);
      clearInterval(keeplifeHandler);
    }
  },5000)

  connection.on('close',function(msg){
      if(keeplifeHandler){  //关闭保活循环
        clearInterval(keeplifeHandler);
      }
      console.log(&quot;close!&quot;,roomid,place);
      var room = global.ShareMem.rooms[roomid];
      if(!room)
        return;
      
      //从连接池移除连接句柄
      if(platform === PC){
          room.projector.forEach(function(item,index){
              if(item.socket === connection){
                  room.projector.splice(index,1);
                  return false;
              }
          })
      }else{
          room.player.forEach(function(item,index){
              if(item.socket === connection){
                  room.player.splice(index,1);
                  return false;
              }
          })
      }
      //发送掉线消息
      boradCast( room, msgPack(platform,place,&quot;lost&quot;) , connection );
  });" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="javascript hljs"><code class="javascript">  <span class="hljs-keyword">var</span> keeplifeHandler = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">if</span>(lastkeeplife == <span class="hljs-number">0</span>){
      connection.close();
      connection.emit(<span class="hljs-string">"close"</span>);
      clearInterval(keeplifeHandler);
    }
    <span class="hljs-keyword">try</span>{
      lastkeeplife = <span class="hljs-number">0</span>;
      connection.send(<span class="hljs-string">"{}"</span>);
    }<span class="hljs-keyword">catch</span>(e){
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"keep live error! "</span>+ e +<span class="hljs-string">"\n\n"</span>);
      connection.close();
      connection.emit(<span class="hljs-string">"close"</span>);
      clearInterval(keeplifeHandler);
    }
  },<span class="hljs-number">5000</span>)

  connection.on(<span class="hljs-string">'close'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>{
      <span class="hljs-keyword">if</span>(keeplifeHandler){  <span class="hljs-comment">//关闭保活循环</span>
        clearInterval(keeplifeHandler);
      }
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"close!"</span>,roomid,place);
      <span class="hljs-keyword">var</span> room = global.ShareMem.rooms[roomid];
      <span class="hljs-keyword">if</span>(!room)
        <span class="hljs-keyword">return</span>;
      
      <span class="hljs-comment">//从连接池移除连接句柄</span>
      <span class="hljs-keyword">if</span>(platform === PC){
          room.projector.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,index</span>)</span>{
              <span class="hljs-keyword">if</span>(item.socket === connection){
                  room.projector.splice(index,<span class="hljs-number">1</span>);
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
          })
      }<span class="hljs-keyword">else</span>{
          room.player.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,index</span>)</span>{
              <span class="hljs-keyword">if</span>(item.socket === connection){
                  room.player.splice(index,<span class="hljs-number">1</span>);
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
          })
      }
      <span class="hljs-comment">//发送掉线消息</span>
      boradCast( room, msgPack(platform,place,<span class="hljs-string">"lost"</span>) , connection );
  });</code></pre>
<p>iOS设备如果锁屏，会发送断开信息给服务器，而安卓不会。想要断开链接，必须等到默认120秒超时后关闭。<br>ws初始化时并没有提供初始化timeout的配置。通过修改<br>ws._server.timeout = 1000;//1秒超时 <br>并不会生效。问题来了，怎么修改才能设置超时时间呢？</p>
<p>目前只能用上述比较捉急的方法来及时断开掉线设备。</p>
<h2 id="articleHeader19">最后</h2>
<p>多屏互动已经不是新鲜的东西了，我做这个Demo还是受chrome实验室一个叫做<a href="https://lightsaber.withgoogle.com" rel="nofollow noreferrer" target="_blank">【光剑出鞘】</a>的项目的启发。因为体验时需要手机端和PC同时翻-墙，导致体验差，然后自己才想做一个。做出来的时候感觉好酷炫，好神奇，好兴奋。<br>后续还是有很多可以拓展和改进的，希望最终可以变为一个成熟的产品，而不是仅仅止步于Demo。</p>
<h2 id="articleHeader20">相关阅读</h2>
<ul>
<li><p><a href="https://blog.maxleap.cn/archives/705" rel="nofollow noreferrer" target="_blank">无需Flash实现图片裁剪——HTML5中级进阶</a></p></li>
<li><p><a href="https://blog.maxleap.cn/archives/512" rel="nofollow noreferrer" target="_blank">5个提高Node.js应用性能的技巧</a></p></li>
<li><p><a href="https://blog.maxleap.cn/archives/555" rel="nofollow noreferrer" target="_blank">浏览器存储及使用</a></p></li>
</ul>
<hr>
<p><strong>作者信息</strong><br>作者来自力谱宿云 LeapCloud 团队_UX成员：王诗诗 【原创】<br>首发地址：<a href="https://blog.maxleap.cn/archives/985" rel="nofollow noreferrer" target="_blank">https://blog.maxleap.cn/archi...</a></p>
<p>王诗诗，前端新人，专职前端工作两年。曾供职于AMI做底层软件开发。喜欢分析H5代码，追崇用简单的CSS，构建精美动效，做前端之前，这些是业余爱好。现任职于MaxLeap UX 组，负责MaxWon 的开发和维护。现热衷于Real-time WebApp。</p>
<p>欢迎关注微信订阅号：MaxLeap_yidongyanfa</p>

                
{{< /raw >}}

# 版权声明
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，

本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。

原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文标题
多屏互动——H5 中级进阶

## 原文链接
[https://segmentfault.com/a/1190000005988744](https://segmentfault.com/a/1190000005988744)

